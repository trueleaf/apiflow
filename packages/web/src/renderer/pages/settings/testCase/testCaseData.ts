
// 原子功能(atomicFunc)里的一条用例
export interface AtomicFunc {
  purpose: string;
  precondition: { id: string; name: string }[];
  operationSteps: { id: string; name: string }[];
  expectedResults: { id: string; name: string }[];
  checkpoints: { id: string; name: string }[];
  notes: { id: string; name: string }[];
}

// 通用树节点
export interface ModelNode {
  modelName: string;
  description: string;
  children: ModelNode[];
  atomicFunc?: AtomicFunc[]; // 只有叶子节点才可能需要
}

/**
 * 整个模块的入口类型
 * 与 testCase 数组结构完全一致
 */
export type TestCase = ModelNode[];

export const testCase = [
  // 应用工作区管理
  {
    modelName: 'appWorkbench',
    description: '应用工作区',
    children: [
      {
        modelName: '工作区顶部',
        description: '工作区顶部',
        children: [
          // logo
          {
            modelName: 'logo',
            description: 'logo',
            atomicFunc: [
              {
                purpose: '点击logo跳转主页面',
                precondition: [
                  { id: '1', name: '应用已启动并加载完成' },
                  { id: '2', name: '当前不在主页面(可能在项目工作区或设置页面)' },
                  { id: '3', name: '顶部Header.vue组件已渲染' },
                ],
                operationSteps: [
                  { id: '1', name: '定位到顶部导航栏的Logo区域(Header.vue第4行)' },
                  { id: '2', name: '点击Logo图标(img元素, 绑定@click="jumpToHome")' },
                  { id: '3', name: '观察页面跳转效果' },
                ],
                expectedResults: [
                  { id: '1', name: '页面立即跳转到主页面(/home路由)' },
                  { id: '2', name: '所有Tab的高亮状态被清除(activeTabId.value设为空字符串)' },
                  { id: '3', name: '显示项目列表或主页内容' },
                  { id: '4', name: '通过IPC事件apiflow.topBarToContent.navigate发送导航指令到内容区' },
                ],
                checkpoints: [
                  { id: '1', name: 'jumpToHome方法被正确调用(Header.vue第251行)' },
                  { id: '2', name: 'activeTabId.value被设置为空字符串' },
                  { id: '3', name: 'syncActiveTabToContentView方法被执行, 同步Tab状态' },
                  { id: '4', name: 'IPC事件IPC_EVENTS.apiflow.topBarToContent.navigate被发送, 参数为"/home"' },
                  { id: '5', name: '内容区(contentView)接收到导航事件并执行路由跳转' },
                  { id: '6', name: '浏览器地址栏显示/#/home' },
                ],
                notes: [
                  { id: '1', name: 'Logo点击事件通过@click="jumpToHome"绑定' },
                  { id: '2', name: 'jumpToHome通过IPC通信在topBarView和contentView之间传递导航指令' },
                  { id: '3', name: 'Logo图标来源: appSettingsStore.appLogo计算属性' },
                  { id: '4', name: 'Logo具有draggable="false"属性防止拖拽' },
                ],
              },
              {
                purpose: '设置页面更改应用图标后logo立马被更新, 刷新页面保持更新后的图标',
                precondition: [
                  { id: '1', name: '应用已启动' },
                  { id: '2', name: '进入设置页面(通用设置或应用设置)' },
                  { id: '3', name: 'appSettingsStore已初始化' },
                  { id: '4', name: 'localStorage可用' },
                ],
                operationSteps: [
                  { id: '1', name: '在设置页面找到应用图标更改功能' },
                  { id: '2', name: '选择或上传新的图标文件' },
                  { id: '3', name: '调用appSettingsStore.setAppLogo(newLogoPath)设置新图标' },
                  { id: '4', name: '观察顶部Header的Logo是否立即更新' },
                  { id: '5', name: '按F5刷新页面' },
                  { id: '6', name: '等待页面重新加载完成' },
                  { id: '7', name: '观察Logo是否仍然显示为新设置的图标' },
                ],
                expectedResults: [
                  { id: '1', name: '步骤3执行后, 顶部Logo立即显示为新图标, 无需刷新页面' },
                  { id: '2', name: 'Logo的src属性值变更为新图标路径' },
                  { id: '3', name: '步骤5刷新后, Logo依然显示为新设置的图标' },
                  { id: '4', name: '新图标路径被持久化保存到localStorage' },
                  { id: '5', name: '关闭应用重新打开后, Logo仍显示为新图标' },
                ],
                checkpoints: [
                  { id: '1', name: 'appSettingsStore.setAppLogo方法正确更新_appLogo响应式变量' },
                  { id: '2', name: 'appSettingsCache.setAppLogo方法被调用,将新图标路径写入localStorage["settings/app/logo"]' },
                  { id: '3', name: 'appLogo计算属性(computed)立即响应变化,返回新图标路径' },
                  { id: '4', name: 'Header.vue中的img标签:src绑定自动更新(v-bind响应式)' },
                  { id: '5', name: 'localStorage["settings/app/logo"]存储值为新图标路径' },
                  { id: '6', name: '刷新页面后,appSettingsStore初始化时通过appSettingsCache.getAppLogo从localStorage读取图标路径' },
                  { id: '7', name: '如果localStorage中无自定义图标,appLogo计算属性返回defaultLogoImg(src/renderer/assets/imgs/logo.png)' },
                ],
                notes: [
                  { id: '1', name: 'Logo响应式更新基于Vue 3的computed属性和v-bind机制' },
                  { id: '2', name: 'appLogo定义: computed(() => _appLogo.value || defaultLogoImg)' },
                  { id: '3', name: '持久化存储键: cacheKey.settings.app.logo' },
                  { id: '4', name: 'setAppLogo方法会捕获localStorage写入错误并记录日志' },
                  { id: '5', name: '默认Logo图标路径: src/renderer/assets/imgs/logo.png' },
                  { id: '6', name: 'Logo更新会通过IPC事件appSettingsChanged同步到contentView' },
                ],
              },
            ],
          },
          // 导航
          {
            modelName: '导航',
            description: '导航',
            atomicFunc: [
              {
                purpose: '项目tab显示项目图标,设置tab显示设置图标',
                precondition: [
                  { id: '1', name: '应用已启动' },
                  { id: '2', name: '已打开至少一个项目Tab' },
                  { id: '3', name: '已打开至少一个设置Tab' },
                  { id: '4', name: 'Header.vue组件已渲染' },
                ],
                operationSteps: [
                  { id: '1', name: '观察顶部导航栏的Tab列表' },
                  { id: '2', name: '找到类型为project的Tab项' },
                  { id: '3', name: '观察项目Tab的图标显示' },
                  { id: '4', name: '找到类型为settings的Tab项' },
                  { id: '5', name: '观察设置Tab的图标显示' },
                ],
                expectedResults: [
                  { id: '1', name: '所有类型为project的Tab显示Folder图标(文件夹图标)' },
                  { id: '2', name: '所有类型为settings的Tab显示Settings图标(齿轮图标)' },
                  { id: '3', name: '图标显示在Tab标题的左侧' },
                  { id: '4', name: '图标来自lucide-vue-next图标库' },
                  { id: '5', name: '图标具有tab-icon类名' },
                ],
                checkpoints: [
                  { id: '1', name: 'Header.vue第14-24行使用draggable组件渲染Tab列表' },
                  { id: '2', name: '项目Tab通过v-if="tab.type === \'project\'"条件渲染Folder组件' },
                  { id: '3', name: '设置Tab通过v-if="tab.type === \'settings\'"条件渲染Settings组件' },
                  { id: '4', name: 'Tab数据结构AppWorkbenchHeaderTab包含type字段(\'project\' | \'settings\')' },
                  { id: '5', name: '每个Tab项的template中按顺序渲染: 图标 -> 标题 -> 关闭按钮' },
                ],
                notes: [
                  { id: '1', name: 'Tab图标通过Vue条件渲染实现,不同type显示不同图标组件' },
                  { id: '2', name: 'Folder和Settings组件来自lucide-vue-next库' },
                  { id: '3', name: 'Tab类型定义:export type AppWorkbenchHeaderTab.type = \'project\' | \'settings\'' },
                  { id: '4', name: 'Tab图标CSS类名为.tab-icon,用于统一样式控制' },
                ],
              },
              {
                purpose: '新建项目,打开设置会新增tab,点击编辑按钮并且不存在对应项目tab时候会新增tab',
                precondition: [
                  { id: '1', name: '应用已启动' },
                  { id: '2', name: '当前在主页面或其他页面' },
                  { id: '3', name: '没有打开目标项目或设置的Tab' },
                  { id: '4', name: 'tabs响应式数组可用' },
                ],
                operationSteps: [
                  { id: '1', name: '场景1: 点击顶部导航栏的"新建项目"按钮(+按钮)' },
                  { id: '2', name: '填写项目信息并确认创建' },
                  { id: '3', name: '观察Tab列表变化' },
                  { id: '4', name: '场景2: 点击顶部导航栏的设置图标按钮(齿轮图标)' },
                  { id: '5', name: '观察Tab列表变化' },
                  { id: '6', name: '场景3:在项目列表页点击某个项目的"编辑"按钮' },
                  { id: '7', name: '观察Tab列表变化' },
                ],
                expectedResults: [
                  { id: '1', name: '场景1:项目创建成功后,Tab列表自动新增一个项目Tab' },
                  { id: '2', name: '新项目Tab显示项目名称和Folder图标,且被自动高亮(激活状态)' },
                  { id: '3', name: '新项目Tab插入到正确的位置(项目Tab按网络模式分组,在同模式最后一个项目之后)' },
                  { id: '4', name: '场景2:点击设置按钮后,Tab列表新增一个设置Tab' },
                  { id: '5', name: '设置Tab显示"设置"文字和Settings图标,且被自动高亮' },
                  { id: '6', name: '设置Tab插入到Tab列表末尾(设置Tab始终在项目Tab之后)' },
                  { id: '7', name: '场景3:点击编辑按钮后,如果该项目Tab不存在,则新增项目Tab并高亮' },
                  { id: '8', name: '如果该项目Tab已存在,则不新增,仅高亮已有Tab' },
                ],
                checkpoints: [
                  { id: '1', name: '新建项目: 监听IPC_EVENTS.apiflow.topBarToContent.projectCreated事件(Header.vue第302-309行)' },
                  { id: '2', name: '事件处理中调用getProjectTabInsertIndex()计算插入位置' },
                  { id: '3', name: '使用tabs.value.splice(insertIndex, 0, newTab)在指定位置插入Tab' },
                  { id: '4', name: '新Tab结构包含:{id: projectId, title: projectName, type: \'project\', network: networkMode}' },
                  { id: '5', name: '插入后调用syncTabsToContentView()同步Tab状态到contentView' },
                  { id: '6', name: '设置activeTabId.value为新Tab的id,实现自动高亮' },
                  { id: '7', name: '打开设置: jumpToSettings方法(Header.vue第257-270行)中检查settings Tab是否存在' },
                  { id: '8', name: '如果不存在,使用tabs.value.push()在末尾添加设置Tab' },
                  { id: '9', name: '设置Tab的id格式为: `settings-${networkMode.value}` (区分在线/离线模式)' },
                  { id: '10', name: '编辑项目:通过switchTab检查Tab是否存在,不存在则触发创建逻辑' },
                ],
                notes: [
                  { id: '1', name: 'Tab新增逻辑分为两种:项目Tab通过splice插入,设置Tab通过push追加' },
                  { id: '2', name: 'getProjectTabInsertIndex方法确保项目Tab始终在同网络模式的项目Tab组内' },
                  { id: '3', name: '每个Tab有唯一id:项目Tab使用projectId,设置Tab使用"settings-{networkMode}"' },
                  { id: '4', name: 'Tab新增后立即调用syncTabsToContentView和syncActiveTabToContentView同步状态' },
                  { id: '5', name: 'Tab按网络模式分组管理(online/offline), 切换网络模式会过滤显示对应Tab' },
                ],
              },
              {
                purpose: '点击编辑项目,项目内切换项目或点击设置,如果tab已存在则高亮当前tab,如果tab不存在则新增tab并高亮当前tab',
                precondition: [
                  { id: '1', name: '应用已启动' },
                  { id: '2', name: '已打开一个或多个项目Tab和设置Tab' },
                  { id: '3', name: '当前有一个Tab处于激活(高亮)状态' },
                ],
                operationSteps: [
                  { id: '1', name: '场景1:点击已打开项目Tab对应的编辑按钮' },
                  { id: '2', name: '观察Tab是否新增以及高亮状态变化' },
                  { id: '3', name: '场景2:点击未打开项目Tab对应的编辑按钮' },
                  { id: '4', name: '观察Tab是否新增以及高亮状态变化' },
                  { id: '5', name: '场景3:在项目内通过项目切换功能切换到已打开Tab的项目' },
                  { id: '6', name: '观察Tab变化' },
                  { id: '7', name: '场景4:在项目内切换到未打开Tab的项目' },
                  { id: '8', name: '观察Tab变化' },
                  { id: '9', name: '场景5:点击已打开的设置Tab对应的设置按钮' },
                  { id: '10', name: '观察Tab变化' },
                ],
                expectedResults: [
                  { id: '1', name: '场景1:不新增Tab,已有的项目Tab被高亮,原高亮Tab失去高亮状态' },
                  { id: '2', name: '内容区域切换到对应项目的工作区' },
                  { id: '3', name: '场景2:新增一个项目Tab并自动高亮,内容区域显示该项目工作区' },
                  { id: '4', name: '场景3:不新增Tab,已有的目标项目Tab被高亮' },
                  { id: '5', name: '场景4:新增目标项目Tab并自动高亮' },
                  { id: '6', name: '场景5:不新增Tab,已有的设置Tab被高亮,内容区域切换到设置页面' },
                  { id: '7', name: '所有高亮切换都伴随内容区域的对应页面切换' },
                  { id: '8', name: 'Tab高亮状态通过.active类名实现视觉反馈' },
                ],
                checkpoints: [
                  { id: '1', name: 'switchTab方法(Header.vue第231-235行)负责切换Tab高亮状态' },
                  { id: '2', name: 'switchTab中更新activeTabId.value为目标Tab的id' },
                  { id: '3', name: '调用syncActiveTabToContentView同步激活状态到contentView' },
                  { id: '4', name: '调用scrollToActiveTab确保激活的Tab在可视区域内' },
                  { id: '5', name: 'Tab的active类名通过计算属性绑定::class="[\'tab-item\', { active: tab.id === activeTabId }]"' },
                  { id: '6', name: '编辑按钮点击后,先查找tabs.value.find(t => t.id === projectId)检查Tab是否存在' },
                  { id: '7', name: 'Tab存在时直接调用switchTab(tabId)高亮' },
                  { id: '8', name: 'Tab不存在时先创建Tab(splice或push), 再调用switchTab高亮新Tab' },
                  { id: '9', name: '项目切换通过IPC事件apiflow.topBarToContent.projectChanged触发' },
                  { id: '10', name: '设置Tab通过jumpToSettings方法处理,使用existingTab变量检查是否已存在' },
                ],
                notes: [
                  { id: '1', name: 'Tab高亮状态由activeTabId响应式变量控制,任意时刻只有一个Tab处于高亮状态' },
                  { id: '2', name: 'switchTab方法是Tab高亮的统一入口,确保状态同步' },
                  { id: '3', name: 'Tab的存在性检查通过Array.find方法实现' },
                  { id: '4', name: '内容区域的页面切换通过IPC事件通信实现,topBarView发送事件,contentView响应' },
                  { id: '5', name: 'scrollToActiveTab使用scrollIntoView API确保激活Tab可见' },
                ],
              },
              {
                purpose: 'tab存在默认排序,项目在前,其他在后',
                precondition: [
                  { id: '1', name: '应用已启动' },
                  { id: '2', name: '打开了多个项目Tab和设置Tab的混合场景' },
                  { id: '3', name: '可能存在在线模式和离线模式的Tab混合' },
                ],
                operationSteps: [
                  { id: '1', name: '创建或打开3个项目Tab(项目A,B,C)' },
                  { id: '2', name: '打开一个设置Tab' },
                  { id: '3', name: '再创建一个新项目Tab(项目D)' },
                  { id: '4', name: '观察Tab列表的排列顺序' },
                  { id: '5', name: '切换网络模式(从在线切换到离线或相反)' },
                  { id: '6', name: '观察Tab排序是否保持规则' },
                ],
                expectedResults: [
                  { id: '1', name: '所有项目Tab(A,B,C,D)排列在前面' },
                  { id: '2', name: '设置Tab排列在所有项目Tab之后' },
                  { id: '3', name: '项目Tab内部按照创建或打开的时间顺序排列' },
                  { id: '4', name: '新创建的项目Tab插入到同网络模式的最后一个项目Tab之后,设置Tab之前' },
                  { id: '5', name: '切换网络模式后,只显示当前网络模式的Tab,但排序规则依然保持' },
                  { id: '6', name: 'Tab排序规则:[在线项目Tab组] + [离线项目Tab组] + [在线设置Tab] + [离线设置Tab]' },
                ],
                checkpoints: [
                  { id: '1', name: 'getProjectTabInsertIndex方法(Header.vue第102-114行)计算项目Tab插入位置' },
                  { id: '2', name: '该方法首先过滤当前网络模式的Tab:currentNetworkTabs = tabs.value.filter(tab => tab.network === networkMode.value)' },
                  { id: '3', name: '使用reduce方法找到同模式下最后一个项目Tab的索引:lastProjectIndex' },
                  { id: '4', name: '项目Tab插入到lastProjectIndex + 1位置,确保在设置Tab之前' },
                  { id: '5', name: '设置Tab通过tabs.value.push()追加到数组末尾,天然排在最后' },
                  { id: '6', name: 'Tab按network字段(\'online\' | \'offline\')分组' },
                  { id: '7', name: 'draggable组件的v-model绑定draggableTabs计算属性,过滤显示当前网络模式的Tab' },
                  { id: '8', name: 'draggableTabs = computed(() => tabs.value.filter(tab => tab.network === networkMode.value))' },
                  { id: '9', name: 'Tab的network字段在创建时自动设置为当前networkMode.value' },
                ],
                notes: [
                  { id: '1', name: 'Tab排序规则由getProjectTabInsertIndex方法强制保证,不依赖用户操作' },
                  { id: '2', name: '项目Tab和设置Tab的分离通过type字段(\'project\' | \'settings\')区分' },
                  { id: '3', name: 'Tab的网络模式分组机制支持在线/离线场景的独立管理' },
                  { id: '4', name: '切换网络模式时,Tab数组不变,仅通过计算属性过滤显示' },
                  { id: '5', name: 'Tab排序规则确保用户界面的一致性和可预测性' },
                ],
              },
              {
                purpose: '可以拖拽tab和可以关闭tab,若高亮当前tab,关闭后,当前tab高亮左侧最近一个tab,并且内容区域切换为当前tab所对应的内容',
                precondition: [
                  { id: '1', name: '应用已启动' },
                  { id: '2', name: '已打开至少3个Tab(便于测试拖拽和关闭逻辑)' },
                  { id: '3', name: '当前有一个Tab处于高亮状态' },
                  { id: '4', name: 'draggable组件已正确加载(vue.draggable.next库)' },
                ],
                operationSteps: [
                  { id: '1', name: '测试拖拽:鼠标左键按住Tab A' },
                  { id: '2', name: '拖动到Tab B和Tab C之间的位置' },
                  { id: '3', name: '释放鼠标,观察Tab A的位置变化' },
                  { id: '4', name: '测试关闭非高亮Tab:点击Tab B的关闭按钮(x图标)' },
                  { id: '5', name: '观察Tab B是否被移除,其他Tab的高亮状态是否保持' },
                  { id: '6', name: '测试关闭高亮Tab:将Tab C设为高亮状态' },
                  { id: '7', name: '点击Tab C的关闭按钮' },
                  { id: '8', name: '观察Tab C被关闭后,哪个Tab自动获得高亮' },
                  { id: '9', name: '观察内容区域是否切换到新高亮Tab对应的内容' },
                ],
                expectedResults: [
                  { id: '1', name: '拖拽:Tab A成功移动到Tab B和Tab C之间,Tab顺序变为:...Tab B - Tab A - Tab C...' },
                  { id: '2', name: '拖拽过程中显示拖拽占位符(ghost-class样式)' },
                  { id: '3', name: '拖拽结束后Tab列表顺序更新,并同步到localStorage和contentView' },
                  { id: '4', name: '关闭非高亮Tab:Tab B从列表中移除,当前高亮Tab保持不变' },
                  { id: '5', name: '关闭高亮Tab:Tab C被移除,自动高亮左侧最近的Tab(如果左侧无Tab则高亮右侧第一个Tab)' },
                  { id: '6', name: '如果关闭高亮Tab后无其他同网络模式Tab,自动跳转到主页面(/home)' },
                  { id: '7', name: '内容区域立即切换到新高亮Tab对应的页面内容' },
                  { id: '8', name: '关闭按钮支持事件冒泡阻止(@click.stop),点击关闭按钮不会触发Tab切换' },
                ],
                checkpoints: [
                  { id: '1', name: 'draggable组件配置(Header.vue第14-24行):v-model="draggableTabs", animation="150", ghost-class="sortable-ghost"' },
                  { id: '2', name: 'draggableTabs是计算属性,过滤当前网络模式的Tab' },
                  { id: '3', name: '拖拽结束后自动触发tabs.value更新,调用syncTabsToContentView同步' },
                  { id: '4', name: 'deleteTab方法(Header.vue第211-230行)处理Tab关闭逻辑' },
                  { id: '5', name: 'deleteTab首先检查要关闭的Tab是否为当前高亮Tab:wasActive = activeTabId.value === tabId' },
                  { id: '6', name: '使用filter方法移除目标Tab:tabs.value = tabs.value.filter(t => t.id !== tabId)' },
                  { id: '7', name: '过滤当前网络模式的Tab:currentNetworkTabs = tabs.value.filter(tab => tab.network === networkMode.value)' },
                  { id: '8', name: '如果没有同模式Tab剩余,调用jumpToHome()跳转主页' },
                  { id: '9', name: '如果关闭的是高亮Tab,找到关闭位置index,从该位置向右查找同模式Tab' },
                  { id: '10', name: '如果右侧无Tab,则选择同模式Tab数组的最后一个Tab' },
                  { id: '11', name: '调用switchTab(newActiveTabId)切换到新的高亮Tab' },
                  { id: '12', name: '关闭按钮使用@click.stop阻止事件冒泡,避免触发Tab的@click事件' },
                ],
                notes: [
                  { id: '1', name: 'Tab拖拽功能基于vue.draggable.next库(Vue 3版本的draggable)' },
                  { id: '2', name: 'draggable通过v-model双向绑定,拖拽操作自动更新绑定的数组' },
                  { id: '3', name: 'ghost-class="sortable-ghost"定义拖拽占位符的CSS类名' },
                  { id: '4', name: 'Tab关闭逻辑考虑了网络模式分组,关闭后只在同模式Tab中选择新的激活Tab' },
                  { id: '5', name: '关闭高亮Tab的新激活逻辑:优先选择右侧Tab,无右侧Tab则选择最后一个同模式Tab' },
                  { id: '6', name: 'syncTabsToContentView确保Tab列表在topBarView和contentView之间保持同步' },
                ],
              },
              {
                purpose: '更新项目名称后,tab页签名称更新,删除项目后,tab页签关闭',
                precondition: [
                  { id: '1', name: '应用已启动' },
                  { id: '2', name: '已打开一个或多个项目Tab' },
                  { id: '3', name: '项目名称可修改(在项目设置或项目列表中)' },
                  { id: '4', name: 'IPC通信正常工作' },
                ],
                operationSteps: [
                  { id: '1', name: '场景1:打开项目A的Tab' },
                  { id: '2', name: '在项目设置或项目列表中将项目A重命名为"新项目名称"' },
                  { id: '3', name: '保存修改' },
                  { id: '4', name: '观察顶部Tab列表中项目A的Tab标题是否更新' },
                  { id: '5', name: '场景2:打开项目B的Tab' },
                  { id: '6', name: '在项目列表中删除项目B' },
                  { id: '7', name: '确认删除操作' },
                  { id: '8', name: '观察顶部Tab列表中项目B的Tab是否被移除' },
                  { id: '9', name: '如果项目B的Tab是高亮状态,观察是否自动切换到其他Tab' },
                ],
                expectedResults: [
                  { id: '1', name: '场景1:项目A重命名后,其Tab标题立即更新为"新项目名称",无需刷新页面' },
                  { id: '2', name: 'Tab的图标(Folder)保持不变,仅标题文字更新' },
                  { id: '3', name: 'Tab的id(projectId)保持不变,不影响高亮状态和内容区域' },
                  { id: '4', name: '场景2:项目B删除后,其Tab立即从Tab列表中移除' },
                  { id: '5', name: '如果删除的项目Tab是高亮状态,自动切换到相邻Tab或主页面' },
                  { id: '6', name: '内容区域自动切换到新的高亮Tab对应的内容或主页面' },
                  { id: '7', name: '删除操作同步到contentView,contentView也执行相应的清理逻辑' },
                ],
                checkpoints: [
                  { id: '1', name: '项目重命名:监听IPC_EVENTS.apiflow.topBarToContent.projectRenamed事件(Header.vue第330-336行)' },
                  { id: '2', name: '事件payload包含{projectId: string, projectName: string}' },
                  { id: '3', name: '通过tabs.value.findIndex(t => t.id === data.projectId)查找目标Tab' },
                  { id: '4', name: '找到后更新tabs.value[index].title = data.projectName' },
                  { id: '5', name: '调用syncTabsToContentView同步Tab列表到contentView' },
                  { id: '6', name: '项目删除:监听IPC_EVENTS.apiflow.topBarToContent.projectDeleted事件(Header.vue第338-344行)' },
                  { id: '7', name: '事件payload包含{projectId: string}' },
                  { id: '8', name: '调用deleteTab(data.projectId)方法移除对应的Tab' },
                  { id: '9', name: 'deleteTab方法会自动处理高亮Tab的切换逻辑(如前述)' },
                  { id: '10', name: 'Tab标题通过{{ tab.title }}模板语法绑定,响应式更新' },
                ],
                notes: [
                  { id: '1', name: 'Tab名称更新基于Vue 3的响应式系统,修改tabs数组元素的title属性会自动触发UI更新' },
                  { id: '2', name: '项目重命名和删除事件由contentView触发,topBarView监听并响应' },
                  { id: '3', name: 'IPC事件确保topBarView和contentView的数据同步' },
                  { id: '4', name: '项目删除时,除了移除Tab,还会触发相关的数据清理(如缓存,历史记录等)' },
                  { id: '5', name: 'syncTabsToContentView方法确保Tab列表在两个WebContentsView之间保持一致' },
                ],
              },
            ],
          },
          // 导航控制
          {
            modelName: 'navControl',
            description: '导航控制',
            atomicFunc: [
              {
                purpose: '点击刷新按钮,关闭并重启项目',
                precondition: [
                  { id: '1', name: '应用已启动(Electron应用)' },
                  { id: '2', name: '已打开一个或多个项目Tab或设置Tab' },
                  { id: '3', name: '顶部Header导航栏已渲染' },
                  { id: '4', name: 'IPC通信正常工作' },
                ],
                operationSteps: [
                  { id: '1', name: '定位到顶部Header导航栏的刷新按钮(RefreshRight图标)' },
                  { id: '2', name: '点击刷新按钮(data-testid="header-refresh-btn")' },
                  { id: '3', name: '观察应用的行为' },
                  { id: '4', name: '等待应用重启完成' },
                  { id: '5', name: '验证之前打开的Tab和状态是否保持' },
                ],
                expectedResults: [
                  { id: '1', name: '打包模式(生产环境):应用完全关闭并自动重启' },
                  { id: '2', name: '开发模式:topBarView和contentView执行reloadIgnoringCache,清除缓存并刷新页面' },
                  { id: '3', name: '应用重启后,之前打开的Tab列表从localStorage恢复' },
                  { id: '4', name: '之前高亮的Tab保持高亮状态(如果存在)' },
                  { id: '5', name: '用户数据,项目数据,设置等持久化数据保持不变' },
                  { id: '6', name: '刷新操作不会导致数据丢失或损坏' },
                ],
                checkpoints: [
                  { id: '1', name: 'Header.vue第143-153行定义refreshApp方法和按钮' },
                  { id: '2', name: 'refreshApp方法调用window.electronAPI?.ipcManager.sendToMain(IPC_EVENTS.apiflow.rendererToMain.refreshApp)' },
                  { id: '3', name: '主进程监听IPC事件:ipcMain.on(IPC_EVENTS.apiflow.rendererToMain.refreshApp, ...)(ipcMessage/index.ts第375-394行)' },
                  { id: '4', name: '打包模式判断:app.isPackaged === true' },
                  { id: '5', name: '打包模式执行:app.relaunch()重启应用 + app.exit()退出当前实例' },
                  { id: '6', name: '开发模式执行:topBarView.webContents.reloadIgnoringCache() + contentView.webContents.reloadIgnoringCache()' },
                  { id: '7', name: 'reloadIgnoringCache清除HTTP缓存并刷新页面,相当于硬刷新(Ctrl+Shift+R)' },
                  { id: '8', name: 'Tab列表通过appWorkbenchCache.getAppWorkbenchHeaderTabs()从localStorage恢复' },
                  { id: '9', name: '高亮Tab通过appWorkbenchCache.getAppWorkbenchHeaderActiveTab()恢复' },
                ],
                notes: [
                  { id: '1', name: '刷新功能区分开发和生产环境,提供不同的刷新策略' },
                  { id: '2', name: '生产环境使用app.relaunch确保完全重启,适用于更新后的重载场景' },
                  { id: '3', name: '开发环境使用reloadIgnoringCache提高开发效率,避免完全重启Electron' },
                  { id: '4', name: 'IPC事件名称:IPC_EVENTS.apiflow.rendererToMain.refreshApp' },
                  { id: '5', name: '刷新按钮title提示文字:t("刷新主应用")' },
                ],
              },
              {
                purpose: '初始状态,项目A切换项目B,然后换到项目C,然后切换到项目A,然后切换到设置,点击后退按钮切换到项目A,再点击后退切换到项目C,再点击后退按钮切换到B,再点击后退按钮切换到A.点击前进需要恢复之前逻辑',
                precondition: [
                  { id: '1', name: '应用已启动' },
                  { id: '2', name: '已创建项目A,项目B,项目C' },
                  { id: '3', name: '当前在主页面(初始状态)' },
                  { id: '4', name: 'Vue Router正常工作' },
                  { id: '5', name: '前进/后退按钮已渲染在Header导航栏' },
                ],
                operationSteps: [
                  { id: '1', name: '初始状态:在主页面' },
                  { id: '2', name: '点击项目A的编辑按钮,进入项目A工作区' },
                  { id: '3', name: '点击项目B的编辑按钮或通过项目切换功能切换到项目B' },
                  { id: '4', name: '切换到项目C' },
                  { id: '5', name: '切换回项目A' },
                  { id: '6', name: '点击设置按钮,进入设置页面' },
                  { id: '7', name: '点击Header的后退按钮(Back图标,data-testid="header-back-btn")' },
                  { id: '8', name: '观察页面变化,应回到项目A' },
                  { id: '9', name: '再次点击后退按钮' },
                  { id: '10', name: '观察页面变化,应回到项目C' },
                  { id: '11', name: '再次点击后退按钮' },
                  { id: '12', name: '观察页面变化,应回到项目B' },
                  { id: '13', name: '再次点击后退按钮' },
                  { id: '14', name: '观察页面变化,应回到项目A' },
                  { id: '15', name: '点击Header的前进按钮(Right图标,data-testid="header-forward-btn")' },
                  { id: '16', name: '观察页面变化,应前进到项目B' },
                  { id: '17', name: '继续点击前进按钮,验证是否按C->A->设置的顺序前进' },
                ],
                expectedResults: [
                  { id: '1', name: '后退按钮点击后,页面按导航历史栈的逆序依次回退:设置->A->C->B->A' },
                  { id: '2', name: '每次后退,内容区域切换到对应的页面,对应Tab被高亮' },
                  { id: '3', name: '后退到项目页面时,项目工作区正确加载对应项目的数据' },
                  { id: '4', name: '前进按钮点击后,页面按导航历史栈的正序依次前进:A->B->C->A->设置' },
                  { id: '5', name: '前进和后退操作不会创建新的历史记录,仅在已有历史栈中移动' },
                  { id: '6', name: '如果历史栈为空或已到达栈底,后退按钮跳转到主页面(/)' },
                  { id: '7', name: '导航历史栈由Vue Router管理,支持完整的SPA路由历史' },
                ],
                checkpoints: [
                  { id: '1', name: 'Header.vue第143-153行定义goBack和goForward方法及按钮' },
                  { id: '2', name: 'goBack调用window.electronAPI?.ipcManager.sendToMain(IPC_EVENTS.apiflow.rendererToMain.goBack)' },
                  { id: '3', name: 'goForward调用window.electronAPI?.ipcManager.sendToMain(IPC_EVENTS.apiflow.rendererToMain.goForward)' },
                  { id: '4', name: '主进程转发IPC事件到contentView:contentView.webContents.send(IPC_EVENTS.apiflow.rendererToMain.goBack)' },
                  { id: '5', name: 'App.vue监听IPC事件:window.electronAPI?.ipcManager.onMain(IPC_EVENTS.apiflow.rendererToMain.goBack, handleGoBack)' },
                  { id: '6', name: 'handleGoBack方法(App.vue第78-89行):window.history.length > 1 ? router.back() : router.push("/")' },
                  { id: '7', name: 'handleGoForward方法(App.vue):router.forward()' },
                  { id: '8', name: 'Vue Router的router.back()和router.forward()操作浏览器历史栈' },
                  { id: '9', name: '导航历史栈包含完整的路由路径,如/project/:projectId,/settings等' },
                  { id: '10', name: '每次项目切换通过router.push()或router.replace()添加历史记录' },
                ],
                notes: [
                  { id: '1', name: '前进/后退功能依赖Vue Router的历史管理,与浏览器的前进后退机制类似' },
                  { id: '2', name: 'IPC通信架构:topBarView发送事件 -> 主进程转发 -> contentView接收并执行router操作' },
                  { id: '3', name: '历史栈为空时后退到根路径(/)作为安全后备' },
                  { id: '4', name: 'window.history.length用于判断是否有可回退的历史记录' },
                  { id: '5', name: '导航控制按钮的title提示:t("后退")和t("前进")' },
                  { id: '6', name: '项目切换,设置打开等操作都会自动添加到路由历史栈' },
                ],
              },
            ],
          },
          // 其他快捷图标功能
          {
            modelName: '其他快捷图标功能',
            description: '其他快捷图标功能',
            atomicFunc: [
              {
                purpose: '点击新增项目按钮可以新增项目',
                precondition: [
                  { id: '1', name: '应用已启动' },
                  { id: '2', name: '当前在主页面或任意页面' },
                  { id: '3', name: 'Header导航栏已渲染' },
                  { id: '4', name: 'IPC通信正常工作' },
                ],
                operationSteps: [
                  { id: '1', name: '定位到顶部Header导航栏Tab列表左侧的新增项目按钮(+按钮)' },
                  { id: '2', name: '点击+按钮(data-testid="header-add-project-btn",button.add-tab-btn)' },
                  { id: '3', name: '观察是否弹出新建项目对话框' },
                  { id: '4', name: '填写项目名称,选择网络模式等必要信息' },
                  { id: '5', name: '点击确认按钮创建项目' },
                  { id: '6', name: '观察Tab列表和内容区域的变化' },
                ],
                expectedResults: [
                  { id: '1', name: '点击+按钮后,新建项目对话框在内容区域弹出' },
                  { id: '2', name: '对话框包含项目名称输入框,网络模式选择等配置项' },
                  { id: '3', name: '项目创建成功后,对话框关闭' },
                  { id: '4', name: 'Tab列表新增一个项目Tab,显示新项目名称和Folder图标' },
                  { id: '5', name: '新项目Tab被自动高亮(激活状态)' },
                  { id: '6', name: '内容区域自动切换到新项目的工作区界面' },
                  { id: '7', name: '新项目Tab插入到正确位置(同网络模式的最后一个项目Tab之后)' },
                ],
                checkpoints: [
                  { id: '1', name: 'Header.vue第26行定义+按钮:button.add-tab-btn, @click="handleAddProject"' },
                  { id: '2', name: 'handleAddProject方法(Header.vue第275行)发送IPC事件到contentView' },
                  { id: '3', name: '调用window.electronAPI?.ipcManager.sendToMain(IPC_EVENTS.apiflow.contentToTopBar.createProject)' },
                  { id: '4', name: 'App.vue监听IPC事件:window.electronAPI?.ipcManager.onMain(IPC_EVENTS.apiflow.rendererToMain.createProject, ...)' },
                  { id: '5', name: '监听处理中设置dialogVisible.value = true,显示新建项目对话框' },
                  { id: '6', name: '项目创建成功后触发projectCreated事件,Header监听该事件并新增Tab' },
                  { id: '7', name: 'Tab新增逻辑与之前的projectCreated处理一致(splice插入)' },
                  { id: '8', name: '+按钮title提示文字:t("新建项目")' },
                ],
                notes: [
                  { id: '1', name: '新增项目按钮位于Tab列表左侧,独立于Tab项' },
                  { id: '2', name: 'IPC通信路径:topBarView -> mainProcess -> contentView' },
                  { id: '3', name: '新建项目对话框在contentView中渲染,topBarView仅负责触发' },
                  { id: '4', name: '项目创建流程涉及数据库操作(在线模式)或IndexedDB操作(离线模式)' },
                ],
              },
              {
                purpose: '点击AI助理按钮,弹出AI助理弹窗,如果是第一次弹窗,弹窗位置再AI助理按钮下方,如果不是第一次弹窗,弹窗位置在上次拖拽后位置处,多次点击不会关闭AI助理',
                precondition: [
                  { id: '1', name: '应用已启动' },
                  { id: '2', name: '已配置AI助理相关设置(可选)' },
                  { id: '3', name: 'Header导航栏已渲染' },
                  { id: '4', name: 'agentViewStore正常工作' },
                ],
                operationSteps: [
                  { id: '1', name: '场景1:第一次打开AI助理' },
                  { id: '2', name: '定位到顶部Header的AI助理按钮(Bot图标,data-testid="header-ai-btn")' },
                  { id: '3', name: '点击AI助理按钮' },
                  { id: '4', name: '观察AI助理弹窗的位置(应在按钮下方)' },
                  { id: '5', name: '拖动AI助理弹窗到新位置' },
                  { id: '6', name: '关闭AI助理弹窗' },
                  { id: '7', name: '场景2:再次打开AI助理' },
                  { id: '8', name: '再次点击AI助理按钮' },
                  { id: '9', name: '观察AI助理弹窗的位置(应在上次拖拽后的位置)' },
                  { id: '10', name: '场景3:多次点击按钮,观察弹窗是否关闭' },
                ],
                expectedResults: [
                  { id: '1', name: '场景1:点击AI助理按钮后,AI助理弹窗显示' },
                  { id: '2', name: '第一次打开时,弹窗初始位置锚定在AI助理按钮下方(按钮的x, y, width, height信息传递)' },
                  { id: '3', name: 'AI助理弹窗支持拖拽移动' },
                  { id: '4', name: '弹窗位置被记录并持久化保存' },
                  { id: '5', name: '场景2:再次打开时,弹窗位置恢复为上次拖拽后保存的位置' },
                  { id: '6', name: '场景3:多次点击AI助理按钮不会关闭已打开的弹窗,弹窗保持显示状态' },
                  { id: '7', name: 'AI助理弹窗包含聊天界面,输入框等功能组件' },
                  { id: '8', name: '支持键盘快捷键Ctrl+L打开AI助理' },
                ],
                checkpoints: [
                  { id: '1', name: 'Header.vue第30-32行定义AI助理按钮:button.ai-trigger-btn, ref="aiButtonRef", @click="handleShowAiDialog"' },
                  { id: '2', name: 'handleShowAiDialog方法(Header.vue第276-288行)获取按钮位置信息' },
                  { id: '3', name: '使用aiButtonRef.value.getBoundingClientRect()获取按钮的DOMRect(x, y, width, height)' },
                  { id: '4', name: '构造AnchorRect对象:{x: rect.left, y: rect.top, width: rect.width, height: rect.height}' },
                  { id: '5', name: '发送IPC事件:window.electronAPI?.ipcManager.sendToMain(IPC_EVENTS.apiflow.contentToTopBar.showAiDialog, { position })' },
                  { id: '6', name: 'App.vue监听事件并调用agentViewStore.showAgentViewDialog(payload?.position)' },
                  { id: '7', name: 'agentViewStore负责管理AI助理弹窗的显示/隐藏状态和位置记忆' },
                  { id: '8', name: '弹窗位置通过localStorage或类似机制持久化保存' },
                  { id: '9', name: 'showCopilotDialog方法判断是否传入position参数,决定使用锚点位置还是记忆位置' },
                  { id: '10', name: '多次点击不关闭通过只调用show方法实现,不toggle状态' },
                ],
                notes: [
                  { id: '1', name: 'AI助理按钮title提示:t("AI助手 Ctrl+L"),支持快捷键' },
                  { id: '2', name: 'AnchorRect类型用于传递锚点位置信息' },
                  { id: '3', name: 'getBoundingClientRect()返回元素相对视口的位置和尺寸' },
                  { id: '4', name: 'AI助理弹窗是可拖拽对话框组件,支持位置记忆功能' },
                  { id: '5', name: 'agentViewStore是专门管理AI助理状态的Pinia store' },
                ],
              },
              {
                purpose: '点击设置按钮,新增一个设置tab,并且内容区域展示为设置页面',
                precondition: [
                  { id: '1', name: '应用已启动' },
                  { id: '2', name: 'Header导航栏已渲染' },
                  { id: '3', name: '当前不在设置页面或设置Tab未打开' },
                ],
                operationSteps: [
                  { id: '1', name: '定位到顶部Header右侧的设置图标按钮(齿轮图标,data-testid="header-settings-btn")' },
                  { id: '2', name: '点击设置按钮' },
                  { id: '3', name: '观察Tab列表是否新增设置Tab' },
                  { id: '4', name: '观察设置Tab是否被高亮(激活状态)' },
                  { id: '5', name: '观察内容区域是否切换到设置页面' },
                  { id: '6', name: '再次点击设置按钮(测试已存在Tab的情况)' },
                  { id: '7', name: '观察是否新增重复的设置Tab' },
                ],
                expectedResults: [
                  { id: '1', name: '点击设置按钮后,Tab列表新增一个设置Tab' },
                  { id: '2', name: '设置Tab显示"设置"文字和Settings图标(齿轮图标)' },
                  { id: '3', name: '设置Tab被自动高亮(激活状态),其他Tab失去高亮' },
                  { id: '4', name: '设置Tab插入到Tab列表末尾(在所有项目Tab之后)' },
                  { id: '5', name: '内容区域立即切换到设置页面,显示设置页面内容' },
                  { id: '6', name: '设置Tab的id格式为"settings-{networkMode}"(如"settings-online"或"settings-offline")' },
                  { id: '7', name: '再次点击设置按钮时,不新增重复Tab,仅高亮已有的设置Tab' },
                  { id: '8', name: '在线模式和离线模式各有独立的设置Tab' },
                ],
                checkpoints: [
                  { id: '1', name: 'Header.vue第38-40行定义设置按钮:el-icon.icon, data-testid="header-settings-btn", @click="jumpToSettings"' },
                  { id: '2', name: 'jumpToSettings方法(Header.vue第257-270行)处理设置Tab逻辑' },
                  { id: '3', name: '构造settingsTabId:`settings-${networkMode.value}`(区分在线/离线)' },
                  { id: '4', name: '使用tabs.value.find(t => t.id === settingsTabId)检查设置Tab是否已存在' },
                  { id: '5', name: 'Tab不存在时,使用tabs.value.push()在末尾添加新Tab' },
                  { id: '6', name: '新Tab结构:{id: settingsTabId, title: t("设置"), type: \'settings\', network: networkMode.value}' },
                  { id: '7', name: 'Tab添加后调用syncTabsToContentView()同步到contentView' },
                  { id: '8', name: '调用switchTab(settingsTabId)高亮设置Tab' },
                  { id: '9', name: 'switchTab内部发送导航事件到contentView,触发路由切换到/settings' },
                  { id: '10', name: '设置按钮title提示文字:t("设置")' },
                ],
                notes: [
                  { id: '1', name: '设置Tab使用网络模式区分,在线和离线模式各有独立的设置Tab' },
                  { id: '2', name: '设置Tab的type字段为\'settings\',用于渲染Settings图标和识别Tab类型' },
                  { id: '3', name: '设置Tab始终插入到Tab列表末尾,通过push方法实现' },
                  { id: '4', name: '重复点击设置按钮不会创建多个设置Tab,通过existingTab判断实现' },
                  { id: '5', name: '内容区域的设置页面路由路径为/settings' },
                ],
              },
              {
                purpose: '点击多语言图标,下方展示简体中文,繁体中文,英语,日本语选项,点击内容区域关闭语言切换弹窗',
                precondition: [
                  { id: '1', name: '应用已启动' },
                  { id: '2', name: 'Header导航栏已渲染' },
                  { id: '3', name: '多语言功能已正确配置(vue-i18n)' },
                  { id: '4', name: 'runtimeStore正常工作' },
                ],
                operationSteps: [
                  { id: '1', name: '定位到顶部Header右侧的语言切换按钮(iconyuyan图标,data-testid="header-language-btn")' },
                  { id: '2', name: '观察按钮显示的当前语言标识(如"中","繁","EN","JP")' },
                  { id: '3', name: '点击语言切换按钮' },
                  { id: '4', name: '观察是否在按钮下方弹出语言选择菜单' },
                  { id: '5', name: '检查菜单中的语言选项(应包含:简体中文,繁体中文,English,日本語)' },
                  { id: '6', name: '点击某个语言选项(如English)' },
                  { id: '7', name: '观察应用界面的语言是否切换' },
                  { id: '8', name: '观察语言按钮的标识是否更新(如变为"EN")' },
                  { id: '9', name: '再次点击语言按钮,点击内容区域任意位置' },
                  { id: '10', name: '观察语言菜单是否关闭' },
                ],
                expectedResults: [
                  { id: '1', name: '语言按钮显示当前语言的简写标识:zh-cn="中", zh-tw="繁", en="EN", ja="JP"' },
                  { id: '2', name: '点击按钮后,语言选择菜单在按钮正下方弹出' },
                  { id: '3', name: '菜单包含4个语言选项:简体中文,繁体中文,English,日本語' },
                  { id: '4', name: '当前选中的语言选项在菜单中高亮显示或有特殊标记' },
                  { id: '5', name: '点击语言选项后,应用界面的所有文字立即切换为对应语言,无需刷新页面' },
                  { id: '6', name: '语言按钮的标识文字更新为新选择的语言(如"EN")' },
                  { id: '7', name: '语言切换后,新语言设置被持久化保存到localStorage' },
                  { id: '8', name: '点击内容区域(contentView)任意位置后,语言菜单自动关闭' },
                  { id: '9', name: '刷新页面或重启应用后,语言保持为最后选择的语言' },
                ],
                checkpoints: [
                  { id: '1', name: 'Header.vue第41-44行定义语言按钮:.icon, ref="languageButtonRef", data-testid="header-language-btn", @click="handleChangeLanguage"' },
                  { id: '2', name: 'currentLanguageDisplay计算属性(Header.vue第160-168行)映射语言代码到显示文字' },
                  { id: '3', name: 'languageMap对象:{"zh-cn": "中", "zh-tw": "繁", "en": "EN", "ja": "JP"}' },
                  { id: '4', name: 'handleChangeLanguage方法(Header.vue第170-186行)获取按钮位置并发送IPC事件' },
                  { id: '5', name: '使用languageButtonRef.value.getBoundingClientRect()获取按钮位置' },
                  { id: '6', name: '发送IPC事件:IPC_EVENTS.apiflow.topBarToContent.showLanguageMenu, {position, currentLanguage}' },
                  { id: '7', name: 'App.vue监听showLanguageMenu事件,显示语言选择菜单组件' },
                  { id: '8', name: '语言选择菜单监听click outside事件,点击外部区域时关闭' },
                  { id: '9', name: '选择语言后调用handleLanguageSelect(App.vue第105-111行)' },
                  { id: '10', name: 'runtimeStore.setLanguage(language)保存语言设置' },
                  { id: '11', name: 'changeLanguage(language)切换vue-i18n的当前语言' },
                  { id: '12', name: '发送IPC事件通知topBarView语言已变更:IPC_EVENTS.apiflow.contentToTopBar.languageChanged' },
                  { id: '13', name: 'runtimeCache.setLanguage方法将语言保存到localStorage["runtime/language"]' },
                ],
                notes: [
                  { id: '1', name: '语言切换基于vue-i18n库,支持全局i18n文本的响应式更新' },
                  { id: '2', name: '支持的语言类型:type Language = "zh-cn" | "zh-tw" | "en" | "ja"' },
                  { id: '3', name: '语言按钮显示简写,便于在狭小空间中显示' },
                  { id: '4', name: '语言菜单是独立组件,支持键盘导航和无障碍访问' },
                  { id: '5', name: '语言切换通过IPC事件在topBarView和contentView之间同步' },
                ],
              },
              {
                purpose: '点击网络切换按钮可以切换互联网模式和单机模式',
                precondition: [
                  { id: '1', name: '应用已启动' },
                  { id: '2', name: 'Header导航栏已渲染' },
                  { id: '3', name: 'runtimeStore正常工作' },
                  { id: '4', name: '当前处于某一网络模式(在线或离线)' },
                ],
                operationSteps: [
                  { id: '1', name: '观察当前网络模式按钮的图标和文字(iconwifi/iconwifi-off-line)' },
                  { id: '2', name: '记录当前显示的Tab列表' },
                  { id: '3', name: '点击网络模式切换按钮(data-testid="header-network-toggle")' },
                  { id: '4', name: '观察按钮图标和文字是否变化' },
                  { id: '5', name: '观察Tab列表是否变化(应只显示新模式的Tab)' },
                  { id: '6', name: '观察内容区域是否有变化' },
                  { id: '7', name: '再次点击网络模式按钮,切换回原模式' },
                  { id: '8', name: '观察Tab列表是否恢复为原来的Tab' },
                  { id: '9', name: '刷新页面,验证网络模式是否保持' },
                ],
                expectedResults: [
                  { id: '1', name: '在线模式:按钮显示wifi图标(iconwifi)和文字"联网模式"' },
                  { id: '2', name: '离线模式:按钮显示wifi-off图标(iconwifi-off-line)和文字"离线模式"' },
                  { id: '3', name: '点击按钮后,网络模式立即切换(online ↔ offline)' },
                  { id: '4', name: '按钮图标和文字同步更新为对应模式' },
                  { id: '5', name: 'Tab列表过滤显示:仅显示当前网络模式的Tab,隐藏其他模式的Tab' },
                  { id: '6', name: '如果当前高亮的Tab不属于新模式,自动切换到新模式的第一个Tab或主页面' },
                  { id: '7', name: '网络模式切换后,新模式设置被持久化保存到localStorage' },
                  { id: '8', name: '切换模式不会删除Tab数据,仅影响显示过滤' },
                  { id: '9', name: '刷新页面后,网络模式保持为最后选择的模式' },
                  { id: '10', name: '在线模式支持与服务器同步,离线模式使用IndexedDB本地存储' },
                ],
                checkpoints: [
                  { id: '1', name: 'Header.vue第45-54行定义网络切换按钮:el-icon, class="network-btn icon", data-testid="header-network-toggle", @click="toggleNetworkMode"' },
                  { id: '2', name: 'networkMode响应式变量(Header.vue第84行):ref<RuntimeNetworkMode>(...)' },
                  { id: '3', name: '图标条件渲染::class="networkMode === \'online\' ? \'iconwifi\' : \'iconwifi-off-line\'"' },
                  { id: '4', name: '文字条件渲染:{{ networkMode === \'online\' ? t("联网模式") : t("离线模式") }}' },
                  { id: '5', name: 'toggleNetworkMode方法(Header.vue第271-274行)切换网络模式' },
                  { id: '6', name: '计算新模式:const newMode = networkMode.value === \'online\' ? \'offline\' : \'online\'' },
                  { id: '7', name: '发送IPC事件:window.electronAPI?.ipcManager.sendToMain(IPC_EVENTS.apiflow.topBarToContent.networkModeChanged, newMode)' },
                  { id: '8', name: 'App.vue监听networkModeChanged事件,调用runtimeStore.setNetworkMode(mode)' },
                  { id: '9', name: 'runtimeStore.setNetworkMode保存到runtimeCache,写入localStorage["runtime/networkMode"]' },
                  { id: '10', name: 'Header监听networkModeChanged事件(Header.vue第362-364行),更新networkMode.value' },
                  { id: '11', name: 'draggableTabs计算属性自动过滤:computed(() => tabs.value.filter(tab => tab.network === networkMode.value))' },
                  { id: '12', name: 'Tab的network字段(\'online\' | \'offline\')用于分组和过滤' },
                  { id: '13', name: '网络模式初始化:networkMode.value = runtimeCache.getNetworkMode(),默认为\'online\'' },
                ],
                notes: [
                  { id: '1', name: '网络模式类型:type RuntimeNetworkMode = \'online\' | \'offline\'' },
                  { id: '2', name: '在线模式连接后端服务器,支持团队协作和云端同步' },
                  { id: '3', name: '离线模式使用IndexedDB本地存储,支持完全离线工作' },
                  { id: '4', name: 'Tab按network字段分组,每个模式维护独立的Tab列表' },
                  { id: '5', name: '网络模式切换不会丢失任何Tab数据,切换回来时Tab完整恢复' },
                  { id: '6', name: '按钮title提示根据当前模式动态变化' },
                ],
              },
            ],
          },
          // 窗口控制
          {
            modelName: '窗口控制',
            description: '窗口控制',
            atomicFunc: [
              {
                purpose: '点击最小化图标应用最小化',
                precondition: [
                  { id: '1', name: 'Electron应用已启动' },
                  { id: '2', name: '窗口处于正常显示状态(非最小化)' },
                  { id: '3', name: 'Header导航栏窗口控制区域已渲染' },
                ],
                operationSteps: [
                  { id: '1', name: '定位到Header右上角的窗口控制区域(.window-control)' },
                  { id: '2', name: '找到最小化按钮(iconjianhao图标,data-testid="header-minimize-btn")' },
                  { id: '3', name: '点击最小化按钮' },
                  { id: '4', name: '观察窗口变化' },
                  { id: '5', name: '在任务栏或Dock中找到应用图标,点击恢复窗口' },
                ],
                expectedResults: [
                  { id: '1', name: '点击最小化按钮后,应用窗口立即最小化到任务栏(Windows)或Dock(macOS)' },
                  { id: '2', name: '窗口从屏幕上消失,但应用进程继续运行' },
                  { id: '3', name: '应用图标在任务栏/Dock中保持显示' },
                  { id: '4', name: '点击任务栏/Dock图标后,窗口恢复到最小化前的状态(大小和位置)' },
                  { id: '5', name: '窗口恢复后,之前打开的Tab,内容,状态等完全保持不变' },
                ],
                checkpoints: [
                  { id: '1', name: 'Header.vue第56-61行定义窗口控制区域,包含最小化,最大化,关闭按钮' },
                  { id: '2', name: '最小化按钮:i.iconfont.iconjianhao, id="minimize", data-testid="header-minimize-btn", @click="minimize"' },
                  { id: '3', name: 'minimize方法(Header.vue第122行):window.electronAPI?.windowManager.minimizeWindow()' },
                  { id: '4', name: 'Preload暴露minimizeWindow方法(preload.ts第20-47行)' },
                  { id: '5', name: 'minimizeWindow通过ipcRenderer.send发送IPC_EVENTS.window.rendererToMain.minimize事件' },
                  { id: '6', name: '主进程监听minimize事件(ipcMessage/index.ts第154-170行)' },
                  { id: '7', name: '调用mainWindow.minimize()执行Electron窗口最小化' },
                  { id: '8', name: 'BrowserWindow的minimize()方法是Electron API,跨平台兼容' },
                ],
                notes: [
                  { id: '1', name: '最小化按钮title提示:t("最小化")' },
                  { id: '2', name: '窗口控制通过IPC通信:rendererProcess -> mainProcess -> Electron API' },
                  { id: '3', name: '最小化不会终止应用进程,所有状态和数据保持在内存中' },
                  { id: '4', name: 'Electron的minimize()在Windows,macOS,Linux上行为一致' },
                ],
              },
              {
                purpose: '点击窗口模式图标从最大化改变为窗口模式并且图标变为最大化图标,点击最大化图标,窗口最大化并且图标变为窗口模式图标',
                precondition: [
                  { id: '1', name: 'Electron应用已启动' },
                  { id: '2', name: 'Header导航栏窗口控制区域已渲染' },
                  { id: '3', name: 'isMaximized响应式变量正常工作' },
                ],
                operationSteps: [
                  { id: '1', name: '场景1:窗口当前处于最大化状态' },
                  { id: '2', name: '观察窗口控制区域显示的是iconminiScreen图标(窗口模式图标)' },
                  { id: '3', name: '点击iconminiScreen按钮(data-testid="header-unmaximize-btn")' },
                  { id: '4', name: '观察窗口大小变化和图标变化' },
                  { id: '5', name: '场景2:窗口当前处于窗口模式' },
                  { id: '6', name: '观察窗口控制区域显示的是iconmaxScreen图标(最大化图标)' },
                  { id: '7', name: '点击iconmaxScreen按钮(data-testid="header-maximize-btn")' },
                  { id: '8', name: '观察窗口大小变化和图标变化' },
                  { id: '9', name: '重复场景1和场景2,验证图标切换逻辑' },
                ],
                expectedResults: [
                  { id: '1', name: '场景1:点击窗口模式按钮后,窗口从最大化状态恢复为窗口模式(unmaximize)' },
                  { id: '2', name: '窗口大小恢复为最大化前的尺寸和位置' },
                  { id: '3', name: '窗口控制区域的图标从iconminiScreen切换为iconmaxScreen(最大化图标)' },
                  { id: '4', name: 'isMaximized.value变为false' },
                  { id: '5', name: '场景2:点击最大化按钮后,窗口填充整个屏幕(最大化)' },
                  { id: '6', name: '窗口标题栏保留可见,任务栏/Dock保持可见(非全屏模式)' },
                  { id: '7', name: '窗口控制区域的图标从iconmaxScreen切换为iconminiScreen(窗口模式图标)' },
                  { id: '8', name: 'isMaximized.value变为true' },
                  { id: '9', name: '图标切换通过v-if条件渲染实现,同一时刻只显示一个图标' },
                ],
                checkpoints: [
                  { id: '1', name: 'Header.vue第56-61行根据isMaximized条件渲染不同按钮' },
                  { id: '2', name: 'v-if="!isMaximized"渲染最大化按钮:i.iconfont.iconmaxScreen, id="maximize", data-testid="header-maximize-btn", @click="maximize"' },
                  { id: '3', name: 'v-if="isMaximized"渲染窗口模式按钮:i.iconfont.iconminiScreen, id="unmaximize", data-testid="header-unmaximize-btn", @click="unmaximize"' },
                  { id: '4', name: 'isMaximized响应式变量(Header.vue):ref<boolean>(false)' },
                  { id: '5', name: 'maximize方法(Header.vue第122行):window.electronAPI?.windowManager.maximizeWindow()' },
                  { id: '6', name: 'unmaximize方法(Header.vue第122行):window.electronAPI?.windowManager.unMaximizeWindow()' },
                  { id: '7', name: 'Preload暴露maximizeWindow和unMaximizeWindow方法(preload.ts第20-47行)' },
                  { id: '8', name: '主进程监听maximize和unmaximize事件(ipcMessage/index.ts第154-170行)' },
                  { id: '9', name: '调用mainWindow.maximize()或mainWindow.unmaximize()执行窗口状态切换' },
                  { id: '10', name: 'handleWindowResize方法(Header.vue第127行)监听窗口状态变化' },
                  { id: '11', name: 'window.electronAPI?.windowManager.onWindowResize(handleWindowResize)注册监听' },
                  { id: '12', name: 'handleWindowResize接收WindowState对象:{isMaximized: boolean},更新isMaximized.value' },
                  { id: '13', name: '主进程在窗口resize事件时通过IPC发送WindowState到renderer' },
                ],
                notes: [
                  { id: '1', name: '最大化和窗口模式按钮互斥显示,通过v-if="!isMaximized"和v-if="isMaximized"控制' },
                  { id: '2', name: 'isMaximized状态通过IPC事件同步,确保UI与实际窗口状态一致' },
                  { id: '3', name: 'windowManager.getWindowState()用于初始化窗口状态(Header.vue第290-295行)' },
                  { id: '4', name: '最大化不是全屏,保留窗口边框和系统任务栏' },
                  { id: '5', name: 'Electron的maximize/unmaximize在跨平台上行为一致' },
                  { id: '6', name: '按钮title提示:t("最大化")和t("取消最大化")' },
                ],
              },
              {
                purpose: '点击关闭按钮关闭应用',
                precondition: [
                  { id: '1', name: 'Electron应用已启动' },
                  { id: '2', name: 'Header导航栏窗口控制区域已渲染' },
                  { id: '3', name: '应用有未保存的数据(可选,测试关闭前保存提示)' },
                ],
                operationSteps: [
                  { id: '1', name: '定位到Header右上角窗口控制区域最右侧的关闭按钮(iconguanbi图标,data-testid="header-close-btn")' },
                  { id: '2', name: '点击关闭按钮' },
                  { id: '3', name: '如果有未保存数据,观察是否弹出确认对话框' },
                  { id: '4', name: '确认关闭操作' },
                  { id: '5', name: '观察应用窗口和进程是否完全终止' },
                ],
                expectedResults: [
                  { id: '1', name: '点击关闭按钮后,应用窗口立即关闭' },
                  { id: '2', name: '如果有未保存的数据,可能弹出确认对话框询问是否保存(取决于应用配置)' },
                  { id: '3', name: '确认关闭后,应用窗口从屏幕消失' },
                  { id: '4', name: 'Electron主进程终止,应用完全退出' },
                  { id: '5', name: '应用图标从任务栏/Dock中移除(如果没有后台常驻)' },
                  { id: '6', name: '关闭前,应用自动保存必要的状态数据到localStorage/IndexedDB' },
                  { id: '7', name: '下次启动应用时,之前的Tab列表,设置等状态被恢复' },
                ],
                checkpoints: [
                  { id: '1', name: 'Header.vue第56-61行定义关闭按钮:i.iconfont.iconguanbi.close, id="close", data-testid="header-close-btn", @click="close"' },
                  { id: '2', name: 'close方法(Header.vue第122行):window.electronAPI?.windowManager.closeWindow()' },
                  { id: '3', name: 'Preload暴露closeWindow方法(preload.ts第20-47行)' },
                  { id: '4', name: 'closeWindow通过ipcRenderer.send发送IPC_EVENTS.window.rendererToMain.close事件' },
                  { id: '5', name: '主进程监听close事件(ipcMessage/index.ts第154-170行)' },
                  { id: '6', name: '调用mainWindow.close()执行窗口关闭' },
                  { id: '7', name: 'BrowserWindow的close()触发窗口关闭流程' },
                  { id: '8', name: '关闭前可能触发before-unload或close事件,执行清理逻辑' },
                  { id: '9', name: 'Tab列表通过appWorkbenchCache自动保存到localStorage' },
                  { id: '10', name: '用户设置,项目数据等通过各自的cache机制持久化' },
                ],
                notes: [
                  { id: '1', name: '关闭按钮title提示:t("关闭")' },
                  { id: '2', name: '关闭按钮使用.close类名,通常有红色背景等视觉强调' },
                  { id: '3', name: 'Electron窗口关闭会触发应用退出,除非有多窗口或后台常驻配置' },
                  { id: '4', name: '关闭前的数据保存由各模块的beforeunload或窗口close事件处理' },
                  { id: '5', name: '可以通过mainWindow.on("close", ...)监听关闭事件,实现自定义关闭逻辑' },
                ],
              },
            ],
          },
        ],
      },
    ],
  },
  // 项目管理
  {
    modelName: 'projectManager',
    description: '项目管理器',
    children: [
      // 项目列表
      {
        modelName: '项目列表',
        description: '项目列表',
        atomicFunc: [
          {
            purpose: '项目列表以卡片形式展示,卡片包含:项目名称,修改图标,删除图标,收藏图标,创建者,最新更新日期,接口总数,编辑按钮',
            precondition: [
              { id: '1', name: '应用已启动并完成数据库初始化' },
              { id: '2', name: '用户已登录或处于离线模式' },
              { id: '3', name: '至少存在一个项目在IndexedDB中' },
              { id: '4', name: 'projectManagerStore已初始化并加载项目列表' },
            ],
            operationSteps: [
              { id: '1', name: '启动应用,导航到/home首页路由' },
              { id: '2', name: '等待ProjectManager.vue组件挂载和项目列表数据加载' },
              { id: '3', name: '观察"全部项目"区域的项目卡片展示' },
              { id: '4', name: '检查每张项目卡片的UI元素完整性' },
              { id: '5', name: '验证项目卡片的响应式布局(flex布局,每行最多4张卡片)' },
            ],
            expectedResults: [
              { id: '1', name: '项目卡片使用el-card组件,带有hover阴影效果' },
              { id: '2', name: '项目名称显示在卡片顶部,使用.title.project-name.theme-color类,超长文本显示省略号' },
              { id: '3', name: '修改图标(EditIcon)显示在项目名称右侧,data-testid="home-project-edit-btn"' },
              { id: '4', name: '在线模式下显示成员管理图标(UserIcon),离线模式下隐藏' },
              { id: '5', name: '收藏图标(Star或StarFilled)显示,未收藏显示空心星星,已收藏显示实心星星' },
              { id: '6', name: '删除图标(DeleteIcon)显示在右上角,data-testid="home-project-delete-btn"' },
              { id: '7', name: '创建者信息显示格式:"创建者: {{ item.owner.name }}",离线模式默认显示"me"' },
              { id: '8', name: '最新更新日期显示格式:"最新更新: {{ formatDate(item.updatedAt) }}",格式为"YYYY-MM-DD HH:mm"' },
              { id: '9', name: '接口总数显示格式:"接口总数: {{ item.docNum || 0 }}"' },
              { id: '10', name: '编辑按钮显示在卡片底部,文案为"编辑",data-testid="home-project-enter-btn"' },
            ],
            checkpoints: [
              { id: '1', name: 'ProjectManager.vue组件正确渲染(行1-734)' },
              { id: '2', name: 'projectList computed属性返回过滤后的项目列表(行287-298)' },
              { id: '3', name: '项目卡片循环渲染:v-for="(item, index) in projectList"(行120)' },
              { id: '4', name: '项目卡片data-testid="home-project-card-{index}"属性正确绑定' },
              { id: '5', name: '项目名称DOM元素:<div class="title project-name theme-color text-ellipsis">(行121)' },
              { id: '6', name: '修改图标点击事件:@click="handleOpenEditDialog(item)"(行129)' },
              { id: '7', name: '收藏图标条件渲染:v-if="!item.isStared"显示Star,v-else显示StarFilled(行135-150)' },
              { id: '8', name: '删除图标点击事件:@click="deleteProject(item._id)"(行155)' },
              { id: '9', name: '创建者信息:{{ item.owner.name }}(行158-161)' },
              { id: '10', name: '更新日期:formatDate(item.updatedAt)调用helper函数(行162-165)' },
              { id: '11', name: '接口总数:{{ item.docNum || 0 }}(行169)' },
              { id: '12', name: '编辑按钮点击事件:@click="handleJumpToProject(item)"(行172)' },
              { id: '13', name: 'ApidocProjectInfo类型包含所有必需字段:_id, projectName, owner, updatedAt, docNum, isStared' },
              { id: '14', name: '离线模式判断:isStandalone = computed(() => runtimeStore.networkMode === "offline")(行234)' },
            ],
            notes: [
              { id: '1', name: '项目列表组件路径:packages/web/src/renderer/pages/home/projectManager/ProjectManager.vue' },
              { id: '2', name: '项目数据来源:projectManagerStore.getProjectList(),离线模式读取IndexedDB,在线模式调用API' },
              { id: '3', name: '接口数量计算逻辑:apiNodesCache.updateProjectNodeNum()统计非folder且未删除的节点' },
              { id: '4', name: '日期格式化函数:formatDate(date, "YYYY-MM-DD HH:mm")在helper/index.ts中实现' },
              { id: '5', name: '卡片布局:使用grid布局,每行最多4张卡片,卡片宽度自适应' },
              { id: '6', name: '图标库:所有图标来自lucide-vue-next库(EditIcon,UserIcon,Star,StarFilled,DeleteIcon)' },
            ],
          },
          {
            purpose: '点击编辑按钮,跳转对应项目工作区',
            precondition: [
              { id: '1', name: '应用已启动,处于/home首页' },
              { id: '2', name: '项目列表已加载,至少显示一个项目卡片' },
              { id: '3', name: 'Vue Router已初始化' },
              { id: '4', name: 'projectWorkbenchStore处于就绪状态' },
            ],
            operationSteps: [
              { id: '1', name: '定位到任意一个项目卡片' },
              { id: '2', name: '点击项目卡片底部的"编辑"按钮(data-testid="home-project-enter-btn")' },
              { id: '3', name: '等待路由跳转完成' },
              { id: '4', name: '观察浏览器地址栏URL变化' },
              { id: '5', name: '验证项目工作区页面已加载' },
            ],
            expectedResults: [
              { id: '1', name: '路由立即跳转到/v1/apidoc/doc-edit路径' },
              { id: '2', name: 'URL携带query参数:id=<项目ID>&name=<项目名称>&mode=edit' },
              { id: '3', name: '项目工作区页面(DocEdit组件)正确渲染' },
              { id: '4', name: '顶部导航栏显示项目名称并新增对应的Tab' },
              { id: '5', name: '新增的Tab处于高亮激活状态' },
              { id: '6', name: '左侧导航树加载该项目的API节点列表' },
              { id: '7', name: '中间内容区域显示项目工作台界面' },
            ],
            checkpoints: [
              { id: '1', name: 'handleJumpToProject方法被正确调用(ProjectManager.vue 行464-475)' },
              { id: '2', name: 'projectManagerStore.recordVisited(item._id)记录项目访问(仅在线模式)' },
              { id: '3', name: 'projectWorkbenchStore.changeProjectId(item._id)更新工作区项目ID' },
              { id: '4', name: 'router.push方法调用,传入正确的路由配置对象' },
              { id: '5', name: 'router.push参数:{ path: "/v1/apidoc/doc-edit", query: { id, name, mode: "edit" } }' },
              { id: '6', name: 'Vue Router路由配置中存在name="DocEdit"的路由记录' },
              { id: '7', name: '路由守卫beforeEach检查数据库初始化状态(router/index.ts 行144-162)' },
              { id: '8', name: 'DocEdit组件挂载并从$route.query中读取id,name,mode参数' },
              { id: '9', name: 'Header.vue组件监听路由变化,自动创建新Tab并高亮' },
              { id: '10', name: 'localStorage["history/lastVisitePage"]更新为当前路由完整路径' },
            ],
            notes: [
              { id: '1', name: '编辑按钮点击事件绑定:@click="handleJumpToProject(item)"(ProjectManager.vue 行172)' },
              { id: '2', name: 'handleJumpToProject方法实现路径:行464-475' },
              { id: '3', name: 'recordVisited方法仅在在线模式调用,用于记录项目最后访问时间' },
              { id: '4', name: 'Vue Router使用hash模式,兼容Electron的app://协议' },
              { id: '5', name: '项目工作区路由定义:{ path: "/v1/apidoc/doc-edit", name: "DocEdit", component: docEdit }' },
              { id: '6', name: 'Tab高亮逻辑在Header.vue中通过watch监听$route实现' },
            ],
          },
          {
            purpose: '点击修改按钮,弹出修改名称弹窗,并且输入框选中对应项目名称',
            precondition: [
              { id: '1', name: '应用已启动,处于/home首页' },
              { id: '2', name: '项目列表已加载,至少显示一个项目卡片' },
              { id: '3', name: 'EditProject.vue组件已注册并可用' },
            ],
            operationSteps: [
              { id: '1', name: '定位到任意一个项目卡片' },
              { id: '2', name: '找到项目名称右侧的修改图标(EditIcon)' },
              { id: '3', name: '点击修改图标' },
              { id: '4', name: '观察编辑项目弹窗是否弹出' },
              { id: '5', name: '检查弹窗中输入框的内容和焦点状态' },
            ],
            expectedResults: [
              { id: '1', name: '编辑项目弹窗(el-dialog)立即弹出显示' },
              { id: '2', name: '弹窗标题显示为"编辑项目"或"修改项目名称"' },
              { id: '3', name: '输入框自动获得焦点(input.focus()被调用)' },
              { id: '4', name: '输入框中的项目名称文本全部被选中(input.select()被调用)' },
              { id: '5', name: '输入框显示的内容与点击的项目名称一致' },
              { id: '6', name: '弹窗底部显示"取消"和"确定"两个按钮' },
              { id: '7', name: '用户可以直接输入新名称覆盖选中的文本' },
            ],
            checkpoints: [
              { id: '1', name: 'handleOpenEditDialog方法被正确调用(ProjectManager.vue 行332-336)' },
              { id: '2', name: 'currentEditProjectId.value设置为被点击项目的_id' },
              { id: '3', name: 'currentEditProjectName.value设置为被点击项目的projectName' },
              { id: '4', name: 'dialogVisible2.value设置为true,触发弹窗显示' },
              { id: '5', name: 'EditProject组件接收props:{ modelValue: true, projectId, projectName, isFocus: true }' },
              { id: '6', name: 'EditProject.vue的handleDialogOpened方法在弹窗打开后被触发(行51-61)' },
              { id: '7', name: 'nextTick后通过$el.querySelector("input")获取原生input元素' },
              { id: '8', name: 'inputEl.focus()调用,输入框获得焦点' },
              { id: '9', name: 'inputEl.select()调用,全选输入框文本' },
              { id: '10', name: 'formInfo.value.projectName初始值等于传入的projectName prop' },
            ],
            notes: [
              { id: '1', name: '修改图标点击事件:@click="handleOpenEditDialog(item)"(ProjectManager.vue 行129)' },
              { id: '2', name: 'EditProject组件路径:pages/home/dialog/editProject/EditProject.vue(行1-119)' },
              { id: '3', name: '自动聚焦实现依赖于el-dialog的@opened事件触发handleDialogOpened方法' },
              { id: '4', name: 'isFocus prop默认为true,可以控制是否自动聚焦和选中' },
              { id: '5', name: '选中文本的作用是方便用户直接输入新名称,无需手动删除旧名称' },
            ],
          },
          {
            purpose: '点击修改按钮,弹出修改名称弹窗,并且输入框选中对应项目名称,点击确认后项目列表卡片名称更新为最新,顶部导航栏项目名称更新为最新',
            precondition: [
              { id: '1', name: '应用已启动,处于/home首页' },
              { id: '2', name: '项目列表已加载,存在至少一个项目' },
              { id: '3', name: '该项目已在顶部导航栏打开(Header.vue中存在对应Tab)' },
              { id: '4', name: 'EditProject.vue弹窗已打开,输入框已选中项目名称' },
            ],
            operationSteps: [
              { id: '1', name: '在编辑项目弹窗的输入框中输入新的项目名称(例如:"新项目名称")' },
              { id: '2', name: '验证输入框内容已更新为新名称' },
              { id: '3', name: '点击弹窗底部的"确定"按钮' },
              { id: '4', name: '等待表单验证和API/缓存更新完成' },
              { id: '5', name: '观察弹窗是否关闭' },
              { id: '6', name: '检查项目列表中对应卡片的项目名称是否更新' },
              { id: '7', name: '检查顶部导航栏中对应Tab的项目名称是否更新' },
            ],
            expectedResults: [
              { id: '1', name: '点击确定后,表单验证通过(项目名称非空且非纯空格)' },
              { id: '2', name: '弹窗立即关闭,dialogVisible2.value设置为false' },
              { id: '3', name: '项目列表自动刷新,调用getProjectList()方法' },
              { id: '4', name: '对应项目卡片的.project-name元素显示的文本更新为新名称' },
              { id: '5', name: '顶部导航栏接收IPC事件apiflow.contentToTopBar.projectRenamed' },
              { id: '6', name: '顶部导航栏中对应Tab的显示名称更新为新名称' },
              { id: '7', name: 'IndexedDB(离线模式)或服务器数据库(在线模式)中的项目名称已持久化' },
              { id: '8', name: '修改成功后显示成功提示消息(ElMessage.success)' },
            ],
            checkpoints: [
              { id: '1', name: 'EditProject.vue的handleEditProject方法被调用(行88-117)' },
              { id: '2', name: 'formRef.value.validate()表单验证通过' },
              { id: '3', name: 'projectManagerStore.updateProject(projectId, projectName)被调用' },
              { id: '4', name: '离线模式:projectCache.updateProject(projectId, { projectName })更新IndexedDB' },
              { id: '5', name: '在线模式:request.put("/api/project/edit_project", params)调用API' },
              { id: '6', name: 'emit("success", { id: projectId, name: projectName })触发成功事件' },
              { id: '7', name: 'ProjectManager.vue的handleEditSuccess方法被调用(行493-501)' },
              { id: '8', name: 'getProjectList()方法被调用,重新加载项目列表' },
              { id: '9', name: 'window.electronAPI.ipcManager.sendToMain发送projectRenamed事件(行496-500)' },
              { id: '10', name: 'IPC payload:{ projectId: data.id, projectName: data.name }' },
              { id: '11', name: 'Header.vue接收IPC事件并更新对应Tab的name属性' },
              { id: '12', name: 'projectList computed属性重新计算,卡片名称响应式更新' },
            ],
            notes: [
              { id: '1', name: '表单验证规则:required + 自定义validator检查空格(EditProject.vue 行62-76)' },
              { id: '2', name: 'projectManagerStore.updateProject返回boolean,表示更新是否成功' },
              { id: '3', name: 'IPC事件定义:IPC_EVENTS.apiflow.contentToTopBar.projectRenamed' },
              { id: '4', name: 'IPC通信路径:Renderer -> Main Process -> TopBar View(Header.vue)' },
              { id: '5', name: 'IndexedDB更新使用合并策略:{ ...existingProject, ...project }(projectCache.ts 行94-107)' },
              { id: '6', name: '成功后emit传递的data对象:{ id, name }用于IPC通信和列表刷新' },
            ],
          },
          {
            purpose: '未收藏项目,点击收藏图标,图标变为已收藏图标,并且在收藏的项目中展示被收藏项目',
            precondition: [
              { id: '1', name: '应用已启动,处于/home首页' },
              { id: '2', name: '项目列表已加载,"全部项目"区域显示至少一个未收藏的项目' },
              { id: '3', name: '该项目的isStared属性为false' },
              { id: '4', name: 'starLoading.value为false(无其他收藏操作进行中)' },
            ],
            operationSteps: [
              { id: '1', name: '在"全部项目"区域定位到一个未收藏的项目卡片' },
              { id: '2', name: '找到该卡片上的收藏图标(空心星星Star图标)' },
              { id: '3', name: '点击空心星星图标' },
              { id: '4', name: '等待收藏操作完成(starLoading状态变化)' },
              { id: '5', name: '观察该项目卡片的收藏图标变化' },
              { id: '6', name: '滚动页面到顶部,检查"收藏的项目"区域是否显示' },
              { id: '7', name: '验证被收藏的项目是否出现在"收藏的项目"区域' },
            ],
            expectedResults: [
              { id: '1', name: '点击后,收藏图标立即从空心星星(Star)变为实心星星(StarFilled)' },
              { id: '2', name: '图标颜色变为主题色(theme-color类)' },
              { id: '3', name: '如果"收藏的项目"区域之前不存在(v-show="starProjects.length > 0"为false),现在显示出来' },
              { id: '4', name: '"收藏的项目"标题区域正确渲染' },
              { id: '5', name: '被收藏的项目卡片出现在"收藏的项目"区域,内容与原卡片一致' },
              { id: '6', name: '被收藏的项目在"全部项目"区域仍然存在,但图标变为实心星星' },
              { id: '7', name: '项目的isStared属性已更新为true' },
              { id: '8', name: 'starProjectIds数组包含该项目的_id' },
            ],
            checkpoints: [
              { id: '1', name: 'handleStar方法被正确调用(ProjectManager.vue 行432-444)' },
              { id: '2', name: 'starLoading.value设置为true,防止重复点击' },
              { id: '3', name: 'projectManagerStore.starProject(item._id)被调用' },
              { id: '4', name: '离线模式:直接修改projectList数组中对应项目的isStared属性为true' },
              { id: '5', name: '在线模式:request.put("/api/project/star", { projectId })调用API' },
              { id: '6', name: 'starProject方法返回true,表示收藏成功' },
              { id: '7', name: 'starLoading.value设置回false,解除防抖' },
              { id: '8', name: 'watch监听projectManagerStore.projectList变化,更新starProjectIds数组(行238-241)' },
              { id: '9', name: 'starProjects computed属性重新计算,包含新收藏的项目(行300-313)' },
              { id: '10', name: '"收藏的项目"区域v-show条件满足,显示标题和卡片列表' },
              { id: '11', name: '收藏图标条件渲染:v-if="!item.isStared"变为false,v-else分支渲染StarFilled图标' },
            ],
            notes: [
              { id: '1', name: '收藏图标点击事件:@click="handleStar(item)"(ProjectManager.vue 行135-150)' },
              { id: '2', name: 'projectManagerStore.starProject方法路径:行186-208' },
              { id: '3', name: '防抖机制:通过starLoading状态防止用户快速重复点击' },
              { id: '4', name: '"收藏的项目"区域在页面顶部,"全部项目"区域在下方' },
              { id: '5', name: 'starProjects computed过滤逻辑:projectList.filter(val => val.isStared)' },
              { id: '6', name: '在线模式下,收藏状态会同步到服务器并持久化到MongoDB' },
            ],
          },
          {
            purpose: '如果不存在收藏的项目,不展示收藏的项目标题',
            precondition: [
              { id: '1', name: '应用已启动,处于/home首页' },
              { id: '2', name: '项目列表已加载' },
              { id: '3', name: '所有项目的isStared属性均为false' },
              { id: '4', name: 'starProjects computed返回空数组(length为0)' },
            ],
            operationSteps: [
              { id: '1', name: '观察首页项目列表区域的布局结构' },
              { id: '2', name: '检查页面顶部是否存在"收藏的项目"标题' },
              { id: '3', name: '检查页面是否直接显示"全部项目"区域' },
              { id: '4', name: '验证DOM中是否渲染了.star-projects-wrap元素' },
            ],
            expectedResults: [
              { id: '1', name: '"收藏的项目"标题及整个区域不显示' },
              { id: '2', name: '.star-projects-wrap元素的v-show条件为false,元素存在但display: none' },
              { id: '3', name: '页面顶部直接显示搜索框和新建项目按钮' },
              { id: '4', name: '"全部项目"标题和卡片列表正常显示' },
              { id: '5', name: '页面布局紧凑,没有为隐藏的"收藏的项目"区域保留空白空间' },
            ],
            checkpoints: [
              { id: '1', name: 'starProjects computed属性返回空数组(ProjectManager.vue 行300-313)' },
              { id: '2', name: 'starProjects computed过滤条件:projectList.filter(val => val.isStared)结果为空' },
              { id: '3', name: '"收藏的项目"容器v-show="starProjects.length > 0"计算为false(行40-42)' },
              { id: '4', name: 'Vue的v-show指令将.star-projects-wrap元素设置为display: none' },
              { id: '5', name: 'DOM中仍存在该元素节点,但不可见也不占据布局空间' },
              { id: '6', name: '"全部项目"区域正常渲染,不受"收藏的项目"隐藏影响' },
            ],
            notes: [
              { id: '1', name: '"收藏的项目"区域条件渲染:v-show="starProjects.length > 0"(ProjectManager.vue 行40-42)' },
              { id: '2', name: '使用v-show而非v-if,元素始终存在于DOM中,仅切换display属性' },
              { id: '3', name: '当用户收藏第一个项目时,该区域会立即显示出来' },
              { id: '4', name: 'starProjects computed属性具有响应式,会自动响应isStared属性变化' },
            ],
          },
          {
            purpose: '收藏的项目,点击收藏图标,图标变为未收藏图标,并且从收藏的项目中移除',
            precondition: [
              { id: '1', name: '应用已启动,处于/home首页' },
              { id: '2', name: '项目列表已加载,至少存在一个已收藏的项目' },
              { id: '3', name: '"收藏的项目"区域已显示,包含至少一个项目卡片' },
              { id: '4', name: '目标项目的isStared属性为true' },
              { id: '5', name: 'unStarLoading.value为false(无其他取消收藏操作进行中)' },
            ],
            operationSteps: [
              { id: '1', name: '在"收藏的项目"区域或"全部项目"区域定位到一个已收藏的项目卡片' },
              { id: '2', name: '找到该卡片上的收藏图标(实心星星StarFilled图标)' },
              { id: '3', name: '点击实心星星图标' },
              { id: '4', name: '等待取消收藏操作完成(unStarLoading状态变化)' },
              { id: '5', name: '观察该项目卡片的收藏图标变化' },
              { id: '6', name: '滚动页面到顶部,检查"收藏的项目"区域的变化' },
              { id: '7', name: '验证项目是否从"收藏的项目"区域移除' },
            ],
            expectedResults: [
              { id: '1', name: '点击后,收藏图标立即从实心星星(StarFilled)变为空心星星(Star)' },
              { id: '2', name: '图标颜色恢复为默认颜色(不再是theme-color)' },
              { id: '3', name: '该项目卡片从"收藏的项目"区域立即消失' },
              { id: '4', name: '如果这是最后一个收藏的项目,"收藏的项目"整个区域隐藏(v-show变为false)' },
              { id: '5', name: '该项目在"全部项目"区域仍然存在,图标变为空心星星' },
              { id: '6', name: '项目的isStared属性已更新为false' },
              { id: '7', name: 'starProjectIds数组不再包含该项目的_id' },
              { id: '8', name: 'starProjects computed属性不再包含该项目' },
            ],
            checkpoints: [
              { id: '1', name: 'handleUnStar方法被正确调用(ProjectManager.vue 行446-458)' },
              { id: '2', name: 'unStarLoading.value设置为true,防止重复点击' },
              { id: '3', name: 'projectManagerStore.unstarProject(item._id)被调用' },
              { id: '4', name: '离线模式:直接修改projectList数组中对应项目的isStared属性为false' },
              { id: '5', name: '在线模式:request.put("/api/project/unstar", { projectId })调用API' },
              { id: '6', name: 'unstarProject方法返回true,表示取消收藏成功' },
              { id: '7', name: 'unStarLoading.value设置回false,解除防抖' },
              { id: '8', name: 'watch监听projectManagerStore.projectList变化,更新starProjectIds数组(行238-241)' },
              { id: '9', name: 'starProjectIds数组filter移除该项目_id' },
              { id: '10', name: 'starProjects computed属性重新计算,不再包含该项目(行300-313)' },
              { id: '11', name: '"收藏的项目"区域v-show条件根据starProjects.length重新评估' },
              { id: '12', name: '收藏图标条件渲染:v-if="!item.isStared"变为true,渲染Star图标' },
            ],
            notes: [
              { id: '1', name: '取消收藏图标点击事件:@click="handleUnStar(item)"(ProjectManager.vue 行60-75, 135-150)' },
              { id: '2', name: 'data-testid区分:"收藏的项目"区域为home-star-project-unstar-btn,"全部项目"区域为home-project-unstar-btn' },
              { id: '3', name: 'projectManagerStore.unstarProject方法路径:行210-232' },
              { id: '4', name: '防抖机制:通过unStarLoading状态防止用户快速重复点击' },
              { id: '5', name: '取消收藏后,如果starProjects为空,"收藏的项目"区域自动隐藏' },
              { id: '6', name: '在线模式下,取消收藏状态会同步到服务器并持久化' },
            ],
          },
          {
            purpose: '点击删除项目图标,提示用户是否删除,确认后删除项目,在左下角出现撤回倒计时,在倒计时时间内允许用户撤回删除的项目',
            precondition: [
              { id: '1', name: '应用已启动,处于/home首页' },
              { id: '2', name: '应用处于离线模式(isStandalone为true),在线模式无撤回功能' },
              { id: '3', name: '项目列表已加载,至少存在一个项目' },
              { id: '4', name: 'UndoNotification组件已注册并可用' },
            ],
            operationSteps: [
              { id: '1', name: '定位到任意一个项目卡片' },
              { id: '2', name: '点击项目卡片右上角的删除图标(DeleteIcon,data-testid="home-project-delete-btn")' },
              { id: '3', name: '观察是否弹出删除确认对话框(ElMessageBox.confirm)' },
              { id: '4', name: '阅读确认对话框提示信息:"此操作将删除该项目,是否继续？"' },
              { id: '5', name: '点击确认对话框的"确定"按钮' },
              { id: '6', name: '等待删除操作完成' },
              { id: '7', name: '观察项目列表是否移除该项目卡片' },
              { id: '8', name: '观察页面左下角是否出现撤回通知组件' },
              { id: '9', name: '检查撤回通知的提示消息和倒计时进度条' },
              { id: '10', name: '在60秒倒计时结束前,点击"撤回"按钮' },
              { id: '11', name: '观察项目列表是否恢复被删除的项目' },
            ],
            expectedResults: [
              { id: '1', name: '点击删除图标后,立即弹出ElMessageBox确认对话框' },
              { id: '2', name: '对话框标题为"提示",内容为"此操作将删除该项目,是否继续？"' },
              { id: '3', name: '对话框显示"取消"和"确定"两个按钮' },
              { id: '4', name: '点击确定后,该项目卡片从项目列表中消失' },
              { id: '5', name: '页面左下角(bottom: 24px, left: 24px)显示UndoNotification撤回通知组件' },
              { id: '6', name: '撤回通知消息为:"项目已删除"' },
              { id: '7', name: '通知组件显示60秒倒计时进度条,进度逐渐减少' },
              { id: '8', name: '通知组件包含"撤回"按钮和关闭图标' },
              { id: '9', name: '点击"撤回"按钮后,通知组件立即消失' },
              { id: '10', name: '被删除的项目重新出现在项目列表中,位置和内容与删除前一致' },
              { id: '11', name: '项目的所有节点数据(httpNode,websocketNode等)也被恢复' },
              { id: '12', name: '顶部导航栏如果有该项目的Tab,不受影响(删除时未关闭Tab)' },
            ],
            checkpoints: [
              { id: '1', name: 'deleteProject方法被调用,传入项目_id(ProjectManager.vue 行343-396)' },
              { id: '2', name: 'ElMessageBox.confirm弹出确认对话框(行344-348)' },
              { id: '3', name: '用户点击确定后,进入then分支的离线模式逻辑(行359-385)' },
              { id: '4', name: 'projectManagerStore.deleteProject(_id)被调用,返回备份数据backupData' },
              { id: '5', name: 'backupData结构:{ project: ApidocProjectInfo, apiNodes: ApiNode[] }' },
              { id: '6', name: 'deletedProjectData.value保存备份数据' },
              { id: '7', name: 'showUndoNotification.value设置为true,显示撤回通知' },
              { id: '8', name: 'undoMessage.value设置为"项目已删除"' },
              { id: '9', name: 'deleteTimer = setTimeout(清理函数, 60000)启动60秒计时器' },
              { id: '10', name: 'httpMockLogsCache.clearLogsByProjectId(_id)清理Mock日志(仅计时器超时时)' },
              { id: '11', name: 'UndoNotification组件接收props:{ message, duration: 60000, showProgress: true }' },
              { id: '12', name: '用户点击撤回触发handleUndoDelete方法(行398-413)' },
              { id: '13', name: 'clearTimeout(deleteTimer)清除计时器,防止永久删除' },
              { id: '14', name: 'projectManagerStore.restoreProjectFromBackup(deletedProjectData.value)恢复数据' },
              { id: '15', name: 'restoreProjectFromBackup方法遍历恢复project和所有apiNodes(projectManagerStore.ts 行99-123)' },
              { id: '16', name: 'projectCache.updateProject或addProject恢复项目数据' },
              { id: '17', name: 'apiNodesCache.addNode逐个恢复节点数据' },
              { id: '18', name: 'showUndoNotification.value设置为false,隐藏通知' },
              { id: '19', name: 'deletedProjectData.value清空' },
            ],
            notes: [
              { id: '1', name: '删除图标点击事件:@click="deleteProject(item._id)"(ProjectManager.vue 行155)' },
              { id: '2', name: '撤回功能仅在离线模式可用,在线模式删除后立即永久删除' },
              { id: '3', name: 'UndoNotification组件路径:components/common/undoNotification/UndoNotification.vue(行1-186)' },
              { id: '4', name: '60秒倒计时使用setTimeout实现,超时后调用clearLogsByProjectId清理Mock日志' },
              { id: '5', name: '备份数据结构包含完整的project和apiNodes数组,支持完整恢复' },
              { id: '6', name: '删除是软删除,设置isDeleted=true,deletedAt=timestamp(projectCache.ts 行108-122)' },
              { id: '7', name: 'IPC通知:删除后发送projectDeleted事件到顶部导航栏' },
              { id: '8', name: '如果用户点击通知的关闭图标而非撤回按钮,触发handleCloseUndo方法(行415-430)' },
            ],
          },
          {
            purpose: '接口数量需要正确展示,项目中如果有5个httpNode节点,5个websocketNode节点,5个httpMockNode节点,5个websocketMockNode节点,5个folder节点,则项目中接口总数展示为20个',
            precondition: [
              { id: '1', name: '应用已启动,处于离线模式' },
              { id: '2', name: '存在一个测试项目,包含以下节点:' },
              { id: '3', name: '- 5个type="http"的httpNode节点(未删除)' },
              { id: '4', name: '- 5个type="websocket"的websocketNode节点(未删除)' },
              { id: '5', name: '- 5个type="httpMock"的httpMockNode节点(未删除)' },
              { id: '6', name: '- 5个type="websocketMock"的websocketMockNode节点(未删除)' },
              { id: '7', name: '- 5个type="folder"的folder节点(未删除)' },
              { id: '8', name: '所有节点的info.isDeleted属性均为false' },
            ],
            operationSteps: [
              { id: '1', name: '使用apiNodesCache.addNode方法创建测试数据:5个httpNode,5个websocketNode,5个httpMockNode,5个websocketMockNode,5个folder' },
              { id: '2', name: '确保所有节点的projectId指向同一个测试项目' },
              { id: '3', name: '确保所有节点的info.isDeleted为false' },
              { id: '4', name: '调用apiNodesCache.updateProjectNodeNum(projectId)手动触发接口数量更新' },
              { id: '5', name: '导航到/home首页' },
              { id: '6', name: '找到对应的项目卡片' },
              { id: '7', name: '查看项目卡片上显示的"接口总数"数字' },
            ],
            expectedResults: [
              { id: '1', name: '项目卡片显示"接口总数: 20"' },
              { id: '2', name: 'folder节点(5个)不计入接口总数' },
              { id: '3', name: 'httpNode节点(5个)计入总数' },
              { id: '4', name: 'websocketNode节点(5个)计入总数' },
              { id: '5', name: 'httpMockNode节点(5个)计入总数' },
              { id: '6', name: 'websocketMockNode节点(5个)计入总数' },
              { id: '7', name: '总数计算公式:5 + 5 + 5 + 5 = 20(不包括folder)' },
              { id: '8', name: '项目的docNum属性值为20' },
            ],
            checkpoints: [
              { id: '1', name: 'apiNodesCache.updateProjectNodeNum方法被调用(nodesCache.ts 行333-346)' },
              { id: '2', name: 'updateProjectNodeNum内部调用getNodesByProjectId获取所有节点' },
              { id: '3', name: '过滤逻辑:docs.filter(doc => !doc.isDeleted && doc.info.type !== "folder")' },
              { id: '4', name: 'folder类型节点被排除,不计入docNum' },
              { id: '5', name: 'isDeleted为true的节点也被排除' },
              { id: '6', name: 'docNum = filteredDocs.length计算结果为20' },
              { id: '7', name: 'projectCache.updateProjectNodeNum(projectId, 20)更新项目的docNum字段' },
              { id: '8', name: 'IndexedDB中的project对象的docNum字段更新为20' },
              { id: '9', name: 'ProjectManager.vue中{{ item.docNum || 0 }}渲染显示为20(行169)' },
              { id: '10', name: 'ApidocProjectInfo类型的docNum字段为number类型' },
            ],
            notes: [
              { id: '1', name: '接口数量计算逻辑:apiNodesCache.updateProjectNodeNum(projectId)(nodesCache.ts 行333-346)' },
              { id: '2', name: '统计规则:只统计非folder且未删除的节点' },
              { id: '3', name: '支持的节点类型:http,websocket,httpMock,websocketMock,markdown(folder不计入)' },
              { id: '4', name: '触发时机:添加节点,删除节点,恢复节点时自动调用updateProjectNodeNum' },
              { id: '5', name: 'projectCache.updateProjectNodeNum方法路径:行184-197' },
              { id: '6', name: 'docNum字段通过IndexedDB持久化存储,项目列表加载时直接读取' },
            ],
          },
        ],
      },
      // 新建项目
      {
        modelName: '新建项目',
        description: '新建项目',
        atomicFunc: [
          {
            purpose: '新建项目弹窗,验证项目名称必填,打开项目弹窗需要默认focus',
            precondition: [
              { id: '1', name: '应用已启动,处于/home首页' },
              { id: '2', name: 'AddProject.vue组件已注册并可用' },
              { id: '3', name: '项目列表页面已加载完成' },
            ],
            operationSteps: [
              { id: '1', name: '点击首页顶部的"新建项目"按钮(data-testid="home-add-project-btn")' },
              { id: '2', name: '观察新建项目弹窗是否弹出' },
              { id: '3', name: '检查项目名称输入框是否自动获得焦点' },
              { id: '4', name: '不输入任何内容,直接点击"确定"按钮' },
              { id: '5', name: '观察表单验证提示信息' },
              { id: '6', name: '在输入框中输入纯空格字符"   "' },
              { id: '7', name: '点击输入框外部区域触发blur事件' },
              { id: '8', name: '观察自定义validator的验证提示' },
            ],
            expectedResults: [
              { id: '1', name: '新建项目弹窗(el-dialog)正确弹出显示' },
              { id: '2', name: '弹窗标题显示为"新建项目"' },
              { id: '3', name: '项目名称输入框(data-testid="add-project-name-input")自动获得焦点' },
              { id: '4', name: '输入框光标闪烁,用户可以直接输入' },
              { id: '5', name: '不输入任何内容点击确定后,显示错误提示:"请填写项目名称"' },
              { id: '6', name: '确定按钮点击无效,弹窗不关闭' },
              { id: '7', name: '输入纯空格后失去焦点,显示错误提示:"项目名称不能为空或仅包含空格"' },
              { id: '8', name: '输入框边框显示红色错误状态' },
              { id: '9', name: '只有输入有效的项目名称后,确定按钮才能成功提交' },
            ],
            checkpoints: [
              { id: '1', name: 'AddProject组件路径:pages/home/dialog/addProject/AddProject.vue(行1-208)' },
              { id: '2', name: 'AddProject组件props包含:{ modelValue: boolean, isFocus: boolean }(默认isFocus为true)' },
              { id: '3', name: 'el-dialog的@opened事件触发handleDialogOpened方法(行97-106)' },
              { id: '4', name: 'nextTick后通过projectNameInput.value.$el.querySelector("input")获取原生input元素' },
              { id: '5', name: 'inputEl.focus()调用,输入框获得焦点' },
              { id: '6', name: 'formInfo.value包含:{ projectName: "", remark: "" }(行92-95)' },
              { id: '7', name: '表单验证规则定义:rules.value.projectName数组(行107-121)' },
              { id: '8', name: '第一条规则:{ required: true, trigger: "blur", message: "请填写项目名称" }' },
              { id: '9', name: '第二条规则:自定义validator检查!value || !value.trim()' },
              { id: '10', name: 'validator在值为空或纯空格时调用callback(new Error("项目名称不能为空或仅包含空格"))' },
              { id: '11', name: 'handleAddProject方法内调用formRef.value.validate()进行验证(行143-179)' },
              { id: '12', name: '验证失败时,validate()的Promise被reject,不执行后续逻辑' },
            ],
            notes: [
              { id: '1', name: '新建项目按钮位置:ProjectManager.vue顶部工具栏' },
              { id: '2', name: '自动聚焦实现依赖于el-dialog的@opened事件和nextTick' },
              { id: '3', name: '表单验证使用Element Plus的el-form组件和rules属性' },
              { id: '4', name: '自定义validator可以实现复杂的验证逻辑,如检查纯空格' },
              { id: '5', name: 'isFocus prop为false时不自动聚焦,但默认为true' },
              { id: '6', name: 'trigger: "blur"表示失去焦点时触发验证' },
            ],
          },
          {
            purpose: '新建项目以后自动跳转项目详情,顶部tab新增一个tab并且高亮该tab,返回项目列表查看项目确实被添加了,并且新建的项目需要排在最前面',
            precondition: [
              { id: '1', name: '应用已启动,处于/home首页' },
              { id: '2', name: '项目列表已加载,显示现有项目' },
              { id: '3', name: '新建项目弹窗已打开,输入框已获得焦点' },
              { id: '4', name: 'Vue Router和Header.vue组件处于就绪状态' },
            ],
            operationSteps: [
              { id: '1', name: '在新建项目弹窗的项目名称输入框中输入:"测试新项目"' },
              { id: '2', name: '点击"确定"按钮提交表单' },
              { id: '3', name: '等待项目创建完成和路由跳转' },
              { id: '4', name: '观察浏览器地址栏URL变化' },
              { id: '5', name: '检查项目工作区页面是否加载' },
              { id: '6', name: '检查顶部导航栏是否新增Tab' },
              { id: '7', name: '验证新Tab是否处于高亮激活状态' },
              { id: '8', name: '点击顶部导航栏的Logo图标返回首页' },
              { id: '9', name: '在项目列表中查找"测试新项目"' },
              { id: '10', name: '验证新项目在列表中的位置' },
            ],
            expectedResults: [
              { id: '1', name: '点击确定后,表单验证通过' },
              { id: '2', name: '弹窗关闭' },
              { id: '3', name: '路由自动跳转到/v1/apidoc/doc-edit' },
              { id: '4', name: 'URL包含query参数:id=<新项目ID>&name=测试新项目&mode=edit' },
              { id: '5', name: '项目工作区页面正确渲染,显示空白的导航树和内容区' },
              { id: '6', name: '顶部导航栏新增一个Tab,显示文本为"测试新项目"' },
              { id: '7', name: '新增的Tab处于激活状态,背景高亮显示' },
              { id: '8', name: '点击Logo返回/home首页后,项目列表刷新' },
              { id: '9', name: '"测试新项目"出现在"全部项目"区域的第一个位置(最前面)' },
              { id: '10', name: '新项目卡片显示正确的初始数据:接口总数为0,创建者为当前用户,更新日期为当前时间' },
              { id: '11', name: '新项目的收藏状态为未收藏(空心星星图标)' },
            ],
            checkpoints: [
              { id: '1', name: 'AddProject.vue的handleAddProject方法被调用(行143-179)' },
              { id: '2', name: 'formRef.value.validate()验证通过' },
              { id: '3', name: 'projectManagerStore.addProject(projectName, members)被调用' },
              { id: '4', name: '离线模式:使用nanoid()生成项目ID' },
              { id: '5', name: '离线模式:generateEmptyProject(projectId)创建空项目对象' },
              { id: '6', name: '空项目初始数据:{ docNum: 0, owner: { id: "", name: "me" }, members: [], updatedAt: new Date().toISOString(), isStared: false }' },
              { id: '7', name: '离线模式:projectCache.addProject(project)写入IndexedDB' },
              { id: '8', name: 'addProject方法返回:{ projectId, projectName }' },
              { id: '9', name: 'emit("success", { projectId, projectName })触发成功事件' },
              { id: '10', name: 'ProjectManager.vue的handleAddSuccess方法被调用(行478-491)' },
              { id: '11', name: '离线模式:调用getProjectList()刷新项目列表' },
              { id: '12', name: 'router.push跳转到项目工作区,传入id,name,mode参数' },
              { id: '13', name: 'Header.vue监听路由变化,自动创建新Tab' },
              { id: '14', name: '新Tab的activeTabId.value设置为当前项目ID,处于激活状态' },
              { id: '15', name: '项目列表按updatedAt倒序排列,新项目的updatedAt最新,排在第一位' },
            ],
            notes: [
              { id: '1', name: 'projectManagerStore.addProject方法路径:行33-56' },
              { id: '2', name: 'generateEmptyProject函数路径:helper/index.ts(生成默认空项目对象)' },
              { id: '3', name: 'nanoid用于生成唯一的项目ID' },
              { id: '4', name: '项目列表排序:服务器API默认按updatedAt倒序返回,离线模式在getProjectList后排序' },
              { id: '5', name: 'Tab高亮逻辑:Header.vue通过watch监听$route.query.id,匹配时设置activeTabId' },
              { id: '6', name: '在线模式:调用/api/project/add_project API创建项目,需要传递members参数' },
              { id: '7', name: 'handleAddSuccess的router.push触发路由守卫beforeEach,检查数据库初始化' },
            ],
          },
        ],
      },
      // 搜索项目
      {
        modelName: '搜索项目',
        description: '搜索项目',
        atomicFunc: [
          {
            purpose: '没有搜索结果需要展示暂无搜索结果提示',
            precondition: [
              { id: '1', name: '应用已启动,处于/home首页' },
              { id: '2', name: '项目列表已加载,存在至少一个项目' },
              { id: '3', name: '简单搜索模式已激活(未点击高级搜索按钮)' },
            ],
            operationSteps: [
              { id: '1', name: '定位到首页顶部的搜索输入框(data-testid="home-project-search-input")' },
              { id: '2', name: '在搜索框中输入一个不存在的项目名称,例如:"不存在的项目xyz123"' },
              { id: '3', name: '等待300ms防抖延迟' },
              { id: '4', name: '观察项目列表区域的变化' },
              { id: '5', name: '检查是否显示空状态提示' },
            ],
            expectedResults: [
              { id: '1', name: '输入后,projectName.value更新为"不存在的项目xyz123"' },
              { id: '2', name: '300ms后debounceSearch方法执行' },
              { id: '3', name: 'projectList computed重新计算,filter结果为空数组' },
              { id: '4', name: 'starProjects computed也为空数组(收藏的项目也不匹配)' },
              { id: '5', name: '"收藏的项目"区域不显示(v-show="starProjects.length > 0"为false)' },
              { id: '6', name: '"全部项目"区域显示el-empty组件' },
              { id: '7', name: 'el-empty组件显示描述文字:"暂无项目,点击上方按钮创建第一个项目"' },
              { id: '8', name: 'el-empty组件显示默认的空状态图标' },
              { id: '9', name: '项目卡片列表不显示任何卡片' },
            ],
            checkpoints: [
              { id: '1', name: '搜索输入框绑定:v-model="projectName"(ProjectManager.vue 行4)' },
              { id: '2', name: '输入事件绑定:@input="debounceSearch" @change="debounceSearch"(行6-7)' },
              { id: '3', name: 'debounceSearch使用lodash的debounce,延迟300ms(行512-517)' },
              { id: '4', name: 'projectList computed过滤逻辑:val.projectName.match(new RegExp(projectName.value, "gi"))(行287-298)' },
              { id: '5', name: '正则匹配不区分大小写("gi"标志)' },
              { id: '6', name: '匹配失败时filter返回空数组' },
              { id: '7', name: 'isEmptyState computed计算:projectList.length === 0 && !projectLoading(行315)' },
              { id: '8', name: '空状态容器条件渲染:v-if="isEmptyState && !isFold"(行114-116)' },
              { id: '9', name: 'el-empty组件显示,description属性绑定i18n文本' },
            ],
            notes: [
              { id: '1', name: '简单搜索只搜索项目名称(projectName字段)' },
              { id: '2', name: '搜索支持正则表达式,不区分大小写' },
              { id: '3', name: '防抖延迟300ms,避免用户输入时频繁触发计算' },
              { id: '4', name: '空状态提示文案可能不太准确(实际是搜索无结果,但提示"创建第一个项目")' },
              { id: '5', name: '清空搜索框后,项目列表恢复显示所有项目' },
            ],
          },
          {
            purpose: `搜索限制条件展示以下内容:
                        1. 基础信息:项目名称,文档名称,请求URL,创建者(单机模式不需要),维护者(单机模式不需要),请求方法,备注
                        2. 节点类型:目录,http节点,websocket节点,httpMock节点,websocketMock节点
                        3. 请求参数:Query参数,Path参数,请求头参数,Body参数,返回参数,前置脚本,后置脚本,websocket消息内容
                        4. 更新日期:不限制,最近三天,最近一周,最近一个月,最近三个月,自定义(选择自定义后出现日期范围选择)
                      `,
            precondition: [
              { id: '1', name: '应用已启动,处于/home首页' },
              { id: '2', name: '项目列表已加载' },
              { id: '3', name: 'AdvancedSearchPanel.vue组件已注册并可用' },
            ],
            operationSteps: [
              { id: '1', name: '点击搜索框右侧的"高级搜索"按钮(Tools图标,data-testid="home-advanced-search-btn")' },
              { id: '2', name: '观察高级搜索面板是否展开显示' },
              { id: '3', name: '逐一检查"基础信息"区域的所有复选框选项' },
              { id: '4', name: '逐一检查"节点类型"区域的所有复选框选项' },
              { id: '5', name: '逐一检查"请求参数"区域的所有复选框选项' },
              { id: '6', name: '检查"更新日期"区域的所有单选按钮选项' },
              { id: '7', name: '选择"自定义"单选按钮,观察日期选择器是否显示' },
              { id: '8', name: '在离线模式下检查"创建者"和"维护者"选项是否隐藏' },
            ],
            expectedResults: [
              { id: '1', name: '点击高级搜索按钮后,showAdvancedSearch.value变为true' },
              { id: '2', name: '高级搜索面板(AdvancedSearchPanel组件)正确渲染并显示' },
              { id: '3', name: '基础信息区域显示7个复选框:项目名称,文档名称,请求URL,创建者,维护者,请求方法,备注' },
              { id: '4', name: '离线模式下,"创建者"和"维护者"复选框隐藏(v-if="!isStandalone")' },
              { id: '5', name: '节点类型区域显示4个复选框:目录,HTTP节点,WebSocket节点,HTTP Mock节点' },
              { id: '6', name: '请求参数区域显示8个复选框:Query参数,Path参数,请求头,Body,返回参数,前置脚本,后置脚本,WebSocket消息' },
              { id: '7', name: '更新日期区域显示6个单选按钮:不限制,最近3天,最近1周,最近1月,最近3月,自定义' },
              { id: '8', name: '选择"自定义"后,显示el-date-picker日期范围选择器' },
              { id: '9', name: '日期选择器类型为daterange,可以选择开始日期和结束日期' },
              { id: '10', name: '面板底部显示"重置"和"搜索"两个按钮' },
            ],
            checkpoints: [
              { id: '1', name: 'AdvancedSearchPanel组件路径:pages/home/projectManager/advancedSearch/AdvancedSearchPanel.vue(行1-179)' },
              { id: '2', name: 'toggleAdvancedSearch方法切换showAdvancedSearch状态(ProjectManager.vue 行567-569)' },
              { id: '3', name: 'searchConditions.value.searchScope包含所有搜索范围字段(行522-545)' },
              { id: '4', name: 'searchScope字段:projectName, docName, url, creator, maintainer, method, remark(基础信息)' },
              { id: '5', name: 'searchScope字段:folder, http, websocket, httpMock(节点类型)' },
              { id: '6', name: 'searchScope字段:query, path, headers, body, response, preScript, afterScript, wsMessage(请求参数)' },
              { id: '7', name: 'searchConditions.value.dateRange包含:type, customStart, customEnd' },
              { id: '8', name: 'dateRange.type可选值:"unlimited" | "recent3days" | "recent1week" | "recent1month" | "recent3months" | "custom"' },
              { id: '9', name: '创建者和维护者checkbox条件渲染:v-if="!isStandalone"(AdvancedSearchPanel.vue 行14-20)' },
              { id: '10', name: '自定义日期选择器条件渲染:v-if="dateRange.type === \'custom\'"(行67-72)' },
              { id: '11', name: 'AdvancedSearchConditions类型定义:types/advancedSearch.ts(行4-32)' },
            ],
            notes: [
              { id: '1', name: '高级搜索面板使用el-card组件包裹,带有阴影效果' },
              { id: '2', name: '搜索范围使用el-checkbox-group和el-checkbox实现' },
              { id: '3', name: '更新日期使用el-radio-group和el-radio实现' },
              { id: '4', name: '所有复选框默认勾选状态由searchConditions.value.searchScope初始值决定' },
              { id: '5', name: '重置按钮调用handleReset方法,恢复所有条件为默认值' },
              { id: '6', name: '搜索按钮触发高级搜索执行,调用useAdvancedSearch composable的performAdvancedSearch方法' },
            ],
          },
          {
            purpose: '模拟数据验证每个搜索限制条件都生效',
            precondition: [
              { id: '1', name: '应用已启动,处于离线模式' },
              { id: '2', name: '已创建测试项目和测试节点,包含各种类型和数据' },
              { id: '3', name: '测试数据包含:不同类型节点(http,websocket,httpMock,folder)' },
              { id: '4', name: '测试数据包含:不同请求方法(GET,POST,PUT,DELETE)' },
              { id: '5', name: '测试数据包含:不同更新时间(3天内,1周内,1月内,3月内)' },
              { id: '6', name: '测试数据包含:不同字段内容(URL,请求参数,脚本等)' },
            ],
            operationSteps: [
              { id: '1', name: '点击高级搜索按钮,展开搜索面板' },
              { id: '2', name: '测试基础信息搜索:只勾选"项目名称",输入关键词,验证只匹配项目名称' },
              { id: '3', name: '测试基础信息搜索:只勾选"文档名称",输入关键词,验证只匹配节点名称' },
              { id: '4', name: '测试基础信息搜索:只勾选"请求URL",输入关键词,验证只匹配URL字段' },
              { id: '5', name: '测试基础信息搜索:只勾选"请求方法",输入"POST",验证只返回POST方法的节点' },
              { id: '6', name: '测试节点类型搜索:只勾选"HTTP节点",验证只返回type="http"的节点' },
              { id: '7', name: '测试节点类型搜索:只勾选"WebSocket节点",验证只返回type="websocket"的节点' },
              { id: '8', name: '测试节点类型搜索:只勾选"目录",验证只返回type="folder"的节点' },
              { id: '9', name: '测试请求参数搜索:只勾选"Query参数",输入关键词,验证只匹配query字段' },
              { id: '10', name: '测试请求参数搜索:只勾选"Body参数",输入关键词,验证只匹配body字段' },
              { id: '11', name: '测试请求参数搜索:只勾选"前置脚本",输入关键词,验证只匹配preRequestScript字段' },
              { id: '12', name: '测试更新日期搜索:选择"最近3天",验证只返回3天内更新的节点' },
              { id: '13', name: '测试更新日期搜索:选择"最近1周",验证只返回1周内更新的节点' },
              { id: '14', name: '测试更新日期搜索:选择"自定义",指定日期范围,验证只返回范围内的节点' },
              { id: '15', name: '测试组合条件:勾选多个搜索范围,验证OR逻辑(匹配任一字段即返回)' },
            ],
            expectedResults: [
              { id: '1', name: '每个搜索条件都能正确过滤节点' },
              { id: '2', name: '只勾选项目名称时,节点名称,URL等字段包含关键词的节点不返回' },
              { id: '3', name: '节点类型过滤准确,只返回指定类型的节点' },
              { id: '4', name: '请求方法过滤准确,只返回指定方法的HTTP节点' },
              { id: '5', name: '请求参数搜索能深入到节点内部的各个字段(query,path,headers,body等)' },
              { id: '6', name: '日期范围搜索准确,基于节点的updatedAt字段' },
              { id: '7', name: '最近3天:过滤条件为now - 3 * 24 * 60 * 60 * 1000 <= updatedAt' },
              { id: '8', name: '最近1周:过滤条件为now - 7 * 24 * 60 * 60 * 1000 <= updatedAt' },
              { id: '9', name: '最近1月:过滤条件为now - 30 * 24 * 60 * 60 * 1000 <= updatedAt' },
              { id: '10', name: '最近3月:过滤条件为now - 90 * 24 * 60 * 60 * 1000 <= updatedAt' },
              { id: '11', name: '自定义日期:customStart <= updatedAt <= customEnd' },
              { id: '12', name: '组合条件时,搜索范围使用OR逻辑,节点类型和日期范围使用AND逻辑' },
            ],
            checkpoints: [
              { id: '1', name: 'useAdvancedSearch composable路径:composables/useAdvancedSearch.ts(行1-325)' },
              { id: '2', name: 'performAdvancedSearch方法执行搜索(行295-324)' },
              { id: '3', name: 'checkNodeType方法验证节点类型(行11-30)' },
              { id: '4', name: 'checkDateRange方法验证日期范围(行32-57)' },
              { id: '5', name: 'matchBasicInfo方法匹配基础信息字段(行76-112)' },
              { id: '6', name: 'matchRequestParams方法匹配请求参数字段(行114-241)' },
              { id: '7', name: 'matchNodesInBatches方法分批处理节点,批大小为50(行274-293)' },
              { id: '8', name: '关键词匹配使用String.includes(),不区分大小写(toLowerCase())' },
              { id: '9', name: '节点类型检查:conditions.searchScope[nodeType]为true时才匹配' },
              { id: '10', name: '日期计算:new Date(node.updatedAt).getTime()转换为时间戳' },
              { id: '11', name: 'matchBasicInfo返回matchedFields数组,记录匹配的字段名' },
              { id: '12', name: 'matchRequestParams深入检查params,query,path,headers,body等字段' },
              { id: '13', name: '搜索结果按updatedAt倒序排序' },
              { id: '14', name: '每个项目最多显示10个结果(可通过"查看更多"展开)' },
            ],
            notes: [
              { id: '1', name: '高级搜索使用防抖,延迟300ms执行' },
              { id: '2', name: '搜索在主线程执行,分批处理避免阻塞UI' },
              { id: '3', name: '搜索结果包含:projectId, projectName, nodeId, nodeName, nodeType, matchedFields, matches' },
              { id: '4', name: 'matchedFields记录匹配的字段名,用于UI高亮显示' },
              { id: '5', name: 'matches数组最多保存前3个匹配内容,用于搜索结果预览' },
              { id: '6', name: '搜索性能优化:使用内存缓存,分批处理,提前终止' },
            ],
          },
          {
            purpose: '搜索结果区域UI显示正确todo 补充',
            precondition: [
              { id: '1', name: '应用已启动,处于/home首页' },
              { id: '2', name: '已执行高级搜索,返回了多个匹配结果' },
              { id: '3', name: '搜索结果包含多个项目的多个节点' },
              { id: '4', name: 'SearchResults.vue组件已正确渲染' },
            ],
            operationSteps: [
              { id: '1', name: '观察搜索结果区域的整体布局' },
              { id: '2', name: '检查搜索结果是否按项目分组显示' },
              { id: '3', name: '检查每个项目组的标题和匹配数量显示' },
              { id: '4', name: '检查单个搜索结果项的UI元素' },
              { id: '5', name: '验证节点类型图标是否正确显示' },
              { id: '6', name: '验证匹配内容高亮显示是否正确' },
              { id: '7', name: '点击搜索结果项,验证是否跳转到对应节点' },
              { id: '8', name: '如果单个项目结果超过10个,检查"查看更多"按钮是否显示' },
            ],
            expectedResults: [
              { id: '1', name: '搜索结果区域使用el-card组件包裹,显示在高级搜索面板下方' },
              { id: '2', name: '结果按项目分组,每个项目显示一个分组标题' },
              { id: '3', name: '分组标题格式:"<项目名称> (共<总数>个结果)"' },
              { id: '4', name: '每个项目默认显示前10个结果,超过10个显示"查看更多"按钮' },
              { id: '5', name: '单个搜索结果项包含:节点图标,节点类型标签,节点名称,请求方法标签(HTTP节点),项目标签,匹配字段列表,前3个匹配内容' },
              { id: '6', name: '节点图标:FileText(HTTP),Globe(WebSocket),Server(Mock),Folder(目录)' },
              { id: '7', name: '节点类型标签:使用el-tag组件,显示"HTTP","WebSocket","Mock","目录"' },
              { id: '8', name: 'HTTP节点显示请求方法标签,颜色区分:GET(蓝色),POST(绿色),PUT(橙色),DELETE(红色),PATCH(紫色)' },
              { id: '9', name: '项目标签显示项目名称,使用灰色el-tag' },
              { id: '10', name: '匹配字段列表显示所有匹配的字段名,用逗号分隔' },
              { id: '11', name: '匹配内容使用ClEmphasize组件高亮显示关键词,背景色为黄色' },
              { id: '12', name: '点击结果项后,跳转到/v1/apidoc/doc-edit,携带projectId,projectName,nodeId参数' },
              { id: '13', name: '如果搜索无结果,显示el-empty组件,提示"暂无搜索结果"' },
            ],
            checkpoints: [
              { id: '1', name: 'SearchResults.vue组件路径:pages/home/projectManager/advancedSearch/SearchResults.vue(行1-122)' },
              { id: '2', name: 'SearchResultItem.vue组件路径:pages/home/projectManager/advancedSearch/SearchResultItem.vue(行1-196)' },
              { id: '3', name: 'ClEmphasize组件路径:components/common/emphasize/ClEmphasize.vue' },
              { id: '4', name: '搜索结果数据结构:SearchResultItem类型(projectId, projectName, nodeId, nodeName, nodeType, matchedFields, matches)' },
              { id: '5', name: '结果分组逻辑:按projectId分组,Map<projectId, SearchResultItem[]>' },
              { id: '6', name: '空状态条件:v-if="!loading && results.length === 0"(SearchResults.vue 行9-15)' },
              { id: '7', name: '结果项循环:v-for="item in displayedResults"(行22-37)' },
              { id: '8', name: '"查看更多"按钮条件:v-if="!showAll && results.length > 10"' },
              { id: '9', name: '节点图标条件渲染:根据item.nodeType选择FileText/Globe/Server/Folder图标' },
              { id: '10', name: '请求方法标签条件:v-if="item.nodeType === \'http\' && item.method"' },
              { id: '11', name: '方法标签颜色映射:GET->primary, POST->success, PUT->warning, DELETE->danger, PATCH->info' },
              { id: '12', name: '匹配内容循环:v-for="(match, index) in item.matches.slice(0, 3)"' },
              { id: '13', name: 'ClEmphasize组件props:{ content: match, keyword: searchKeyword, highlightBackground: true }' },
              { id: '14', name: '点击事件:@click="handleJumpToNode(item)"(ProjectManager.vue 行605-615)' },
              { id: '15', name: 'handleJumpToNode调用router.push,传入{ path, query: { id, name, mode, nodeId } }' },
            ],
            notes: [
              { id: '1', name: '搜索结果UI设计考虑了可读性和信息密度的平衡' },
              { id: '2', name: '高亮组件ClEmphasize支持不区分大小写的关键词匹配' },
              { id: '3', name: '请求方法标签的颜色遵循行业标准(RESTful API颜色约定)' },
              { id: '4', name: '匹配内容最多显示3个,避免结果项过长' },
              { id: '5', name: '"查看更多"按钮点击后展开显示所有结果,按钮文案变为"收起"' },
              { id: '6', name: '结果项支持键盘导航和回车键跳转(accessibility优化)' },
            ],
          },
        ],
      },
    ],
  },
  // 项目功能区
  {
    modelName: 'projectAddon',
    description: '项目辅助功能',
    children: [
      {
        modelName: 'import',
        description: '导入项目',
        children: [
          // 标准格式
          {
            modelName: 'apiflow类型数据导入',
            description: 'apiflow类型数据导入',
            atomicFunc: [
              {
                purpose: '导入完整的apiflow类型数据(所有节点的所有可能的数据情况),需要完整展示所有数据',
                precondition: [
                  { id: '1', name: '应用已启动,已打开一个项目工作区' },
                  { id: '2', name: '当前处于项目编辑页面(/v1/apidoc/doc-edit)' },
                  { id: '3', name: '准备好符合Apiflow格式的JSON文件,包含所有节点类型:http,websocket,httpMock,websocketMock,folder' },
                  { id: '4', name: 'JSON文件包含type: "apiflow"标识字段' },
                  { id: '5', name: 'JSON文件size不超过config.renderConfig.importProjectConfig.maxSize' },
                ],
                operationSteps: [
                  { id: '1', name: '点击项目工作区顶部工具栏的"导入文档"按钮(ArrowDownToLine图标)或使用快捷键Ctrl+I' },
                  { id: '2', name: '等待导入页面加载,验证Import.vue组件正确渲染' },
                  { id: '3', name: '确认"导入方式"选择为"file"(本地文件上传)' },
                  { id: '4', name: '点击或拖拽上传准备好的Apiflow JSON文件到el-upload拖拽区域' },
                  { id: '5', name: '等待文件读取和格式识别完成' },
                  { id: '6', name: '观察导入数据预览区域,检查el-tree展示的节点结构' },
                  { id: '7', name: '验证所有节点类型(http,websocket,httpMock,websocketMock,folder)都正确解析' },
                  { id: '8', name: '检查每个节点的完整数据:名称,URL,方法,参数,脚本,响应等字段' },
                  { id: '9', name: '配置导入选项:选择"追加方式",不选择目标目录' },
                  { id: '10', name: '点击"确定"按钮执行导入' },
                ],
                expectedResults: [
                  { id: '1', name: '点击导入按钮后,projectNavStore.addProjectNav创建新Tab,tabType为"importDoc"' },
                  { id: '2', name: '导入页面正确渲染,显示三个导入方式选项:file,url,paste' },
                  { id: '3', name: 'el-upload组件显示拖拽上传区域,accept属性为".json"' },
                  { id: '4', name: '上传文件后,beforeUpload方法验证文件大小和类型' },
                  { id: '5', name: 'FileReader读取文件内容,JSON.parse解析为对象' },
                  { id: '6', name: '格式识别逻辑检测到jsonText.value.type === "apiflow",设置importTypeInfo.name为"apiflow"' },
                  { id: '7', name: 'formInfo.value.moyuData.docs填充为解析后的节点数组' },
                  { id: '8', name: 'el-tree组件渲染节点树形结构,使用默认展开(default-expand-all)' },
                  { id: '9', name: '所有节点类型正确显示对应图标:FileText(http),Globe(websocket),Server(mock),Folder(folder)' },
                  { id: '10', name: '每个节点的完整数据都被保留:item.method,item.url,item.headers,item.queryParams,item.paths,item.requestBody,item.responseParams,preRequestScript,afterRequestScript' },
                  { id: '11', name: '点击确定后,调用apiNodesCache.appendNodes方法(离线模式)' },
                  { id: '12', name: '节点成功追加到根目录,不影响现有节点' },
                  { id: '13', name: 'bannerStore.getDocBanner刷新左侧导航树' },
                  { id: '14', name: 'ElMessage.success显示"导入成功"提示' },
                ],
                checkpoints: [
                  { id: '1', name: '导入按钮配置:operations.ts中op: "importDoc",shortcut: ["Ctrl", "I"]' },
                  { id: '2', name: 'Import.vue组件路径:pages/projectWorkbench/layout/content/import/Import.vue' },
                  { id: '3', name: '文件上传:el-upload组件,:before-upload="beforeUpload",:on-change="handleFileChange"' },
                  { id: '4', name: '文件大小限制:config.renderConfig.importProjectConfig.maxSize(默认10MB)' },
                  { id: '5', name: '格式识别:Import.vue行303-306,检查(jsonText.value as ApiflowInfo).type === "apiflow"' },
                  { id: '6', name: 'formInfo.value.moyuData结构:{ docs: HttpNode[], info: { projectName: string } }' },
                  { id: '7', name: '追加逻辑:Import.vue行514-520,apiNodesCache.appendNodes(copiedDocs, projectId)' },
                  { id: '8', name: 'appendNodes方法:nodesCache.ts,遍历docs数组,为每个节点调用addNode' },
                  { id: '9', name: 'addNode自动生成_id(nanoid),设置projectId,保存到IndexedDB' },
                  { id: '10', name: 'bannerStore.getDocBanner触发:行518,刷新projectNavStore中的导航树数据' },
                  { id: '11', name: 'ApiflowInfo类型定义包含type字段和docs数组' },
                ],
                notes: [
                  { id: '1', name: 'Apiflow标准格式:{ type: "apiflow", docs: HttpNode[], info: { projectName: string } }' },
                  { id: '2', name: '节点类型包括:http(HTTP请求),websocket(WebSocket连接),httpMock(HTTP Mock服务器),websocketMock(WebSocket Mock服务器),folder(文件夹)' },
                  { id: '3', name: '完整数据字段包括:基本信息(_id,pid,projectId,sort,info),请求配置(item),脚本(preRequestScript,afterRequestScript),响应(responseParams)' },
                  { id: '4', name: '导入流程:文件选择 -> 读取解析 -> 格式识别 -> 数据预览 -> 配置选项 -> 执行导入 -> 刷新UI' },
                  { id: '5', name: '离线模式直接操作IndexedDB,在线模式调用/api/project/import/moyu API' },
                  { id: '6', name: 'JSON.parse可能抛出异常,需要try-catch包裹并提示"文件格式错误"' },
                ],
              },
              {
                purpose: '验证追加方式选择目标目录和不选择目标目录情况',
                precondition: [
                  { id: '1', name: '应用已启动,已打开一个项目工作区' },
                  { id: '2', name: '项目中已存在节点结构:根目录下有文件夹A,文件夹B,HTTP节点C' },
                  { id: '3', name: '准备好Apiflow格式JSON文件,包含3个节点:HTTP节点1,HTTP节点2,文件夹D' },
                  { id: '4', name: '已打开导入页面,文件已上传并解析完成' },
                  { id: '5', name: '导入模式选择区域显示"追加方式"和"覆盖方式"两个选项' },
                ],
                operationSteps: [
                  { id: '1', name: '**场景1:追加方式 + 不选择目标目录**' },
                  { id: '2', name: '选择导入模式为"追加方式"(formInfo.value.cover = false)' },
                  { id: '3', name: '不勾选任何目标文件夹(mountedId为空)' },
                  { id: '4', name: '点击"确定"按钮执行导入' },
                  { id: '5', name: '观察左侧导航树的变化' },
                  { id: '6', name: '验证导入的节点位置' },
                  { id: '7', name: '**场景2:追加方式 + 选择目标目录**' },
                  { id: '8', name: '重新打开导入页面,上传相同的JSON文件' },
                  { id: '9', name: '选择导入模式为"追加方式"' },
                  { id: '10', name: '在目标文件夹选择区域,展开el-tree并点击选择"文件夹A"' },
                  { id: '11', name: '验证mountedId.value已设置为文件夹A的_id' },
                  { id: '12', name: '点击"确定"按钮执行导入' },
                  { id: '13', name: '观察左侧导航树的变化,展开文件夹A' },
                  { id: '14', name: '验证导入的节点位置' },
                ],
                expectedResults: [
                  { id: '1', name: '**场景1结果**:导入的3个节点(HTTP节点1,HTTP节点2,文件夹D)追加到根目录' },
                  { id: '2', name: '根目录节点列表变为:文件夹A,文件夹B,HTTP节点C,HTTP节点1,HTTP节点2,文件夹D' },
                  { id: '3', name: '原有节点(文件夹A,文件夹B,HTTP节点C)保持不变' },
                  { id: '4', name: '新导入节点的pid为null(根节点)' },
                  { id: '5', name: '新导入节点的sort自动递增,排在原有节点之后' },
                  { id: '6', name: '**场景2结果**:导入的3个节点追加到文件夹A下' },
                  { id: '7', name: '文件夹A展开后显示:HTTP节点1,HTTP节点2,文件夹D' },
                  { id: '8', name: '新导入节点的pid为文件夹A的_id' },
                  { id: '9', name: '文件夹B和HTTP节点C不受影响' },
                  { id: '10', name: '根目录仍然只有:文件夹A,文件夹B,HTTP节点C' },
                  { id: '11', name: '两种场景都不删除或覆盖任何现有节点' },
                ],
                checkpoints: [
                  { id: '1', name: '追加模式配置:Import.vue行108-111,el-radio :value="false"绑定到formInfo.value.cover' },
                  { id: '2', name: '目标文件夹选择:Import.vue行113-130,el-tree组件,@node-click="handleNodeClick"' },
                  { id: '3', name: 'handleNodeClick方法:行269-277,设置mountedId.value = data._id' },
                  { id: '4', name: 'pid处理逻辑:Import.vue行498-506,(!val.pid && mountedId) ? mountedId : val.pid' },
                  { id: '5', name: '场景1:mountedId为空,根节点的pid保持为null' },
                  { id: '6', name: '场景2:mountedId为文件夹A的_id,根节点的pid被设置为mountedId' },
                  { id: '7', name: 'apiNodesCache.appendNodes方法:遍历docs,为每个节点调用addNode' },
                  { id: '8', name: 'addNode方法保留节点的pid值,自动生成新的_id和projectId' },
                  { id: '9', name: 'sort字段自动计算:获取同级最大sort值+1' },
                  { id: '10', name: 'bannerStore.getDocBanner刷新后,projectNavStore中的节点树更新' },
                  { id: '11', name: 'el-tree渲染逻辑根据pid关系构建树形结构' },
                ],
                notes: [
                  { id: '1', name: '追加方式(append)的核心特征:不删除,不覆盖,只添加新节点' },
                  { id: '2', name: '目标目录选择使用el-tree的node-key="_id"属性标识节点' },
                  { id: '3', name: 'pid字段决定节点的父子关系:null表示根节点,非null表示子节点' },
                  { id: '4', name: '导入的JSON文件中如果包含嵌套结构(有pid关系),追加时会保持该结构' },
                  { id: '5', name: '选择目标目录后,只有JSON中的根节点(pid为null)的pid会被修改为目标目录ID,子节点的pid保持不变' },
                  { id: '6', name: 'sort字段用于同级节点的排序,新节点排在同级节点最后' },
                ],
              },
              {
                purpose: '验证覆盖方式选择目标目录和不选择目标目录情况',
                precondition: [
                  { id: '1', name: '已在任意项目中点击顶部工具栏"导入"按钮打开Import.vue导入对话框' },
                  { id: '2', name: '已选择一个包含apiflow格式的JSON文件(formInfo.value.type自动识别为"apiflow")' },
                  { id: '3', name: '当前项目已存在节点数据(例如根目录下有文件夹A,文件夹B和HTTP节点C)' },
                  { id: '4', name: 'formInfo.value.moyuData.docs已解析完成,包含待导入的节点数据' },
                  { id: '5', name: '当前运行在standalone模式(isStandalone.value为true,使用IndexedDB)' },
                ],
                operationSteps: [
                  { id: '1', name: '在Import.vue对话框的"导入方式"区域,选择el-radio value为true的"覆盖"选项' },
                  { id: '2', name: '验证formInfo.value.cover值变为true' },
                  { id: '3', name: '场景1:不选择目标目录 - 保持el-tree"选择目标文件夹"为空,直接点击"确认导入"按钮' },
                  { id: '4', name: '在弹出的el-message-box确认对话框中查看警告内容:"覆盖导入会清空当前项目所有接口数据,导入后无法恢复,是否继续"' },
                  { id: '5', name: '点击"确定"按钮确认覆盖操作' },
                  { id: '6', name: '等待导入完成,观察项目节点树的变化' },
                  { id: '7', name: '记录导入后的节点结构和pid关系' },
                  { id: '8', name: '重新打开Import.vue对话框,再次选择相同的apiflow JSON文件' },
                  { id: '9', name: '选择"覆盖"导入方式' },
                  { id: '10', name: '场景2:选择目标目录 - 在el-tree中点击并选中"文件夹A"作为目标目录(mountedId为文件夹A的_id)' },
                  { id: '11', name: '点击"确认导入"按钮' },
                  { id: '12', name: '在确认对话框中再次点击"确定"按钮' },
                  { id: '13', name: '等待导入完成,观察项目节点树的变化' },
                  { id: '14', name: '对比两次导入后的节点结构差异,特别关注根节点的pid字段' },
                ],
                expectedResults: [
                  { id: '1', name: '场景1(不选择目标目录):覆盖导入会完全清空项目原有的所有节点(文件夹A,B,HTTP节点C全部被删除)' },
                  { id: '2', name: '场景1:导入的节点完全按照JSON文件中的pid结构组织,保持原有层级关系不变' },
                  { id: '3', name: '场景1:JSON中pid为null/undefined的根节点在导入后pid仍为null/undefined,位于项目根目录' },
                  { id: '4', name: '场景1:JSON中所有子节点的pid保持原值,指向其父节点的_id,维持原有父子关系' },
                  { id: '5', name: '场景2(选择目标目录"文件夹A"):覆盖导入同样清空项目原有所有节点' },
                  { id: '6', name: '场景2:导入的根节点(JSON中pid为null/undefined的节点)的pid被设置为选中的文件夹A的_id' },
                  { id: '7', name: '场景2:导入的根节点现在成为文件夹A的子节点,全部显示在文件夹A下' },
                  { id: '8', name: '场景2:JSON中原本就有pid值的子节点保持原有pid值不变,维持相对层级关系' },
                  { id: '9', name: '两个场景都显示"导入成功"的el-message提示信息' },
                  { id: '10', name: '两个场景都会调用bannerStore.getDocBanner刷新文档数量统计' },
                  { id: '11', name: '覆盖导入前都会弹出el-message-box确认对话框,避免误操作导致数据丢失' },
                ],
                checkpoints: [
                  { id: '1', name: 'Import.vue第498-506行:pid处理逻辑 - const processedDoc = { ...val, pid: (!val.pid && mountedId) ? mountedId : val.pid }' },
                  { id: '2', name: 'Import.vue第514-520行:standalone模式下覆盖导入判断 - if (isStandalone.value && formInfo.value.cover)' },
                  { id: '3', name: 'Import.vue第522-527行:调用apiNodesCache.replaceAllNodes(copiedDocs, projectId)执行覆盖操作' },
                  { id: '4', name: 'nodesCache.ts的replaceAllNodes方法会先清空IndexedDB中该projectId的所有httpNodeList记录' },
                  { id: '5', name: 'replaceAllNodes方法然后批量写入新的节点数据到IndexedDB' },
                  { id: '6', name: 'Import.vue第478-485行:el-message-box确认对话框配置 - 标题"覆盖导入",内容警告数据丢失' },
                  { id: '7', name: 'Import.vue第488行:用户点击"取消"时return阻止导入操作,点击"确定"时继续执行' },
                  { id: '8', name: 'Import.vue第206行:el-tree的node-click事件设置mountedId = node._id' },
                  { id: '9', name: '场景1(不选择目标目录):mountedId为undefined,JSON中pid为null/undefined的节点保持pid为null/undefined' },
                  { id: '10', name: '场景2(选择目标目录):mountedId为文件夹A的_id,JSON中pid为null/undefined的节点的pid被设置为mountedId' },
                  { id: '11', name: 'Import.vue第529行:调用bannerStore.getDocBanner({ projectId })更新顶部Banner的文档统计数字' },
                  { id: '12', name: 'Import.vue第530行:message.success(t("导入成功"))显示成功提示' },
                ],
                notes: [
                  { id: '1', name: '覆盖导入的核心区别:formInfo.value.cover = true时调用apiNodesCache.replaceAllNodes()而非appendNodes()' },
                  { id: '2', name: 'replaceAllNodes方法会先清空项目所有节点,然后写入新数据,是破坏性操作,因此需要确认对话框' },
                  { id: '3', name: 'pid处理逻辑与追加模式相同:选择目标目录时,仅处理JSON中原本pid为null/undefined的根节点' },
                  { id: '4', name: '选择目标目录后,导入的节点树整体作为选中目录的子树挂载,但内部相对层级关系保持不变' },
                  { id: '5', name: '覆盖导入适用场景:完全替换项目接口数据,从备份恢复,团队成员之间同步完整项目结构' },
                  { id: '6', name: 'el-message-box确认对话框使用ElMessageBox.confirm方法,type为"warning",confirmButtonText为"确定",cancelButtonText为"取消"' },
                  { id: '7', name: '覆盖导入后IndexedDB中该项目的httpNodeList表会被完全重建,旧数据无法恢复,建议操作前先备份' },
                ],
              },
            ],
          },
          // openapi3.0格式
          {
            modelName: 'openapi3.0类型数据导入',
            description: 'openapi3.0类型数据导入',
            atomicFunc: [
              {
                purpose: '导入完整的openapi3.0类型数据(所有节点的所有可能的数据情况),需要完整展示所有数据',
                precondition: [
                  { id: '1', name: '已在任意项目中点击顶部工具栏"导入"按钮打开Import.vue导入对话框' },
                  { id: '2', name: '准备一个符合OpenAPI 3.0规范的JSON文件,包含openapi字段(如"openapi": "3.0.0")' },
                  { id: '3', name: 'OpenAPI文件包含完整的API定义:paths,components,servers等' },
                ],
                operationSteps: [
                  { id: '1', name: '点击"上传文件"区域的el-upload拖拽上传组件' },
                  { id: '2', name: '选择准备好的OpenAPI 3.0 JSON文件' },
                  { id: '3', name: '触发handleBeforeUpload方法,文件内容被读取并解析为JSON对象' },
                  { id: '4', name: '观察Import.vue第307-310行的格式识别逻辑执行' },
                  { id: '5', name: '观察importTypeInfo显示区域是否正确显示"格式: openapi"和版本号' },
                  { id: '6', name: '查看formInfo.value.type是否被设置为"openapi"' },
                  { id: '7', name: '尝试点击"确认导入"按钮' },
                  { id: '8', name: '观察是否出现警告提示' },
                ],
                expectedResults: [
                  { id: '1', name: '文件上传后,Import.vue能够正确识别OpenAPI 3.0格式(检测jsonText.openapi字段)' },
                  { id: '2', name: 'importTypeInfo.value.name被设置为"openapi"' },
                  { id: '3', name: 'importTypeInfo.value.version被设置为文件中的openapi版本号(如"3.0.0")' },
                  { id: '4', name: 'formInfo.value.type被设置为"openapi"' },
                  { id: '5', name: '但formInfo.value.moyuData.docs保持为空(因为第311行转换代码被注释)' },
                  { id: '6', name: '点击"确认导入"按钮后,handleSubmit方法第491行判断moyuData.docs不存在' },
                  { id: '7', name: '显示el-message警告提示:"请选择需要导入的文件"' },
                  { id: '8', name: '导入操作被中止,项目节点树不发生任何变化' },
                ],
                checkpoints: [
                  { id: '1', name: 'Import.vue第307行:格式识别条件 - (jsonText.value as OpenAPIV3.Document).openapi' },
                  { id: '2', name: 'Import.vue第308行:importTypeInfo.value.name = "openapi"' },
                  { id: '3', name: 'Import.vue第309行:importTypeInfo.value.version = (jsonText.value as OpenAPIV3.Document).openapi' },
                  { id: '4', name: 'Import.vue第310行:formInfo.value.type = "openapi"' },
                  { id: '5', name: 'Import.vue第311行:转换逻辑被注释 - formInfo.value.moyuData.docs = openApiTranslatorInstance.getDocsInfo()' },
                  { id: '6', name: 'openapi.ts转换器文件仅包含空的PostmanTranslator类,无实际转换实现' },
                  { id: '7', name: 'handleSubmit方法第491-493行:if (!formInfo.value.moyuData.docs) { message.warning(t("请选择需要导入的文件")); return; }' },
                  { id: '8', name: 'formInfo.value.moyuData.docs为undefined或null,导致导入流程被中止' },
                ],
                notes: [
                  { id: '1', name: '当前版本的OpenAPI 3.0导入功能仅完成了格式识别部分,数据转换功能尚未实现' },
                  { id: '2', name: 'Import.vue第311行的转换逻辑openApiTranslatorInstance.getDocsInfo()被注释,导致无法将OpenAPI格式转换为apiflow格式' },
                  { id: '3', name: 'openapi.ts转换器文件(应为OpenAPITranslator类)内容为空,需要实现convertToMoyuDocs方法' },
                  { id: '4', name: 'OpenAPI规范定义:paths对象包含所有端点,每个端点可有get/post/put/delete等操作方法' },
                  { id: '5', name: '完整实现需要将OpenAPI的paths转换为apiflow的HttpNode结构,包括URL,method,parameters,requestBody,responses等字段映射' },
                  { id: '6', name: 'OpenAPI的tags可以映射为apiflow的文件夹结构,servers可以映射为环境变量' },
                  { id: '7', name: '此测试用例反映当前实现状态,待转换功能实现后需要更新测试用例内容' },
                ],
              },
              {
                purpose: '验证追加方式选择目标目录和不选择目标目录情况',
                precondition: [
                  { id: '1', name: 'OpenAPI 3.0格式的数据转换功能已实现(当前未实现)' },
                  { id: '2', name: 'formInfo.value.moyuData.docs能够成功从OpenAPI数据转换得到' },
                  { id: '3', name: '已在任意项目中打开Import.vue导入对话框' },
                  { id: '4', name: '已上传OpenAPI 3.0 JSON文件并成功识别格式' },
                ],
                operationSteps: [
                  { id: '1', name: '在"导入方式"区域选择el-radio value为false的"追加"选项' },
                  { id: '2', name: '场景1:不选择目标目录,直接点击"确认导入"' },
                  { id: '3', name: '观察转换后的节点是否添加到项目根目录' },
                  { id: '4', name: '场景2:在el-tree中选择一个文件夹作为目标目录' },
                  { id: '5', name: '点击"确认导入"按钮' },
                  { id: '6', name: '观察转换后的节点是否添加到选中的文件夹下' },
                ],
                expectedResults: [
                  { id: '1', name: '因转换功能未实现,当前版本无法执行追加导入操作' },
                  { id: '2', name: '待转换功能实现后,追加导入行为应与apiflow格式保持一致' },
                  { id: '3', name: '不选择目标目录时,OpenAPI转换的根节点pid为null,位于项目根目录' },
                  { id: '4', name: '选择目标目录时,OpenAPI转换的根节点pid设置为选中文件夹的_id' },
                  { id: '5', name: 'OpenAPI的每个path+method组合应转换为一个独立的HTTP节点' },
                  { id: '6', name: 'OpenAPI的tags应转换为文件夹结构,带相同tag的节点归入同一文件夹' },
                ],
                checkpoints: [
                  { id: '1', name: '待实现:openApiTranslatorInstance.getDocsInfo()方法需要解析OpenAPI的paths对象' },
                  { id: '2', name: '待实现:每个path的每个operation(get/post/put等)转换为一个HttpNode' },
                  { id: '3', name: '待实现:OpenAPI的parameters转换为apiflow的params数组' },
                  { id: '4', name: '待实现:OpenAPI的requestBody转换为apiflow的body对象' },
                  { id: '5', name: '待实现:OpenAPI的responses转换为apiflow的response示例数据' },
                  { id: '6', name: 'pid处理逻辑复用Import.vue第498-506行:(!val.pid && mountedId) ? mountedId : val.pid' },
                  { id: '7', name: '追加操作调用apiNodesCache.appendNodes()方法,与apiflow格式相同' },
                ],
                notes: [
                  { id: '1', name: '此测试用例为OpenAPI转换功能实现后的预期行为描述' },
                  { id: '2', name: '当前版本因转换逻辑未实现,无法执行此测试用例' },
                  { id: '3', name: 'OpenAPI到apiflow的字段映射关系需要在转换器中定义' },
                  { id: '4', name: '建议参考注释代码第341行的转换调用:convertToMoyuDocs(jsonText, { folderNamedType: openapiFolderNamedType })' },
                  { id: '5', name: 'openapiFolderNamedType可能控制文件夹命名规则(按tags或按paths)' },
                ],
              },
              {
                purpose: '验证覆盖方式选择目标目录和不选择目标目录情况',
                precondition: [
                  { id: '1', name: 'OpenAPI 3.0格式的数据转换功能已实现(当前未实现)' },
                  { id: '2', name: 'formInfo.value.moyuData.docs能够成功从OpenAPI数据转换得到' },
                  { id: '3', name: '已在任意项目中打开Import.vue导入对话框' },
                  { id: '4', name: '已上传OpenAPI 3.0 JSON文件并成功识别格式' },
                  { id: '5', name: '当前项目已存在一些节点数据' },
                ],
                operationSteps: [
                  { id: '1', name: '在"导入方式"区域选择el-radio value为true的"覆盖"选项' },
                  { id: '2', name: '验证formInfo.value.cover值变为true' },
                  { id: '3', name: '场景1:不选择目标目录,直接点击"确认导入"' },
                  { id: '4', name: '在el-message-box确认对话框中点击"确定"按钮' },
                  { id: '5', name: '观察项目原有节点是否被清空,OpenAPI转换的节点是否完全替换' },
                  { id: '6', name: '场景2:选择一个文件夹作为目标目录,点击"确认导入"' },
                  { id: '7', name: '确认覆盖操作' },
                  { id: '8', name: '观察项目节点树的变化' },
                ],
                expectedResults: [
                  { id: '1', name: '因转换功能未实现,当前版本无法执行覆盖导入操作' },
                  { id: '2', name: '待转换功能实现后,覆盖导入行为应与apiflow格式保持一致' },
                  { id: '3', name: '覆盖导入会清空项目所有原有节点,弹出确认对话框警告用户' },
                  { id: '4', name: '不选择目标目录时,OpenAPI转换的节点完全替换项目内容,保持原有层级关系' },
                  { id: '5', name: '选择目标目录时,转换的根节点的pid被设置为选中文件夹的_id' },
                  { id: '6', name: 'OpenAPI文件中定义的完整API结构被转换并导入到项目中' },
                ],
                checkpoints: [
                  { id: '1', name: '待实现:转换逻辑需要正确处理OpenAPI的嵌套结构' },
                  { id: '2', name: 'Import.vue第478-485行:覆盖导入确认对话框 - ElMessageBox.confirm' },
                  { id: '3', name: 'Import.vue第508-513行:覆盖导入判断 - if (isStandalone.value && formInfo.value.cover)' },
                  { id: '4', name: '覆盖操作调用apiNodesCache.replaceAllNodes()方法' },
                  { id: '5', name: 'replaceAllNodes会先清空IndexedDB中该projectId的所有httpNodeList记录' },
                  { id: '6', name: 'pid处理逻辑复用:(!val.pid && mountedId) ? mountedId : val.pid' },
                  { id: '7', name: '导入后调用bannerStore.getDocBanner({ projectId })刷新文档统计' },
                ],
                notes: [
                  { id: '1', name: '此测试用例为OpenAPI转换功能实现后的预期行为描述' },
                  { id: '2', name: '当前版本因转换逻辑未实现,无法执行此测试用例' },
                  { id: '3', name: '覆盖导入是破坏性操作,需要确认对话框防止误操作' },
                  { id: '4', name: 'OpenAPI规范支持多个servers定义,可能需要让用户选择导入哪个server的配置' },
                  { id: '5', name: 'OpenAPI的components/schemas可以转换为apiflow的全局数据模型或环境变量' },
                  { id: '6', name: '建议实现时参考swagger-to-postman等开源转换工具的字段映射方案' },
                ],
              },
            ],
          },
          // postman格式
          {
            modelName: 'postman类型数据导入',
            description: 'postman类型数据导入',
            atomicFunc: [
              {
                purpose: '导入完整的postman类型数据(所有节点的所有可能的数据情况),需要完整展示所有数据',
                precondition: [
                  { id: '1', name: '已在任意项目中点击顶部工具栏"导入"按钮打开Import.vue导入对话框' },
                  { id: '2', name: '准备一个Postman Collection导出的JSON文件,包含info._postman_id字段' },
                  { id: '3', name: 'Postman文件包含完整的collection结构:info,item数组,auth,variables等' },
                ],
                operationSteps: [
                  { id: '1', name: '点击"上传文件"区域的el-upload拖拽上传组件' },
                  { id: '2', name: '选择准备好的Postman Collection JSON文件' },
                  { id: '3', name: '触发handleBeforeUpload方法,文件内容被读取并解析为JSON对象' },
                  { id: '4', name: '观察Import.vue第319-321行的格式识别逻辑执行' },
                  { id: '5', name: '观察importTypeInfo显示区域是否正确显示"格式: postman"' },
                  { id: '6', name: '查看formInfo.value.type是否被设置为"postman"' },
                  { id: '7', name: '尝试点击"确认导入"按钮' },
                  { id: '8', name: '观察是否出现警告提示' },
                ],
                expectedResults: [
                  { id: '1', name: '文件上传后,Import.vue能够正确识别Postman格式(检测jsonText.info._postman_id字段)' },
                  { id: '2', name: 'importTypeInfo.value.name被设置为"postman"' },
                  { id: '3', name: 'formInfo.value.type被设置为"postman"' },
                  { id: '4', name: '但formInfo.value.moyuData.docs保持为空(因为转换代码被注释)' },
                  { id: '5', name: '第323行postmanTranslatorInstance实例化代码被注释,转换器未创建' },
                  { id: '6', name: '点击"确认导入"按钮后,handleSubmit方法第491行判断moyuData.docs不存在' },
                  { id: '7', name: '显示el-message警告提示:"请选择需要导入的文件"' },
                  { id: '8', name: '导入操作被中止,项目节点树不发生任何变化' },
                ],
                checkpoints: [
                  { id: '1', name: 'Import.vue第319行:格式识别条件 - (jsonText.value as any)?.info?._postman_id' },
                  { id: '2', name: 'Import.vue第320行:importTypeInfo.value.name = "postman"' },
                  { id: '3', name: 'Import.vue第321行:formInfo.value.type = "postman"' },
                  { id: '4', name: 'Import.vue第323行:转换器实例化被注释 - postmanTranslatorInstance = new PostmanTranslator()' },
                  { id: '5', name: 'Import.vue第336行:转换逻辑被注释 - formInfo.moyuData = postmanTranslatorInstance.convertPostmanData(jsonText)' },
                  { id: '6', name: 'openapi.ts转换器文件错误地声明为PostmanTranslator类,且内容为空,无实际转换实现' },
                  { id: '7', name: 'handleSubmit方法第491-493行:if (!formInfo.value.moyuData.docs) { message.warning(t("请选择需要导入的文件")); return; }' },
                  { id: '8', name: 'formInfo.value.moyuData.docs为undefined或null,导致导入流程被中止' },
                ],
                notes: [
                  { id: '1', name: '当前版本的Postman导入功能仅完成了格式识别部分,数据转换功能尚未实现' },
                  { id: '2', name: 'Import.vue第323和336行的转换逻辑被注释,导致无法将Postman格式转换为apiflow格式' },
                  { id: '3', name: 'Postman转换器文件应该独立创建(postman.ts),目前没有正确的转换器实现' },
                  { id: '4', name: 'Postman Collection结构:info包含集合元数据,item数组包含请求或文件夹,每个item可以嵌套子item' },
                  { id: '5', name: '完整实现需要将Postman的item递归转换为apiflow的HttpNode结构,包括request对象的url,method,header,body等字段映射' },
                  { id: '6', name: 'Postman的folder(文件夹)应转换为apiflow的文件夹节点,保持层级关系' },
                  { id: '7', name: 'Postman的variables可以转换为apiflow的环境变量或项目变量' },
                  { id: '8', name: '此测试用例反映当前实现状态,待转换功能实现后需要更新测试用例内容' },
                ],
              },
              {
                purpose: '验证追加方式选择目标目录和不选择目标目录情况',
                precondition: [
                  { id: '1', name: 'Postman格式的数据转换功能已实现(当前未实现)' },
                  { id: '2', name: 'postmanTranslatorInstance.convertPostmanData()能够成功将Postman Collection转换为apiflow格式' },
                  { id: '3', name: '已在任意项目中打开Import.vue导入对话框' },
                  { id: '4', name: '已上传Postman Collection JSON文件并成功识别格式' },
                ],
                operationSteps: [
                  { id: '1', name: '在"导入方式"区域选择el-radio value为false的"追加"选项' },
                  { id: '2', name: '场景1:不选择目标目录,直接点击"确认导入"' },
                  { id: '3', name: '观察转换后的节点是否添加到项目根目录' },
                  { id: '4', name: '场景2:在el-tree中选择一个文件夹作为目标目录' },
                  { id: '5', name: '点击"确认导入"按钮' },
                  { id: '6', name: '观察转换后的节点是否添加到选中的文件夹下' },
                ],
                expectedResults: [
                  { id: '1', name: '因转换功能未实现,当前版本无法执行追加导入操作' },
                  { id: '2', name: '待转换功能实现后,追加导入行为应与apiflow格式保持一致' },
                  { id: '3', name: '不选择目标目录时,Postman转换的根节点pid为null,位于项目根目录' },
                  { id: '4', name: '选择目标目录时,Postman转换的根节点pid设置为选中文件夹的_id' },
                  { id: '5', name: 'Postman的每个request item应转换为一个独立的HTTP节点' },
                  { id: '6', name: 'Postman的folder item应转换为文件夹节点,保持嵌套层级关系' },
                  { id: '7', name: 'Postman Collection的名称(info.name)可以作为根文件夹或保持扁平结构' },
                ],
                checkpoints: [
                  { id: '1', name: '待实现:postmanTranslatorInstance.convertPostmanData()方法需要递归解析item数组' },
                  { id: '2', name: '待实现:识别item类型 - 有request字段的是请求节点,有item数组的是文件夹节点' },
                  { id: '3', name: '待实现:Postman的request.url对象转换为apiflow的url字符串' },
                  { id: '4', name: '待实现:Postman的request.header数组转换为apiflow的headers数组' },
                  { id: '5', name: '待实现:Postman的request.body(raw/formdata/urlencoded等)转换为apiflow的body对象' },
                  { id: '6', name: '待实现:Postman的request.method转换为apiflow的method字段' },
                  { id: '7', name: 'pid处理逻辑复用Import.vue第498-506行:(!val.pid && mountedId) ? mountedId : val.pid' },
                  { id: '8', name: '追加操作调用apiNodesCache.appendNodes()方法,与apiflow格式相同' },
                ],
                notes: [
                  { id: '1', name: '此测试用例为Postman转换功能实现后的预期行为描述' },
                  { id: '2', name: '当前版本因转换逻辑未实现,无法执行此测试用例' },
                  { id: '3', name: 'Postman到apiflow的字段映射需要处理复杂的url对象结构(protocol,host数组,path数组,query参数)' },
                  { id: '4', name: '建议参考注释代码第336行的转换调用:postmanTranslatorInstance.convertPostmanData(jsonText)' },
                  { id: '5', name: 'Postman的auth配置(apikey,bearer,basic等)需要映射到apiflow的认证headers' },
                  { id: '6', name: 'Postman的pre-request scripts和tests可以映射到apiflow的pre-request和post-request脚本' },
                ],
              },
              {
                purpose: '验证覆盖方式选择目标目录和不选择目标目录情况',
                precondition: [
                  { id: '1', name: 'Postman格式的数据转换功能已实现(当前未实现)' },
                  { id: '2', name: 'postmanTranslatorInstance.convertPostmanData()能够成功转换Postman数据' },
                  { id: '3', name: '已在任意项目中打开Import.vue导入对话框' },
                  { id: '4', name: '已上传Postman Collection JSON文件并成功识别格式' },
                  { id: '5', name: '当前项目已存在一些节点数据' },
                ],
                operationSteps: [
                  { id: '1', name: '在"导入方式"区域选择el-radio value为true的"覆盖"选项' },
                  { id: '2', name: '验证formInfo.value.cover值变为true' },
                  { id: '3', name: '场景1:不选择目标目录,直接点击"确认导入"' },
                  { id: '4', name: '在el-message-box确认对话框中点击"确定"按钮' },
                  { id: '5', name: '观察项目原有节点是否被清空,Postman转换的节点是否完全替换' },
                  { id: '6', name: '场景2:选择一个文件夹作为目标目录,点击"确认导入"' },
                  { id: '7', name: '确认覆盖操作' },
                  { id: '8', name: '观察项目节点树的变化' },
                ],
                expectedResults: [
                  { id: '1', name: '因转换功能未实现,当前版本无法执行覆盖导入操作' },
                  { id: '2', name: '待转换功能实现后,覆盖导入行为应与apiflow格式保持一致' },
                  { id: '3', name: '覆盖导入会清空项目所有原有节点,弹出确认对话框警告用户' },
                  { id: '4', name: '不选择目标目录时,Postman转换的节点完全替换项目内容,保持原有层级关系' },
                  { id: '5', name: '选择目标目录时,转换的根节点的pid被设置为选中文件夹的_id' },
                  { id: '6', name: 'Postman Collection中定义的完整请求集合被转换并导入到项目中' },
                  { id: '7', name: 'Postman的文件夹层级结构在转换后得到保持' },
                ],
                checkpoints: [
                  { id: '1', name: '待实现:转换逻辑需要正确处理Postman的递归item结构' },
                  { id: '2', name: 'Import.vue第478-485行:覆盖导入确认对话框 - ElMessageBox.confirm' },
                  { id: '3', name: 'Import.vue第508-513行:覆盖导入判断 - if (isStandalone.value && formInfo.value.cover)' },
                  { id: '4', name: '覆盖操作调用apiNodesCache.replaceAllNodes()方法' },
                  { id: '5', name: 'replaceAllNodes会先清空IndexedDB中该projectId的所有httpNodeList记录' },
                  { id: '6', name: 'pid处理逻辑复用:(!val.pid && mountedId) ? mountedId : val.pid' },
                  { id: '7', name: '导入后调用bannerStore.getDocBanner({ projectId })刷新文档统计' },
                ],
                notes: [
                  { id: '1', name: '此测试用例为Postman转换功能实现后的预期行为描述' },
                  { id: '2', name: '当前版本因转换逻辑未实现,无法执行此测试用例' },
                  { id: '3', name: '覆盖导入是破坏性操作,需要确认对话框防止误操作' },
                  { id: '4', name: 'Postman Collection可能非常庞大(数百个请求),转换过程需要考虑性能优化' },
                  { id: '5', name: 'Postman的environment变量应该作为单独的导入选项或合并到项目变量中' },
                  { id: '6', name: '建议实现时参考postman-to-openapi等开源转换工具的解析逻辑' },
                  { id: '7', name: 'Postman v2.1格式与v2.0格式可能存在差异,转换器需要兼容多个版本' },
                ],
              },
            ],
          },
          // ai识别数据类型进行导入
          {
            modelName: 'ai识别数据类型进行导入',
            description: 'ai识别数据类型进行导入',
            atomicFunc: [
              {
                purpose: '搜索afx支持的所有导入类型,模拟这些数据,通过大模型对其进行转换,需要完整展示所有数据',
                precondition: [
                  { id: '1', name: '【功能未实现】AI导入功能当前版本尚未开发' },
                  { id: '2', name: 'Import.vue的importTypes数组仅包含file,url,paste三种导入方式,无AI选项' },
                  { id: '3', name: '预期功能:用户上传任意格式的API文档数据(JSON/YAML/文本等)' },
                  { id: '4', name: '预期功能:通过AI大模型自动识别数据格式和结构' },
                  { id: '5', name: '预期功能:AI将识别出的数据转换为apiflow格式' },
                ],
                operationSteps: [
                  { id: '1', name: '【待实现】在导入对话框中添加新的导入方式选项:带有Sparkles图标的"AI智能识别"' },
                  { id: '2', name: '【待实现】点击"AI智能识别"选项,切换currentImportType为"ai"' },
                  { id: '3', name: '【待实现】显示文件上传区域或文本粘贴区域,支持多种格式输入' },
                  { id: '4', name: '【待实现】用户上传/粘贴未知格式的API文档数据(如非标准JSON,自定义格式等)' },
                  { id: '5', name: '【待实现】点击"开始识别"按钮,调用AI服务进行格式识别' },
                  { id: '6', name: '【待实现】AI分析数据结构,识别可能的格式类型(OpenAPI/Postman/Swagger/自定义等)' },
                  { id: '7', name: '【待实现】AI提取API端点,方法,参数,响应等信息' },
                  { id: '8', name: '【待实现】显示识别结果预览,包含转换后的节点树结构' },
                  { id: '9', name: '【待实现】用户确认识别结果,选择导入方式(追加/覆盖)' },
                  { id: '10', name: '【待实现】点击"确认导入"按钮,将AI转换的数据导入项目' },
                ],
                expectedResults: [
                  { id: '1', name: '【功能未实现】当前版本Import.vue不包含AI导入功能' },
                  { id: '2', name: '【预期行为】AI能够识别apiflow,OpenAPI,Postman,Swagger等标准格式' },
                  { id: '3', name: '【预期行为】AI能够处理非标准格式或格式混合的文档数据' },
                  { id: '4', name: '【预期行为】AI提取的API信息包括:URL,HTTP方法,请求头,请求体,响应示例等' },
                  { id: '5', name: '【预期行为】AI识别结果以可视化方式展示,用户可以编辑修正' },
                  { id: '6', name: '【预期行为】转换后的数据符合apiflow的HttpNode结构定义' },
                  { id: '7', name: '【预期行为】导入过程支持进度显示和错误提示' },
                  { id: '8', name: '【预期行为】AI识别失败时提供降级方案(手动选择格式或编辑数据)' },
                ],
                checkpoints: [
                  { id: '1', name: '【待开发】Import.vue需要添加AI导入的UI入口和交互流程' },
                  { id: '2', name: '【待开发】需要集成AI服务(如通过aiStore调用AI API)' },
                  { id: '3', name: '【待开发】AI prompt设计:明确输入输出格式,提供API文档示例作为few-shot' },
                  { id: '4', name: '【待开发】AI响应解析:将AI返回的结构化数据转换为HttpNode数组' },
                  { id: '5', name: '【待开发】错误处理:AI服务不可用,识别失败,数据格式错误等异常情况' },
                  { id: '6', name: '【待开发】识别结果预览组件:以树形结构展示AI提取的API节点' },
                  { id: '7', name: '【待开发】用户编辑功能:允许用户修正AI识别的错误或遗漏' },
                  { id: '8', name: '导入逻辑复用:AI转换后调用现有的appendNodes/replaceAllNodes方法' },
                ],
                notes: [
                  { id: '1', name: 'AI识别导入功能当前版本(截至编写时)尚未实现,此测试用例描述预期功能' },
                  { id: '2', name: '实现建议:可以参考aiStore(src/renderer/store/aiStore)的AI调用方式' },
                  { id: '3', name: '实现建议:AI prompt可以包含apiflow,OpenAPI,Postman格式的schema定义作为参考' },
                  { id: '4', name: '实现建议:支持增量识别(用户可以分批上传,AI逐步识别)' },
                  { id: '5', name: '实现建议:AI识别历史记录保存,便于用户回溯和复用' },
                  { id: '6', name: '技术难点:AI输出的稳定性和准确性,需要充分测试各种格式的文档' },
                  { id: '7', name: '技术难点:处理大文档时的性能优化(分块处理,流式输出等)' },
                  { id: '8', name: '用户价值:降低导入门槛,支持非标准格式的API文档快速导入' },
                ],
              },
              {
                purpose: '验证追加方式选择目标目录和不选择目标目录情况',
                precondition: [
                  { id: '1', name: '【功能未实现】AI识别导入功能已开发完成(当前未实现)' },
                  { id: '2', name: 'AI能够成功识别并转换API文档数据为apiflow格式' },
                  { id: '3', name: '已在任意项目中打开导入对话框,选择"AI智能识别"导入方式' },
                  { id: '4', name: 'AI已完成数据识别,formInfo.value.moyuData.docs包含转换后的节点数据' },
                ],
                operationSteps: [
                  { id: '1', name: '在"导入方式"区域选择"追加"选项(formInfo.value.cover = false)' },
                  { id: '2', name: '场景1:不选择目标目录,直接点击"确认导入"' },
                  { id: '3', name: '观察AI转换的节点是否追加到项目根目录' },
                  { id: '4', name: '验证原有节点未被删除,新节点排在同级节点最后' },
                  { id: '5', name: '场景2:在el-tree中选择一个文件夹作为目标目录' },
                  { id: '6', name: '点击"确认导入"按钮' },
                  { id: '7', name: '观察AI转换的节点是否追加到选中的文件夹下' },
                  { id: '8', name: '验证AI识别的层级关系是否正确保持' },
                ],
                expectedResults: [
                  { id: '1', name: '【预期行为】AI转换的数据追加导入行为与apiflow格式完全一致' },
                  { id: '2', name: '【预期行为】不选择目标目录时,AI转换的根节点pid为null,位于项目根目录' },
                  { id: '3', name: '【预期行为】选择目标目录时,AI转换的根节点pid设置为选中文件夹的_id' },
                  { id: '4', name: '【预期行为】AI识别的文件夹和请求节点的嵌套关系正确保持' },
                  { id: '5', name: '【预期行为】原项目节点不受影响,新旧节点共存' },
                  { id: '6', name: '【预期行为】导入成功后显示成功提示,bannerStore刷新文档统计' },
                ],
                checkpoints: [
                  { id: '1', name: 'AI转换输出的数据结构必须符合HttpNode类型定义' },
                  { id: '2', name: 'pid处理逻辑复用Import.vue第498-506行:(!val.pid && mountedId) ? mountedId : val.pid' },
                  { id: '3', name: '追加操作调用apiNodesCache.appendNodes()方法' },
                  { id: '4', name: 'AI转换时需要正确设置节点的type字段(folder或api)' },
                  { id: '5', name: 'AI转换时需要生成唯一的_id字段(可以使用nanoid)' },
                  { id: '6', name: 'AI转换时需要设置合理的sort字段以控制节点排序' },
                ],
                notes: [
                  { id: '1', name: '此测试用例为AI导入功能实现后的预期行为描述' },
                  { id: '2', name: 'AI转换后的数据导入流程完全复用现有的导入逻辑,无需额外开发' },
                  { id: '3', name: 'AI识别的准确性直接影响导入质量,建议提供人工校验环节' },
                ],
              },
              {
                purpose: '验证覆盖方式选择目标目录和不选择目标目录情况',
                precondition: [
                  { id: '1', name: '【功能未实现】AI识别导入功能已开发完成(当前未实现)' },
                  { id: '2', name: 'AI能够成功识别并转换API文档数据为apiflow格式' },
                  { id: '3', name: '已在任意项目中打开导入对话框,选择"AI智能识别"导入方式' },
                  { id: '4', name: 'AI已完成数据识别,formInfo.value.moyuData.docs包含转换后的节点数据' },
                  { id: '5', name: '当前项目已存在一些节点数据' },
                ],
                operationSteps: [
                  { id: '1', name: '在"导入方式"区域选择"覆盖"选项(formInfo.value.cover = true)' },
                  { id: '2', name: '场景1:不选择目标目录,直接点击"确认导入"' },
                  { id: '3', name: '在el-message-box确认对话框中查看警告内容并点击"确定"' },
                  { id: '4', name: '观察项目原有节点是否被清空,AI转换的节点是否完全替换' },
                  { id: '5', name: '场景2:选择一个文件夹作为目标目录,点击"确认导入"' },
                  { id: '6', name: '确认覆盖操作' },
                  { id: '7', name: '观察AI转换节点的pid关系是否正确' },
                ],
                expectedResults: [
                  { id: '1', name: '【预期行为】AI转换的数据覆盖导入行为与apiflow格式完全一致' },
                  { id: '2', name: '【预期行为】覆盖导入前弹出确认对话框,警告数据丢失风险' },
                  { id: '3', name: '【预期行为】确认后,项目原有所有节点被清空' },
                  { id: '4', name: '【预期行为】AI转换的节点完全替换项目内容,保持原有层级关系' },
                  { id: '5', name: '【预期行为】选择目标目录时,AI转换的根节点的pid被设置为选中文件夹的_id' },
                ],
                checkpoints: [
                  { id: '1', name: 'Import.vue第478-485行:覆盖导入确认对话框' },
                  { id: '2', name: 'Import.vue第508-513行:覆盖导入判断逻辑' },
                  { id: '3', name: '覆盖操作调用apiNodesCache.replaceAllNodes()方法' },
                  { id: '4', name: 'AI转换数据的完整性校验:确保所有必需字段都已填充' },
                ],
                notes: [
                  { id: '1', name: '此测试用例为AI导入功能实现后的预期行为描述' },
                  { id: '2', name: 'AI识别大量API时需要考虑性能,建议显示识别进度' },
                  { id: '3', name: '覆盖导入是破坏性操作,建议在确认对话框中显示AI识别的节点数量' },
                ],
              },
            ],
          },
          // 选择代码仓库导入
          {
            modelName: '通过代码仓库识别接口',
            description: '通过代码仓库识别接口',
            atomicFunc: [
              {
                purpose: '搜索go,java,nodejs,python等常见后端应用框架,模拟这些框架项目数据,使用大模型进行解析,需要完整展示所有数据',
                precondition: [
                  { id: '1', name: '【功能未实现】代码仓库导入功能当前版本尚未开发' },
                  { id: '2', name: 'Import.vue的importTypes数组不包含代码仓库导入选项' },
                  { id: '3', name: '预期功能:用户提供代码仓库地址(Git URL或本地路径)' },
                  { id: '4', name: '预期功能:系统自动识别后端框架类型(Go Gin/Echo,Java Spring,Node.js Express/Koa,Python Flask/Django等)' },
                  { id: '5', name: '预期功能:通过AI大模型分析代码,提取路由定义和API端点信息' },
                  { id: '6', name: '预期功能:自动生成对应的apiflow格式API节点' },
                ],
                operationSteps: [
                  { id: '1', name: '【待实现】在导入对话框中添加新的导入方式选项:带有GitBranch图标的"代码仓库识别"' },
                  { id: '2', name: '【待实现】点击"代码仓库识别"选项,切换currentImportType为"repository"' },
                  { id: '3', name: '【待实现】显示代码仓库配置表单:仓库地址(Git URL/本地路径),分支名称,认证信息(可选)' },
                  { id: '4', name: '【待实现】用户输入仓库地址(如https://github.com/user/project.git)或选择本地项目文件夹' },
                  { id: '5', name: '【待实现】点击"开始分析"按钮,系统克隆/读取代码仓库' },
                  { id: '6', name: '【待实现】AI分析项目结构,识别框架类型(检测package.json,pom.xml,go.mod,requirements.txt等)' },
                  { id: '7', name: '【待实现】AI扫描路由定义文件(如Go的router.go,Java的Controller类,Node.js的routes.js等)' },
                  { id: '8', name: '【待实现】AI提取API端点信息:路径,HTTP方法,参数,中间件,注释文档等' },
                  { id: '9', name: '【待实现】显示识别结果预览,包含框架类型,识别到的API数量,节点树结构' },
                  { id: '10', name: '【待实现】用户确认识别结果,可以筛选需要导入的API' },
                  { id: '11', name: '【待实现】选择导入方式(追加/覆盖)和目标目录' },
                  { id: '12', name: '【待实现】点击"确认导入"按钮,将识别的API导入项目' },
                ],
                expectedResults: [
                  { id: '1', name: '【功能未实现】当前版本Import.vue不包含代码仓库导入功能' },
                  { id: '2', name: '【预期行为】支持主流后端框架:Go (Gin/Echo/Beego),Java (Spring Boot/Spring MVC),Node.js (Express/Koa/Fastify),Python (Flask/Django/FastAPI)' },
                  { id: '3', name: '【预期行为】AI能够识别RESTful路由定义:@GetMapping,router.GET,@app.route等注解和方法' },
                  { id: '4', name: '【预期行为】提取完整的API信息:路径参数,查询参数,请求体,响应格式,权限要求等' },
                  { id: '5', name: '【预期行为】保持代码中的文件夹结构:按Controller/Router文件组织,或按模块/包名组织' },
                  { id: '6', name: '【预期行为】提取代码注释作为API文档(如Swagger注解,JSDoc注释等)' },
                  { id: '7', name: '【预期行为】转换后的数据符合apiflow的HttpNode结构定义' },
                  { id: '8', name: '【预期行为】支持增量更新:再次分析同一仓库时,识别新增/修改/删除的API' },
                  { id: '9', name: '【预期行为】分析过程显示进度(克隆代码,识别框架,扫描文件,提取API等阶段)' },
                ],
                checkpoints: [
                  { id: '1', name: '【待开发】Import.vue需要添加代码仓库导入的UI入口和表单' },
                  { id: '2', name: '【待开发】需要集成Git操作(克隆仓库)或文件系统访问(读取本地项目)' },
                  { id: '3', name: '【待开发】框架识别逻辑:通过依赖文件和项目结构判断框架类型' },
                  { id: '4', name: '【待开发】AI prompt设计:针对不同框架的路由定义模式,提供识别规则' },
                  { id: '5', name: '【待开发】代码解析:使用AST(抽象语法树)或正则表达式提取路由信息' },
                  { id: '6', name: '【待开发】AI辅助理解:处理复杂路由逻辑(中间件,路由组,动态路由等)' },
                  { id: '7', name: '【待开发】注释文档提取:解析Swagger/OpenAPI注解,JSDoc,Godoc等' },
                  { id: '8', name: '【待开发】错误处理:仓库不可访问,框架不支持,代码解析失败等异常' },
                  { id: '9', name: '【待开发】安全性:避免执行仓库中的恶意代码,沙箱化分析环境' },
                  { id: '10', name: '导入逻辑复用:转换后调用现有的appendNodes/replaceAllNodes方法' },
                ],
                notes: [
                  { id: '1', name: '代码仓库导入功能当前版本(截至编写时)尚未实现,此测试用例描述预期功能' },
                  { id: '2', name: '实现建议:可以参考swagger-jsdoc,go-swagger等工具的代码分析方法' },
                  { id: '3', name: '实现建议:对于复杂框架(如Spring),可以利用框架自带的元数据导出功能' },
                  { id: '4', name: '实现建议:本地分析优先(避免频繁克隆代码),缓存分析结果' },
                  { id: '5', name: '实现建议:支持配置文件(.apiflowrc)指定需要扫描的路径和排除规则' },
                  { id: '6', name: '技术难点:不同框架的路由定义差异大,需要为每种框架编写专门的解析规则' },
                  { id: '7', name: '技术难点:动态路由和中间件的识别(如权限校验,参数验证等)' },
                  { id: '8', name: '技术难点:处理大型项目(数千个API)时的性能优化' },
                  { id: '9', name: '用户价值:前后端协作场景,后端代码变更后自动同步到API文档' },
                  { id: '10', name: '用户价值:新项目快速生成API文档,减少手动录入工作量' },
                ],
              },
              {
                purpose: '验证追加方式选择目标目录和不选择目标目录情况',
                precondition: [
                  { id: '1', name: '【功能未实现】代码仓库导入功能已开发完成(当前未实现)' },
                  { id: '2', name: '已成功分析代码仓库,提取API端点信息并转换为apiflow格式' },
                  { id: '3', name: '已在任意项目中打开导入对话框,选择"代码仓库识别"导入方式' },
                  { id: '4', name: 'formInfo.value.moyuData.docs包含从代码仓库提取的API节点数据' },
                ],
                operationSteps: [
                  { id: '1', name: '在"导入方式"区域选择"追加"选项(formInfo.value.cover = false)' },
                  { id: '2', name: '场景1:不选择目标目录,直接点击"确认导入"' },
                  { id: '3', name: '观察从代码仓库提取的API节点是否追加到项目根目录' },
                  { id: '4', name: '验证原有节点未被删除,代码仓库节点保持原有模块结构' },
                  { id: '5', name: '场景2:在el-tree中选择一个文件夹作为目标目录' },
                  { id: '6', name: '点击"确认导入"按钮' },
                  { id: '7', name: '观察API节点是否追加到选中的文件夹下,保持代码中的Controller/模块层级' },
                ],
                expectedResults: [
                  { id: '1', name: '【预期行为】代码仓库提取的数据追加导入行为与apiflow格式完全一致' },
                  { id: '2', name: '【预期行为】不选择目标目录时,提取的根节点pid为null,位于项目根目录' },
                  { id: '3', name: '【预期行为】选择目标目录时,提取的根节点pid设置为选中文件夹的_id' },
                  { id: '4', name: '【预期行为】代码中的模块/包结构映射为apiflow的文件夹层级' },
                  { id: '5', name: '【预期行为】同一Controller/Router的API归入同一文件夹' },
                  { id: '6', name: '【预期行为】原项目节点不受影响,代码仓库节点与手动创建的节点共存' },
                  { id: '7', name: '【预期行为】导入成功后显示统计信息(识别到N个API,导入M个节点)' },
                ],
                checkpoints: [
                  { id: '1', name: '代码仓库转换输出的数据结构必须符合HttpNode类型定义' },
                  { id: '2', name: 'pid处理逻辑复用Import.vue第498-506行:(!val.pid && mountedId) ? mountedId : val.pid' },
                  { id: '3', name: '追加操作调用apiNodesCache.appendNodes()方法' },
                  { id: '4', name: '提取时需要正确设置节点的type字段(folder用于模块,api用于端点)' },
                  { id: '5', name: '提取时需要生成唯一的_id字段,避免与现有节点冲突' },
                  { id: '6', name: '提取的API需要包含完整的url,method,params,headers等字段' },
                  { id: '7', name: '代码注释转换为节点的description字段' },
                ],
                notes: [
                  { id: '1', name: '此测试用例为代码仓库导入功能实现后的预期行为描述' },
                  { id: '2', name: '代码仓库分析结果可以缓存,再次导入时提示用户是否使用缓存' },
                  { id: '3', name: '建议支持部分导入:用户可以在预览界面取消勾选不需要的API' },
                ],
              },
              {
                purpose: '验证覆盖方式选择目标目录和不选择目标目录情况',
                precondition: [
                  { id: '1', name: '【功能未实现】代码仓库导入功能已开发完成(当前未实现)' },
                  { id: '2', name: '已成功分析代码仓库,提取API端点信息并转换为apiflow格式' },
                  { id: '3', name: '已在任意项目中打开导入对话框,选择"代码仓库识别"导入方式' },
                  { id: '4', name: 'formInfo.value.moyuData.docs包含从代码仓库提取的API节点数据' },
                  { id: '5', name: '当前项目已存在一些节点数据' },
                ],
                operationSteps: [
                  { id: '1', name: '在"导入方式"区域选择"覆盖"选项(formInfo.value.cover = true)' },
                  { id: '2', name: '场景1:不选择目标目录,直接点击"确认导入"' },
                  { id: '3', name: '在el-message-box确认对话框中查看警告内容并点击"确定"' },
                  { id: '4', name: '观察项目原有节点是否被清空,代码仓库提取的API是否完全替换' },
                  { id: '5', name: '场景2:选择一个文件夹作为目标目录,点击"确认导入"' },
                  { id: '6', name: '确认覆盖操作' },
                  { id: '7', name: '观察代码仓库API节点的组织结构是否正确' },
                ],
                expectedResults: [
                  { id: '1', name: '【预期行为】代码仓库提取的数据覆盖导入行为与apiflow格式完全一致' },
                  { id: '2', name: '【预期行为】覆盖导入前弹出确认对话框,警告数据丢失风险' },
                  { id: '3', name: '【预期行为】确认后,项目原有所有节点被清空' },
                  { id: '4', name: '【预期行为】代码仓库API完全替换项目内容,保持代码中的模块层级关系' },
                  { id: '5', name: '【预期行为】选择目标目录时,提取的根节点的pid被设置为选中文件夹的_id' },
                  { id: '6', name: '【预期行为】覆盖后项目结构完全反映代码仓库的API组织方式' },
                ],
                checkpoints: [
                  { id: '1', name: 'Import.vue第478-485行:覆盖导入确认对话框' },
                  { id: '2', name: 'Import.vue第508-513行:覆盖导入判断逻辑' },
                  { id: '3', name: '覆盖操作调用apiNodesCache.replaceAllNodes()方法' },
                  { id: '4', name: '代码仓库提取数据的完整性校验:确保所有必需字段都已填充' },
                  { id: '5', name: '提取的文件夹节点和API节点的pid关系正确建立' },
                ],
                notes: [
                  { id: '1', name: '此测试用例为代码仓库导入功能实现后的预期行为描述' },
                  { id: '2', name: '覆盖导入适用场景:初始化新项目,直接将后端代码的API结构同步到apiflow' },
                  { id: '3', name: '建议提供"同步"功能:定期分析代码仓库,自动更新变更的API(增量覆盖)' },
                  { id: '4', name: '覆盖导入是破坏性操作,确认对话框应显示识别到的API数量和模块结构预览' },
                ],
              },
            ],
          },
        ],
      },
      {
        modelName: 'export',
        description: '导出项目',
        atomicFunc: [
          {
            purpose: '导出apiflow格式数据',
            precondition: [
              { id: '1', name: '已登录并打开任意项目工作区' },
              { id: '2', name: '项目中存在至少一个HTTP或WebSocket节点' },
              { id: '3', name: '应用运行在离线模式(runtimeStore.networkMode === "offline")' },
            ],
            operationSteps: [
              { id: '1', name: '点击项目工作区顶部导航栏中的"导出"按钮或菜单项' },
              { id: '2', name: '在导出弹窗中,点击选择"JSON文档"类型(moyu类型,显示应用logo图标)' },
              { id: '3', name: '(可选)开启"选择导出"配置,通过el-tree勾选需要导出的节点' },
              { id: '4', name: '观察统计信息:总数,文件夹数量,文档数量' },
              { id: '5', name: '点击"确定导出"按钮' },
              { id: '6', name: '等待导出完成,浏览器自动下载JSON文件' },
              { id: '7', name: '打开下载的JSON文件,验证数据格式和内容' },
            ],
            expectedResults: [
              { id: '1', name: '导出弹窗正确显示,包含HTML,WORD,JSON文档,OpenAPI四种导出类型' },
              { id: '2', name: '选择JSON文档后,对应的.item元素添加.active类名,显示边框高亮' },
              { id: '3', name: '开启"选择导出"后,显示el-tree组件,展示当前项目的所有节点(folder和文档节点)' },
              { id: '4', name: '统计信息实时更新:总数=allCheckedNodes.length,文件夹数量=type为folder的节点数,文档数量=type不为folder的节点数' },
              { id: '5', name: '点击导出后,触发handleExportAsApiflow方法' },
              { id: '6', name: '从apiNodesCache.getNodesByProjectId获取所有项目节点' },
              { id: '7', name: '根据选中节点ID过滤需要导出的节点,如果未选择则导出全部节点' },
              { id: '8', name: '生成的JSON文件结构:{ type: "apiflow", info: { projectName }, docs: [所有选中节点的完整数据] }' },
              { id: '9', name: '文件名格式:{项目名称}.json,contentType为application/json' },
              { id: '10', name: '使用downloadStringAsText方法触发浏览器下载,无需服务器交互' },
            ],
            checkpoints: [
              { id: '1', name: 'Export.vue第202-238行:handleExportAsApiflow方法实现' },
              { id: '2', name: 'Export.vue第17-20行:JSON文档选项,selectedType === "moyu"时显示.active类' },
              { id: '3', name: 'Export.vue第123行:isStandalone = computed(() => runtimeStore.networkMode === "offline")' },
              { id: '4', name: 'Export.vue第204-211行:从apiNodesCache获取节点并根据selectedIds过滤' },
              { id: '5', name: 'Export.vue第212-218行:result对象结构包含type,info,docs三个字段' },
              { id: '6', name: 'Export.vue第219行:downloadStringAsText(JSON.stringify(result), `${projectName}.json`, "application/json")' },
              { id: '7', name: 'Export.vue第360行:selectedType.value === "moyu"时调用handleExportAsApiflow方法' },
              { id: '8', name: 'Export.vue第48-79行:el-tree组件配置,show-checkbox启用复选框,node-key="_id"' },
              { id: '9', name: 'Export.vue第131-134行:handleCheckChange方法合并getCheckedNodes和getHalfCheckedNodes' },
              { id: '10', name: 'Export.vue第38-45行:统计信息显示,使用allCheckedNodes.length和filter统计不同类型节点' },
            ],
            notes: [
              { id: '1', name: 'Apiflow格式导出仅支持离线模式,在线模式使用/api/project/export/json接口' },
              { id: '2', name: '导出的JSON包含节点的完整结构:_id,pid,sort,info,item等字段' },
              { id: '3', name: 'docs数组包含所有选中的节点,包括folder和文档节点' },
              { id: '4', name: 'downloadStringAsText在helper模块中定义,创建Blob并触发a标签下载' },
              { id: '5', name: '选择导出功能通过SConfig组件实现,支持启用/禁用切换' },
              { id: '6', name: 'el-tree的半选中节点(文件夹部分子节点被选中)也会包含在导出中' },
            ],
          },
          {
            purpose: '导出openapi格式数据',
            precondition: [
              { id: '1', name: '已登录并打开任意项目工作区' },
              { id: '2', name: '项目中存在至少一个HTTP节点(OpenAPI导出仅支持HTTP类型)' },
              { id: '3', name: '应用运行在离线模式(runtimeStore.networkMode === "offline")' },
            ],
            operationSteps: [
              { id: '1', name: '点击项目工作区顶部导航栏中的"导出"按钮或菜单项' },
              { id: '2', name: '在导出弹窗中,点击选择"OpenAPI"类型(显示FileJson图标)' },
              { id: '3', name: '(可选)开启"选择导出"配置,勾选需要导出的HTTP节点' },
              { id: '4', name: '点击"确定导出"按钮' },
              { id: '5', name: '等待OpenAPIConverter转换完成,浏览器自动下载JSON文件' },
              { id: '6', name: '打开下载的JSON文件,验证符合OpenAPI 3.0规范' },
            ],
            expectedResults: [
              { id: '1', name: '导出弹窗正确显示OpenAPI类型选项,图标为FileJson(lucide-vue-next图标库)' },
              { id: '2', name: '选择OpenAPI后,对应的.item元素添加.active类名' },
              { id: '3', name: '点击导出后,触发handleExportAsOpenAPI方法' },
              { id: '4', name: '如果不是离线模式,显示警告提示:"OpenAPI导出仅支持离线模式"' },
              { id: '5', name: '从apiNodesCache获取所有项目节点,过滤出选中的HTTP节点(类型断言为HttpNode[])' },
              { id: '6', name: '创建OpenAPIConverter实例,调用convertToOpenAPI方法转换数据' },
              { id: '7', name: '生成的JSON文件符合OpenAPI 3.0规范,包含openapi,info,paths,components等字段' },
              { id: '8', name: '文件名格式:{项目名称}.openapi.json,contentType为application/json' },
              { id: '9', name: 'JSON格式化输出,使用JSON.stringify的第三个参数为2(两空格缩进)' },
              { id: '10', name: '使用downloadStringAsText方法触发浏览器下载' },
            ],
            checkpoints: [
              { id: '1', name: 'Export.vue第326-349行:handleExportAsOpenAPI方法实现' },
              { id: '2', name: 'Export.vue第21-24行:OpenAPI选项,selectedType === "openapi"时显示.active类' },
              { id: '3', name: 'Export.vue第327-330行:非离线模式时显示警告并return' },
              { id: '4', name: 'Export.vue第338行:类型断言as HttpNode[],因为OpenAPI仅支持HTTP节点' },
              { id: '5', name: 'Export.vue第339行:创建OpenAPIConverter实例' },
              { id: '6', name: 'Export.vue第340-343行:调用converter.convertToOpenAPI(projectName, selectedDocs)' },
              { id: '7', name: 'Export.vue第344-348行:downloadStringAsText导出,文件名包含.openapi后缀' },
              { id: '8', name: 'Export.vue第345行:JSON.stringify第二个参数为null,第三个参数为2(格式化输出)' },
              { id: '9', name: 'Export.vue第365-366行:selectedType === "openapi"时调用handleExportAsOpenAPI' },
              { id: '10', name: 'openapi-converter.ts:OpenAPIConverter类实现转换逻辑,遵循OpenAPI 3.0规范' },
              { id: '11', name: 'Export.vue第114行:import { OpenAPIConverter } from "./openapi-converter"' },
              { id: '12', name: 'Export.vue第22行:FileJson图标来自lucide-vue-next库,size=70, stroke-width=1.5' },
            ],
            notes: [
              { id: '1', name: 'OpenAPI导出仅支持离线模式,确保数据安全性和完整性' },
              { id: '2', name: 'OpenAPIConverter将Apiflow的HttpNode数据结构转换为OpenAPI 3.0规范格式' },
              { id: '3', name: 'OpenAPI规范包含:请求方法,路径,参数(query/path/header/body),响应结构等' },
              { id: '4', name: 'WebSocket节点不会被包含在OpenAPI导出中,需要过滤' },
              { id: '5', name: '导出的OpenAPI JSON可以被Swagger,Postman等工具导入使用' },
              { id: '6', name: 'convertToOpenAPI方法的第一个参数为projectName,用于生成OpenAPI的info.title字段' },
            ],
          },
          {
            purpose: '导出postman格式数据',
            precondition: [
              { id: '1', name: '已登录并打开任意项目工作区' },
              { id: '2', name: '项目中存在至少一个HTTP节点' },
              { id: '3', name: '应用运行在离线模式' },
            ],
            operationSteps: [
              { id: '1', name: '点击项目工作区顶部导航栏中的"导出"按钮' },
              { id: '2', name: '在导出弹窗中,点击选择"Postman"类型(如果已实现)' },
              { id: '3', name: '(可选)开启"选择导出"配置,勾选需要导出的节点' },
              { id: '4', name: '点击"确定导出"按钮' },
              { id: '5', name: '等待转换完成,浏览器自动下载JSON文件' },
              { id: '6', name: '使用Postman导入功能,导入下载的JSON文件验证兼容性' },
            ],
            expectedResults: [
              { id: '1', name: '导出弹窗显示Postman类型选项(当前版本未实现,需要添加)' },
              { id: '2', name: '点击导出后,触发handleExportAsPostman方法' },
              { id: '3', name: '从apiNodesCache获取所有项目节点,过滤出选中的HTTP节点' },
              { id: '4', name: '创建PostmanConverter实例(类似OpenAPIConverter),调用convertToPostman方法' },
              { id: '5', name: '生成的JSON文件符合Postman Collection v2.1规范' },
              { id: '6', name: '文件名格式:{项目名称}.postman_collection.json,contentType为application/json' },
              { id: '7', name: 'JSON包含info,item,variable等字段,符合Postman格式' },
              { id: '8', name: '使用downloadStringAsText方法触发浏览器下载' },
            ],
            checkpoints: [
              { id: '1', name: 'Export.vue需要添加Postman选项:selectedType类型联合添加"postman"' },
              { id: '2', name: 'Export.vue需要添加handleExportAsPostman方法(参考handleExportAsOpenAPI实现)' },
              { id: '3', name: '需要创建postman-converter.ts文件,实现PostmanConverter类' },
              { id: '4', name: 'PostmanConverter.convertToPostman方法将HttpNode转换为Postman Collection格式' },
              { id: '5', name: 'Postman Collection包含:info.name,info.schema,item数组等字段' },
              { id: '6', name: 'item数组中每个元素包含:name,request(method,url,header,body),response等' },
              { id: '7', name: 'handleExport方法的switch中添加postman分支调用handleExportAsPostman' },
              { id: '8', name: '导出功能仅支持离线模式,需要检查isStandalone.value' },
            ],
            notes: [
              { id: '1', name: 'Postman导出功能当前未实现,这是计划中的功能' },
              { id: '2', name: '实现方式可参考OpenAPI导出:创建转换器类,实现格式转换逻辑' },
              { id: '3', name: 'Postman Collection v2.1规范文档:https://schema.postman.com/collection/json/v2.1.0/draft-07/docs/index.html' },
              { id: '4', name: '需要将Apiflow的HttpNode.item数据映射到Postman的request格式' },
              { id: '5', name: 'Postman支持文件夹结构,需要处理folder节点转换为Postman的item.item嵌套结构' },
              { id: '6', name: '变量需要映射到Postman的variable数组,格式:{ key, value, type }' },
            ],
          },
        ],
      },
      {
        modelName: 'variable',
        description: '变量管理',
        atomicFunc: [
          {
            purpose: '新增所有类型变量,变量名不允许重复,可以删除变量',
            precondition: [
              { id: '1', name: '已登录并打开任意项目工作区' },
              { id: '2', name: '打开变量管理弹窗' },
            ],
            operationSteps: [
              { id: '1', name: '点击"新增变量"按钮' },
              { id: '2', name: '输入变量名"testString",选择类型"string",输入值"hello world",点击保存' },
              { id: '3', name: '再次点击"新增变量",输入变量名"testNumber",选择类型"number",输入值"123",点击保存' },
              { id: '4', name: '新增变量名"testBoolean",类型"boolean",值"true"' },
              { id: '5', name: '新增变量名"testFile",类型"file",选择一个文件上传' },
              { id: '6', name: '新增变量名"testAny",类型"any",输入JavaScript表达式"new Date().getTime()"' },
              { id: '7', name: '尝试新增重复变量名"testString",输入不同的值' },
              { id: '8', name: '选择某个已存在的变量,点击删除按钮' },
              { id: '9', name: '确认删除' },
            ],
            expectedResults: [
              { id: '1', name: '成功新增string类型变量,variables数组中增加一条记录' },
              { id: '2', name: '成功新增number类型变量,值被转换为数字类型' },
              { id: '3', name: '成功新增boolean类型变量,值为true或false' },
              { id: '4', name: '成功新增file类型变量,值为文件对象或文件路径' },
              { id: '5', name: '成功新增any类型变量,值为JavaScript表达式的执行结果' },
              { id: '6', name: '新增重复变量名时,显示错误提示:"变量名已存在"或类似提示' },
              { id: '7', name: '重复变量不允许保存,变量列表不变' },
              { id: '8', name: '删除变量后,该变量从variables数组中移除' },
              { id: '9', name: '变量列表UI立即更新,不再显示被删除的变量' },
              { id: '10', name: '所有变量操作会调用syncVariablesToMainProcess同步到主进程' },
            ],
            checkpoints: [
              { id: '1', name: 'variablesStore.ts:variables = ref<ApidocVariable[]>([])存储所有变量' },
              { id: '2', name: 'ApidocVariable接口包含字段:_id,name,type,value等' },
              { id: '3', name: 'variablesStore.changeVariableById方法用于修改变量' },
              { id: '4', name: 'variablesStore.replaceVariables方法用于替换所有变量' },
              { id: '5', name: 'syncVariablesToMainProcess方法调用window.electronAPI!.mock.syncProjectVariables同步到主进程' },
              { id: '6', name: 'getObjectVariable(variables.value)将变量数组转换为对象格式,方便在请求中使用' },
              { id: '7', name: 'objectVariable.value存储转换后的对象格式:{ 变量名: 变量值 }' },
              { id: '8', name: '变量名重复验证逻辑:遍历variables数组检查name字段是否已存在' },
              { id: '9', name: '删除变量使用数组的splice方法,传入索引和删除数量' },
              { id: '10', name: '每次变量变更后都要调用getObjectVariable更新objectVariable.value' },
            ],
            notes: [
              { id: '1', name: '变量类型包含:string,number,boolean,file,any五种类型' },
              { id: '2', name: 'any类型支持JavaScript表达式,可以编写动态计算逻辑' },
              { id: '3', name: 'file类型用于上传文件,在multipart/form-data请求中使用' },
              { id: '4', name: '变量同步到主进程后,可以在pre-request和post-request脚本中使用' },
              { id: '5', name: '变量管理通常在独立弹窗或侧边栏中展示,方便集中管理' },
              { id: '6', name: '变量数据会持久化到IndexedDB(离线模式)或服务器(在线模式)' },
            ],
          },
          {
            purpose: '模拟一个post发送body请求,调用echo接口,验证所有类型变量是否正确',
            precondition: [
              { id: '1', name: '已登录并打开任意项目工作区' },
              { id: '2', name: '已新增以下变量:testString(string:"test"),testNumber(number:100),testBool(boolean:true),testAny(any:计算表达式)' },
              { id: '3', name: '本地或远程有可访问的echo接口(返回请求参数的接口)' },
            ],
            operationSteps: [
              { id: '1', name: '新建一个HTTP POST请求节点' },
              { id: '2', name: '设置请求URL为:http://127.0.0.1:{端口}/echo' },
              { id: '3', name: '设置Content-Type为application/json' },
              { id: '4', name: '在Body的JSON编辑器中输入:{ "str": "{{testString}}", "num": {{testNumber}}, "bool": {{testBool}}, "any": {{testAny}} }' },
              { id: '5', name: '点击"发送请求"按钮' },
              { id: '6', name: '等待请求完成,查看响应结果' },
              { id: '7', name: '验证响应body中各字段的值是否为变量替换后的值' },
            ],
            expectedResults: [
              { id: '1', name: '发送请求前,变量解析器识别{{variableName}}模式的变量引用' },
              { id: '2', name: 'testString变量被替换为"test",在JSON中保持字符串格式(带引号)' },
              { id: '3', name: 'testNumber变量被替换为100,在JSON中为数字类型(不带引号)' },
              { id: '4', name: 'testBool变量被替换为true,在JSON中为布尔类型' },
              { id: '5', name: 'testAny变量被执行表达式,替换为计算结果值' },
              { id: '6', name: 'echo接口正确返回包含替换后值的响应,状态码200' },
              { id: '7', name: '响应body JSON结构:{ "str": "test", "num": 100, "bool": true, "any": <计算结果> }' },
              { id: '8', name: '变量替换过程在request.ts的变量解析模块中完成' },
            ],
            checkpoints: [
              { id: '1', name: '变量解析使用正则表达式匹配{{variableName}}模式' },
              { id: '2', name: 'objectVariable.value对象提供变量名到值的映射关系' },
              { id: '3', name: 'variablesStore.variables数组包含所有定义的变量' },
              { id: '4', name: 'getObjectVariable helper函数将变量数组转换为对象:{ name: value }' },
              { id: '5', name: '变量替换支持在URL,query参数,headers,body等所有请求部分使用' },
              { id: '6', name: 'string类型变量替换时保留引号,number和boolean类型去除引号' },
              { id: '7', name: 'any类型变量会执行JavaScript表达式,支持Date,Math等内置对象' },
              { id: '8', name: 'echo接口应返回原样的请求参数,验证变量替换的准确性' },
            ],
            notes: [
              { id: '1', name: 'echo接口通常由mock server提供,或使用第三方测试工具' },
              { id: '2', name: '变量替换在发送请求前执行,不影响原始配置数据' },
              { id: '3', name: '变量解析支持嵌套引用,如变量A的值包含{{变量B}}' },
              { id: '4', name: 'any类型变量的表达式在Web Worker中执行,提供af对象访问变量,cookies等' },
              { id: '5', name: '变量替换错误(如变量不存在)会在控制台输出警告信息' },
              { id: '6', name: '测试所有类型变量可以覆盖变量系统的核心功能' },
            ],
          },
        ],
      },
      {
        modelName: 'commonHeader',
        description: '公共请求头',
        children: [
          {
            modelName: '全局公共请求头',
            description: '全局公共请求头',
            atomicFunc: [
              {
                purpose: '为folder节点设置公共请求头,该folder下所有接口自动继承这些请求头',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '项目中存在至少一个folder节点' },
                  { id: '3', name: 'folder节点下存在至少一个HTTP请求节点' },
                ],
                operationSteps: [
                  { id: '1', name: '在项目导航树中,右键点击或选中一个folder节点' },
                  { id: '2', name: '点击节点的"公共请求头"按钮或菜单项,打开公共请求头配置页面' },
                  { id: '3', name: '在公共请求头页面,查看说明信息(针对目录生效,子目录优先级高于父目录,接口本身请求头优先级最高)' },
                  { id: '4', name: '在表格模式下,点击"添加"按钮新增一行' },
                  { id: '5', name: '输入请求头:key="Authorization",value="Bearer {{token}}",勾选启用' },
                  { id: '6', name: '再新增一行:key="Content-Type",value="application/json",勾选启用' },
                  { id: '7', name: '点击"确认修改"按钮保存公共请求头' },
                  { id: '8', name: '打开该folder下的一个HTTP请求节点' },
                  { id: '9', name: '查看Headers tab,验证公共请求头是否自动添加' },
                  { id: '10', name: '发送请求,验证请求中是否包含公共请求头' },
                ],
                expectedResults: [
                  { id: '1', name: '公共请求头配置页面正确打开,显示CommonHeader.vue组件' },
                  { id: '2', name: '说明区域显示3条规则:目录内生效,子目录优先级高,接口本身优先级最高' },
                  { id: '3', name: '表格模式下使用SParamsTree组件(edit-mode="table"),支持添加,编辑,删除行' },
                  { id: '4', name: '成功添加两个公共请求头,headerData数组包含两条记录' },
                  { id: '5', name: '点击"确认修改"后,调用handleEditCommonHeader方法' },
                  { id: '6', name: '离线模式:公共请求头保存到commonHeadersCache和commonHeaderStore' },
                  { id: '7', name: '在线模式:调用API /api/project/edit_common_header保存到服务器' },
                  { id: '8', name: '打开HTTP请求节点时,自动合并公共请求头到节点的headers中' },
                  { id: '9', name: '公共请求头在Headers tab中显示,但标记为来自folder(可能显示不同的颜色或图标)' },
                  { id: '10', name: '发送请求时,公共请求头被包含在实际的HTTP请求中' },
                  { id: '11', name: '如果接口本身有同名请求头,接口的值覆盖公共请求头的值' },
                ],
                checkpoints: [
                  { id: '1', name: 'CommonHeader.vue:公共请求头配置组件' },
                  { id: '2', name: 'CommonHeader.vue第3-7行:说明文字,包含3条优先级规则' },
                  { id: '3', name: 'CommonHeader.vue第26-32行:SParamsTree组件,edit-mode根据isMultiline切换table/multiline' },
                  { id: '4', name: 'CommonHeader.vue第64行:headerData = ref<ApidocProperty<"string" | "file">[]>([])' },
                  { id: '5', name: 'CommonHeader.vue第100-130行:getCommonHeaderInfo方法从缓存或API获取公共请求头' },
                  { id: '6', name: 'CommonHeader.vue第131-170行:handleEditCommonHeader方法保存公共请求头' },
                  { id: '7', name: 'commonHeaderStore.ts:Pinia store管理公共请求头状态' },
                  { id: '8', name: 'commonHeadersCache.ts:IndexedDB缓存层,存储folder的公共请求头' },
                  { id: '9', name: '公共请求头与folder节点的_id关联,存储结构:{ _id: folderId, commonHeaders: ApidocProperty[] }' },
                  { id: '10', name: '请求发送时,request.ts中的请求合并逻辑会自动合并公共请求头' },
                ],
                notes: [
                  { id: '1', name: '公共请求头仅针对folder节点有效,HTTP/WebSocket节点不支持设置公共请求头' },
                  { id: '2', name: '公共请求头支持变量替换,如{{token}}会在请求时被解析为实际变量值' },
                  { id: '3', name: '优先级规则:接口本身 > 子目录 > 父目录,这样可以实现继承和覆盖机制' },
                  { id: '4', name: '公共请求头的典型应用场景:统一设置Authorization,Content-Type等通用请求头' },
                  { id: '5', name: '公共请求头支持文件类型(file),但通常用于string类型' },
                ],
              },
              {
                purpose: '公共请求头支持表格模式和多行编辑模式切换,两种模式数据同步',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '已打开某个folder节点的公共请求头配置页面' },
                  { id: '3', name: '当前处于表格模式(isMultiline = false)' },
                  { id: '4', name: '已添加至少2个公共请求头' },
                ],
                operationSteps: [
                  { id: '1', name: '在表格模式下,验证公共请求头以表格形式展示(checkbox,key,value,description列)' },
                  { id: '2', name: '点击标题右侧的"多行编辑"切换按钮(Switch图标)' },
                  { id: '3', name: '观察页面切换到多行编辑模式' },
                  { id: '4', name: '在多行编辑器中编辑请求头文本,格式为:Authorization: Bearer token\\nContent-Type: application/json' },
                  { id: '5', name: '点击多行编辑器的"应用"按钮' },
                  { id: '6', name: '观察页面自动切换回表格模式' },
                  { id: '7', name: '验证表格中的数据已更新为多行编辑器中的内容' },
                  { id: '8', name: '再次点击切换按钮,切换到多行编辑模式,验证数据一致' },
                  { id: '9', name: '点击多行编辑器的"取消"按钮' },
                  { id: '10', name: '验证页面切换回表格模式,数据未被修改' },
                ],
                expectedResults: [
                  { id: '1', name: '表格模式下,SParamsTree组件的edit-mode prop为"table"' },
                  { id: '2', name: '点击切换按钮后,isMultiline.value切换为true' },
                  { id: '3', name: 'SParamsTree组件的edit-mode prop变为"multiline"' },
                  { id: '4', name: '多行编辑模式显示文本编辑器,支持手动输入key: value格式的请求头' },
                  { id: '5', name: '多行编辑器支持换行符\\n分隔多个请求头' },
                  { id: '6', name: '点击"应用"按钮后,触发handleMultilineApplied回调' },
                  { id: '7', name: 'handleMultilineApplied将isMultiline设置为false,自动切换回表格模式' },
                  { id: '8', name: '表格模式中的数据已同步更新为多行编辑器解析后的数据' },
                  { id: '9', name: '点击"取消"按钮后,触发handleMultilineCancelled回调' },
                  { id: '10', name: 'handleMultilineCancelled将isMultiline设置为false,数据不变' },
                  { id: '11', name: '切换按钮图标为Switch(Element Plus图标库)' },
                  { id: '12', name: '切换按钮在多行模式时显示.active类名' },
                ],
                checkpoints: [
                  { id: '1', name: 'CommonHeader.vue第81行:isMultiline = ref(false)控制编辑模式' },
                  { id: '2', name: 'CommonHeader.vue第83-85行:toggleMode方法切换isMultiline值' },
                  { id: '3', name: 'CommonHeader.vue第31行:edit-mode prop根据isMultiline动态计算:"table"或"multiline"' },
                  { id: '4', name: 'CommonHeader.vue第86-91行:handleMultilineApplied和handleMultilineCancelled回调' },
                  { id: '5', name: 'CommonHeader.vue第92-97行:watch监听paramsTreeRef,注册回调函数' },
                  { id: '6', name: 'CommonHeader.vue第12-24行:切换按钮,绑定@click="toggleMode"' },
                  { id: '7', name: 'CommonHeader.vue第17行::class="{ active: isMultiline }"控制按钮高亮' },
                  { id: '8', name: 'CommonHeader.vue第16行:title属性根据isMultiline显示"返回表格"或"多行编辑"' },
                  { id: '9', name: 'SParamsTree组件支持table和multiline两种编辑模式' },
                  { id: '10', name: '多行编辑模式解析逻辑:按行分割,每行按冒号分割key和value' },
                ],
                notes: [
                  { id: '1', name: '多行编辑模式适合批量复制粘贴请求头,提高效率' },
                  { id: '2', name: '表格模式适合精细编辑单个请求头,支持checkbox,description等字段' },
                  { id: '3', name: '两种模式的数据通过headerData ref保持同步' },
                  { id: '4', name: 'SParamsTree组件内部处理模式切换和数据转换逻辑' },
                  { id: '5', name: '多行编辑模式的格式:每行一个请求头,格式为"key: value"' },
                  { id: '6', name: '切换按钮的tooltip提示当前操作:"返回表格"表示当前在多行模式,点击回到表格' },
                ],
              },
            ],
          },
        ],
      },
      {
        modelName: 'trash',
        description: '接口回收站',
        children: [],
      },
      {
        modelName: 'cookieManagement',
        description: 'cookie管理',
        children: [],
      },
    ],
  },
  //项目工作区
  {
    modelName: 'projectWorkbench',
    description: '项目工作区',
    children: [
      // banner区域
      {
        modelName: 'banner',
        description: '项目工作区banner导航',
        children: [
          {
            modelName: 'search',
            description: '搜索',
            atomicFunc: [
              {
                purpose: '搜索框默认UI样式验证,placeholder内容,筛选图标,focus后边框高亮,输入内容后出现清空按钮',
                precondition: [
                  { id: '1', name: '已打开任意项目工作区,进入项目编辑页面' },
                  { id: '2', name: 'Tool.vue组件已渲染在banner区域' },
                  { id: '3', name: '当前处于在线模式(runtimeStore.networkMode !== "offline")' },
                ],
                operationSteps: [
                  { id: '1', name: '观察Tool.vue第33-35行的el-input搜索框,验证初始渲染状态' },
                  { id: '2', name: '检查搜索框placeholder文字显示' },
                  { id: '3', name: '检查搜索框右侧是否显示高级筛选按钮(data-testid="banner-filter-btn")' },
                  { id: '4', name: '点击搜索框,触发focus事件' },
                  { id: '5', name: '观察搜索框边框样式变化' },
                  { id: '6', name: '在搜索框中输入任意文字(如"test")' },
                  { id: '7', name: '观察搜索框右侧是否出现清空按钮(el-input的clearable属性)' },
                  { id: '8', name: '点击清空按钮' },
                  { id: '9', name: '验证搜索框内容被清空' },
                ],
                expectedResults: [
                  { id: '1', name: 'Tool.vue第34行el-input正确渲染,size="large",class="doc-search"' },
                  { id: '2', name: 'placeholder显示为t("文档名称,文档url"),中文环境下显示"文档名称,文档url"' },
                  { id: '3', name: '搜索框右侧显示高级筛选图标(icongaojishaixuan),带有el-badge红点提示(当有筛选条件时)' },
                  { id: '4', name: 'data-testid="banner-search-input"属性正确设置,便于自动化测试定位' },
                  { id: '5', name: 'focus后搜索框边框显示主题色高亮(Element Plus默认focus样式)' },
                  { id: '6', name: '输入内容后,搜索框右侧出现清空图标(叉号)' },
                  { id: '7', name: '点击清空按钮后,formInfo.iptValue被清空为空字符串' },
                  { id: '8', name: '清空后触发@change事件,调用handleFilterBanner方法' },
                  { id: '9', name: 'handleFilterBanner方法emit("filter", formInfo),通知Banner.vue更新过滤状态' },
                ],
                checkpoints: [
                  { id: '1', name: 'Tool.vue第34行:el-input配置 - v-model="formInfo.iptValue", size="large", clearable' },
                  { id: '2', name: 'Tool.vue第34行:placeholder使用i18n - :placeholder="t(\'文档名称,文档url\')"' },
                  { id: '3', name: 'Tool.vue第36行:高级筛选条件判断 - v-if="!isStandalone"' },
                  { id: '4', name: 'Tool.vue第36行:el-badge红点显示 - :is-dot="hasFilterCondition"' },
                  { id: '5', name: 'Tool.vue第39行:高级筛选按钮 - data-testid="banner-filter-btn"' },
                  { id: '6', name: 'Tool.vue中formInfo响应式对象包含iptValue字段' },
                  { id: '7', name: 'el-input的clearable属性自动添加清空按钮功能' },
                  { id: '8', name: '@change事件绑定handleFilterBanner方法' },
                ],
                notes: [
                  { id: '1', name: 'el-input的size="large"使搜索框高度更大,便于用户操作' },
                  { id: '2', name: 'clearable属性是Element Plus内置功能,当输入内容时自动显示清空按钮' },
                  { id: '3', name: 'placeholder使用i18n国际化,支持中英文切换' },
                  { id: '4', name: '高级筛选按钮仅在在线模式显示,离线模式隐藏该功能' },
                  { id: '5', name: 'data-testid属性便于Playwright等E2E测试工具定位元素' },
                ],
              },
              {
                purpose: '搜索框默认UI样式验证,placeholder内容,筛选图标,focus后边框高亮',
                precondition: [
                  { id: '1', name: '已打开任意项目工作区,进入项目编辑页面' },
                  { id: '2', name: 'Tool.vue组件已渲染' },
                  { id: '3', name: '搜索框未输入任何内容(formInfo.iptValue为空字符串)' },
                ],
                operationSteps: [
                  { id: '1', name: '直接观察搜索框UI渲染状态,无需任何操作' },
                  { id: '2', name: '验证placeholder文字内容' },
                  { id: '3', name: '验证搜索框尺寸和样式' },
                  { id: '4', name: '点击搜索框激活focus状态' },
                  { id: '5', name: '观察边框颜色变化' },
                  { id: '6', name: '点击页面其他区域,使搜索框失去焦点' },
                  { id: '7', name: '观察边框恢复到默认状态' },
                ],
                expectedResults: [
                  { id: '1', name: '搜索框正确显示在banner区域顶部,位于项目名称和切换按钮下方' },
                  { id: '2', name: 'placeholder显示灰色文字提示:"文档名称,文档url"' },
                  { id: '3', name: '搜索框使用Element Plus的large尺寸,高度约40px' },
                  { id: '4', name: '搜索框宽度自适应父容器,class="doc-search"应用自定义样式' },
                  { id: '5', name: 'focus状态下边框显示主题色(通常为蓝色)高亮' },
                  { id: '6', name: '失去焦点后边框恢复为默认的灰色边框' },
                  { id: '7', name: '搜索框右侧始终显示高级筛选图标(在线模式下)' },
                ],
                checkpoints: [
                  { id: '1', name: 'Tool.vue第34行el-input渲染正确' },
                  { id: '2', name: 'placeholder文字使用i18n翻译' },
                  { id: '3', name: 'Element Plus el-input组件的focus伪类样式自动应用' },
                  { id: '4', name: 'CSS类名doc-search可能在Tool.vue的style标签中定义额外样式' },
                  { id: '5', name: '搜索框父容器使用p-relative(position: relative)定位' },
                ],
                notes: [
                  { id: '1', name: '此用例与用例1部分重复,主要验证默认状态的UI展示' },
                  { id: '2', name: '用例1侧重clearable功能,此用例侧重基础UI验证' },
                  { id: '3', name: 'focus高亮效果由Element Plus框架提供,无需额外代码' },
                ],
              },
              {
                purpose: '搜索框输入内容后,可以匹配接口的url和名称,需要验证搜索算法对不对',
                precondition: [
                  { id: '1', name: '已打开项目工作区,项目中存在多个API节点' },
                  { id: '2', name: '测试数据包含:名称为"用户登录"的HTTP节点(url: /api/user/login)' },
                  { id: '3', name: '测试数据包含:名称为"获取订单列表"的HTTP节点(url: /api/order/list)' },
                  { id: '4', name: '测试数据包含:名称为"WebSocket连接"的WebSocket节点(url.path: /ws/chat)' },
                  { id: '5', name: '测试数据包含:名称为"用户模块"的folder节点(不含url)' },
                ],
                operationSteps: [
                  { id: '1', name: '在搜索框中输入"login"' },
                  { id: '2', name: '观察节点树过滤结果,验证是否显示"用户登录"节点' },
                  { id: '3', name: '清空搜索框,输入"用户"' },
                  { id: '4', name: '观察节点树是否同时显示"用户登录"节点和"用户模块"文件夹' },
                  { id: '5', name: '清空搜索框,输入"order"' },
                  { id: '6', name: '验证是否显示"获取订单列表"节点(URL匹配)' },
                  { id: '7', name: '清空搜索框,输入"ws"' },
                  { id: '8', name: '验证WebSocket节点的URL path匹配逻辑' },
                  { id: '9', name: '清空搜索框,输入不存在的内容"xyz123"' },
                  { id: '10', name: '验证无匹配结果时的显示状态' },
                ],
                expectedResults: [
                  { id: '1', name: '输入"login"后,仅显示URL包含"login"的节点(/api/user/login)' },
                  { id: '2', name: '输入"用户"后,显示名称包含"用户"的所有节点("用户登录"节点和"用户模块"文件夹)' },
                  { id: '3', name: '输入"order"后,显示URL包含"order"的节点(/api/order/list)' },
                  { id: '4', name: '搜索算法使用JavaScript的match方法进行匹配,支持正则表达式模式' },
                  { id: '5', name: 'HTTP节点匹配逻辑:bannerData.url?.match(filterInfo.iptValue)' },
                  { id: '6', name: 'WebSocket节点匹配逻辑:bannerData.url.path?.match(filterInfo.iptValue)' },
                  { id: '7', name: '名称匹配逻辑:bannerData.name.match(filterInfo.iptValue)' },
                  { id: '8', name: '匹配成功的节点显示,不匹配的节点被过滤隐藏' },
                  { id: '9', name: 'folder类型节点仅通过name匹配(type !== "http" && type !== "websocket"时返回false)' },
                ],
                checkpoints: [
                  { id: '1', name: 'Banner.vue第640行:filterNode方法实现过滤逻辑' },
                  { id: '2', name: 'Banner.vue第650-656行:URL匹配条件判断 - 区分http和websocket类型' },
                  { id: '3', name: 'Banner.vue第651-652行:HTTP节点URL匹配 - bannerData.url?.match(filterInfo.iptValue)' },
                  { id: '4', name: 'Banner.vue第653-654行:WebSocket节点URL匹配 - bannerData.url.path?.match(filterInfo.iptValue)' },
                  { id: '5', name: 'Banner.vue第657行:名称匹配 - bannerData.name.match(filterInfo.iptValue)' },
                  { id: '6', name: 'Banner.vue第660行:返回匹配结果 - (!!matchedUrl || !!matchedDocName) || !!matchedOthers' },
                  { id: '7', name: 'Tool.vue中handleFilterBanner方法触发emit("filter", formInfo)' },
                  { id: '8', name: 'Banner.vue第633行:handleFilterNode方法调用docTree.filter(filterInfo)' },
                  { id: '9', name: 'el-tree的filter方法接收filterNode作为filter-node-method' },
                ],
                notes: [
                  { id: '1', name: '搜索算法使用JavaScript原生match方法,支持字符串直接匹配' },
                  { id: '2', name: 'match方法区分大小写,如需不区分可以转换为小写后匹配' },
                  { id: '3', name: 'HTTP节点和WebSocket节点的URL结构不同,需分别处理' },
                  { id: '4', name: 'HTTP节点:url是字符串(如"/api/user/login")' },
                  { id: '5', name: 'WebSocket节点:url是对象,包含path字段(如{path: "/ws/chat"})' },
                  { id: '6', name: 'folder类型节点没有url字段,仅通过name匹配' },
                  { id: '7', name: '匹配逻辑使用逻辑或运算符,只要name或url任一匹配即显示' },
                ],
              },
              {
                purpose: '搜索框输入内容后,若无搜索结果,需要正确展示无搜索结果提示',
                precondition: [
                  { id: '1', name: '已打开项目工作区,项目中存在若干API节点' },
                  { id: '2', name: 'Banner.vue组件已正确渲染节点树' },
                ],
                operationSteps: [
                  { id: '1', name: '在搜索框中输入一个不存在于任何节点名称和URL的字符串(如"xyzabc123")' },
                  { id: '2', name: '观察el-tree节点树的显示状态' },
                  { id: '3', name: '检查是否有任何节点显示' },
                  { id: '4', name: '观察是否显示"无搜索结果"或空状态提示' },
                ],
                expectedResults: [
                  { id: '1', name: 'filterNode方法对所有节点返回false,el-tree不显示任何节点' },
                  { id: '2', name: 'el-tree组件显示空状态(Element Plus默认空状态或自定义empty slot)' },
                  { id: '3', name: 'Banner.vue中如果定义了el-tree的empty slot,显示自定义空状态提示' },
                  { id: '4', name: '节点树区域显示为空白或显示"暂无数据"提示' },
                  { id: '5', name: '清空搜索框后,所有节点恢复显示' },
                ],
                checkpoints: [
                  { id: '1', name: 'Banner.vue第640-661行:filterNode方法返回false时节点被过滤' },
                  { id: '2', name: 'el-tree的empty slot可以自定义无数据提示' },
                  { id: '3', name: 'Banner.vue中el-tree可能包含empty模板插槽' },
                  { id: '4', name: '无匹配结果时,docTree中所有节点的visible属性为false' },
                ],
                notes: [
                  { id: '1', name: 'Element Plus el-tree组件在所有节点被过滤后显示空状态' },
                  { id: '2', name: '可以通过el-tree的empty slot自定义无数据提示内容' },
                  { id: '3', name: '建议在Banner.vue中添加友好的空状态提示,如"未找到匹配的接口"' },
                ],
              },
              {
                purpose: '搜索框输入内容后,如果存在节点名称匹配,需要在节点名称中高亮关键字,如果存在节点url匹配,需要在url中高亮关键字,匹配中的节点如果存在父元素,则递归展示所有父元素',
                precondition: [
                  { id: '1', name: '已打开项目工作区,存在嵌套的节点结构' },
                  { id: '2', name: '测试数据:根目录下有"用户模块"文件夹,文件夹内有"用户登录"HTTP节点' },
                  { id: '3', name: '"用户登录"节点的URL为/api/user/login' },
                  { id: '4', name: 'Banner.vue中SEmphasize组件已正确引入和使用' },
                ],
                operationSteps: [
                  { id: '1', name: '在搜索框中输入"登录"' },
                  { id: '2', name: '观察"用户登录"节点的显示' },
                  { id: '3', name: '检查"用户登录"文字中"登录"是否高亮显示' },
                  { id: '4', name: '检查父级"用户模块"文件夹是否自动展开并显示' },
                  { id: '5', name: '清空搜索框,输入"login"' },
                  { id: '6', name: '观察节点URL /api/user/login 中"login"是否高亮' },
                  { id: '7', name: '验证父级文件夹是否依然显示' },
                ],
                expectedResults: [
                  { id: '1', name: '输入"登录"后,"用户登录"节点显示,节点名称中"登录"二字高亮显示(不同颜色或背景色)' },
                  { id: '2', name: '父级"用户模块"文件夹自动展开,显示在节点树中' },
                  { id: '3', name: 'SEmphasize组件处理高亮逻辑,接收value(完整文本)和keyword(关键字)props' },
                  { id: '4', name: 'Banner.vue第42行使用SEmphasize高亮节点名称:<SEmphasize :value="scope.data.name" :keyword="filterString">' },
                  { id: '5', name: 'Banner.vue第45行使用SEmphasize高亮URL:<SEmphasize :value="scope.data.url" :keyword="filterString">' },
                  { id: '6', name: '输入"login"后,URL中"login"部分高亮显示' },
                  { id: '7', name: 'filterString.value在handleFilterNode方法中被设置为输入的关键字' },
                  { id: '8', name: '匹配的节点及其所有祖先节点都显示在树中' },
                  { id: '9', name: 'showMoreNodeInfo.value被设置为true,显示更多节点信息' },
                ],
                checkpoints: [
                  { id: '1', name: 'Banner.vue第631行:filterString响应式变量存储搜索关键字' },
                  { id: '2', name: 'Banner.vue第637行:filterString.value = filterInfo.iptValue 赋值' },
                  { id: '3', name: 'Banner.vue第42行:SEmphasize组件高亮节点名称' },
                  { id: '4', name: 'Banner.vue第45,74,124,145,171行:多处使用SEmphasize高亮URL' },
                  { id: '5', name: 'SEmphasize组件props包含:value(完整文本),keyword(搜索关键字),title(tooltip)' },
                  { id: '6', name: 'Banner.vue第659行:showMoreNodeInfo.value = true 显示更多信息' },
                  { id: '7', name: 'el-tree的filter方法自动处理父节点展开逻辑' },
                  { id: '8', name: 'Element Plus el-tree在过滤时自动显示匹配节点的所有祖先节点' },
                ],
                notes: [
                  { id: '1', name: 'SEmphasize是自定义组件,用于高亮显示文本中的关键字' },
                  { id: '2', name: 'SEmphasize组件可能使用正则替换或字符串分割方式实现高亮' },
                  { id: '3', name: 'el-tree的filter方法会自动展开包含匹配节点的父节点' },
                  { id: '4', name: '父节点展开逻辑由Element Plus内部处理,无需手动实现' },
                  { id: '5', name: 'filterString用于在模板中传递给SEmphasize组件' },
                  { id: '6', name: 'showMoreNodeInfo控制是否显示节点的URL等额外信息' },
                ],
              },
              {
                purpose: '离线模式不展示高级筛选',
                precondition: [
                  { id: '1', name: '应用运行在离线模式(runtimeStore.networkMode === "offline")' },
                  { id: '2', name: 'Tool.vue组件已渲染' },
                  { id: '3', name: 'isStandalone计算属性返回true' },
                ],
                operationSteps: [
                  { id: '1', name: '切换应用到离线模式(standalone模式)' },
                  { id: '2', name: '观察搜索框右侧区域' },
                  { id: '3', name: '检查是否显示高级筛选按钮(带有筛选图标的按钮)' },
                  { id: '4', name: '尝试查找data-testid="banner-filter-btn"元素' },
                  { id: '5', name: '切换到在线模式' },
                  { id: '6', name: '再次观察搜索框右侧是否出现高级筛选按钮' },
                ],
                expectedResults: [
                  { id: '1', name: '离线模式下,Tool.vue第36行的v-if="!isStandalone"条件判断为false' },
                  { id: '2', name: 'el-badge和el-popover组件(高级筛选功能)不渲染' },
                  { id: '3', name: '搜索框右侧仅显示el-input的clearable清空按钮,无筛选图标' },
                  { id: '4', name: 'data-testid="banner-filter-btn"元素在DOM中不存在' },
                  { id: '5', name: '切换到在线模式后,高级筛选按钮出现' },
                  { id: '6', name: '在线模式下可以点击筛选按钮,弹出筛选面板' },
                ],
                checkpoints: [
                  { id: '1', name: 'Tool.vue第36行:v-if="!isStandalone"条件渲染高级筛选功能' },
                  { id: '2', name: 'Tool.vue中isStandalone计算属性定义:computed(() => runtimeStore.networkMode === "offline")' },
                  { id: '3', name: 'runtimeStore.networkMode值为"offline"时isStandalone为true' },
                  { id: '4', name: '离线模式隐藏的功能包含:el-badge,el-popover,筛选按钮,筛选面板' },
                  { id: '5', name: '筛选面板包含:操作人员,录入日期,最近多少条等筛选条件(第43-86行)' },
                ],
                notes: [
                  { id: '1', name: '离线模式(standalone)是Apiflow的本地纯IndexedDB模式,无后端服务器' },
                  { id: '2', name: '高级筛选功能依赖服务器端数据(操作人员,录入日期等),离线模式不可用' },
                  { id: '3', name: '基础搜索功能(按名称和URL搜索)在离线模式下依然可用' },
                  { id: '4', name: 'isStandalone计算属性统一控制离线/在线模式的功能差异' },
                  { id: '5', name: '通过v-if条件渲染,离线模式下筛选相关DOM完全不渲染,提升性能' },
                ],
              },
            ],
          },
          {
            modelName: 'projectToggle',
            description: '项目切换',
            atomicFunc: [
              {
                purpose: '点击切换项目图标,弹出项目切换面板,点击项目名称可以切换项目,切换项目后顶部header区域需要添加一个切换项目的tab',
                precondition: [
                  { id: '1', name: '应用已登录,当前用户至少有2个可访问的项目' },
                  { id: '2', name: '已打开项目A的工作区页面' },
                  { id: '3', name: 'Tool.vue组件已渲染在banner区域' },
                  { id: '4', name: 'projectList响应式数组包含用户的所有项目列表' },
                  { id: '5', name: 'startProjectList包含用户收藏的项目(如果有)' },
                ],
                operationSteps: [
                  { id: '1', name: '观察Tool.vue第4-5行显示的当前项目名称' },
                  { id: '2', name: '点击Tool.vue第9行的切换项目按钮(Switch图标,data-testid="banner-toggle-project-btn")' },
                  { id: '3', name: '观察el-popover弹出层是否显示' },
                  { id: '4', name: '检查弹出层中是否显示"收藏的项目"标题(如果startProjectList.length > 0)' },
                  { id: '5', name: '检查收藏项目列表的显示(每个项目显示projectName和owner.name)' },
                  { id: '6', name: '检查"项目列表"标题下的所有项目显示' },
                  { id: '7', name: '点击项目列表中的项目B(不同于当前项目A)' },
                  { id: '8', name: '等待页面响应,观察是否触发handleChangeProject方法' },
                  { id: '9', name: '验证Tool.vue emit("changeProject", item)事件是否被触发' },
                  { id: '10', name: '检查header区域顶部tabsStore是否新增了项目B的tab' },
                  { id: '11', name: '验证页面是否跳转到项目B的工作区' },
                ],
                expectedResults: [
                  { id: '1', name: 'Tool.vue第4行h2元素显示当前项目名称projectName,title属性用于完整显示' },
                  { id: '2', name: '点击切换按钮后,toggleProjectVisible响应式变量变为true' },
                  { id: '3', name: 'Tool.vue第6-31行el-popover弹出层正确显示,placement="right",width="500px"' },
                  { id: '4', name: '弹出层包含SLoading组件,显示加载状态(:loading="projectLoading")' },
                  { id: '5', name: '如果startProjectList.length > 0,显示第16行h3标题:"收藏的项目"' },
                  { id: '6', name: '收藏项目列表区域(第17-22行)显示每个收藏项目的名称和创建者' },
                  { id: '7', name: '第23行h3标题"项目列表"始终显示' },
                  { id: '8', name: '项目列表区域(第24-29行)显示所有可访问项目' },
                  { id: '9', name: '每个项目item包含:item-title(项目名)和item-content(创建者名,灰色文字)' },
                  { id: '10', name: '点击项目B后,触发第25行@click="handleChangeProject(item)"' },
                  { id: '11', name: 'handleChangeProject方法调用emit("changeProject", item)' },
                  { id: '12', name: 'Banner.vue接收changeProject事件,调用handleChangeProject方法' },
                  { id: '13', name: 'projectNavStore.addProjectNav方法创建新的项目tab' },
                  { id: '14', name: 'header区域顶部tabs新增一个项目B的tab,可以切换回项目A' },
                  { id: '15', name: 'router跳转到项目B的工作区页面(路由参数id更新为项目B的ID)' },
                ],
                checkpoints: [
                  { id: '1', name: 'Tool.vue第4行:当前项目名称显示 - <h2 :title="projectName">{{ projectName }}</h2>' },
                  { id: '2', name: 'Tool.vue第6行:el-popover配置 - :visible="toggleProjectVisible", placement="right", width="500px"' },
                  { id: '3', name: 'Tool.vue第9行:切换按钮 - data-testid="banner-toggle-project-btn", @click.stop="handleToggleProjectModel"' },
                  { id: '4', name: 'Tool.vue第15行:SLoading包裹项目列表,显示加载状态' },
                  { id: '5', name: 'Tool.vue第16行:收藏项目标题条件渲染 - v-if="startProjectList.length > 0"' },
                  { id: '6', name: 'Tool.vue第18行:收藏项目列表 - v-for="(item, index) in startProjectList"' },
                  { id: '7', name: 'Tool.vue第19行:项目名称显示 - {{ item.projectName }}' },
                  { id: '8', name: 'Tool.vue第20行:创建者名称显示 - {{ item.owner.name }}(灰色文字)' },
                  { id: '9', name: 'Tool.vue第25行:项目列表 - v-for="(item, index) in projectList",@click="handleChangeProject(item)"' },
                  { id: '10', name: 'Tool.vue中handleChangeProject方法emit("changeProject", item)事件' },
                  { id: '11', name: 'Banner.vue接收@changeProject事件,调用handleChangeProject处理项目切换' },
                  { id: '12', name: 'projectNavStore.addProjectNav方法用于添加新的项目tab' },
                  { id: '13', name: 'router.push方法跳转到新项目的工作区页面' },
                ],
                notes: [
                  { id: '1', name: 'el-popover的transition="none"禁用过渡动画,提升响应速度' },
                  { id: '2', name: '@click.stop阻止事件冒泡,避免触发其他点击事件' },
                  { id: '3', name: 'startProjectList是收藏项目列表,通过用户收藏操作添加' },
                  { id: '4', name: 'projectList是用户所有可访问的项目,包含个人项目和共享项目' },
                  { id: '5', name: '项目切换后创建新tab而不是替换当前tab,方便用户在多个项目间快速切换' },
                  { id: '6', name: 'toggleProjectVisible控制弹出层显示隐藏,点击外部区域自动关闭' },
                  { id: '7', name: 'projectLoading控制加载状态,从服务器获取项目列表时显示加载动画' },
                ],
              },
            ],
          },
          {
            modelName: 'tools',
            description: '工具栏',
            atomicFunc: [
              {
                purpose: '工具栏默认按顺序展示:新增目录,新增httpNode,刷新,折叠全部,回收站,导入文档,变量图标,更多操作',
                precondition: [
                  { id: '1', name: '首次打开项目工作区,localStorage中无工具栏配置缓存' },
                  { id: '2', name: 'Tool.vue组件已渲染' },
                  { id: '3', name: 'operations.ts中originOperaions定义了所有默认工具' },
                ],
                operationSteps: [
                  { id: '1', name: '打开项目工作区页面' },
                  { id: '2', name: '观察Tool.vue第91-110行的工具栏区域渲染' },
                  { id: '3', name: '从左到右依次检查工具栏图标的显示顺序' },
                  { id: '4', name: '验证每个图标的tooltip提示文字' },
                  { id: '5', name: '检查工具栏最右侧是否显示"更多操作"按钮(MoreFilled图标)' },
                ],
                expectedResults: [
                  { id: '1', name: 'Tool.vue第232-258行initCacheOperation方法初始化工具栏' },
                  { id: '2', name: '无缓存时,使用operations.ts中originOperaions的默认配置' },
                  { id: '3', name: '第257行:pinOperations.value = availableOperations.filter((v) => v.pin),筛选pin为true的工具' },
                  { id: '4', name: '默认固定工具(pin: true)按operations.ts顺序显示:新增文件夹,新增文件,刷新banner,Cookie管理,回收站' },
                  { id: '5', name: 'operations.ts第3-7行:新增文件夹(#iconxinzengwenjian)' },
                  { id: '6', name: 'operations.ts第10-14行:新增文件(#iconwenjian)' },
                  { id: '7', name: 'operations.ts第17-22行:刷新banner(#iconshuaxin)' },
                  { id: '8', name: 'operations.ts第25-29行:Cookie管理(#iconCookies)' },
                  { id: '9', name: 'operations.ts第32-36行:回收站(#iconhuishouzhan)' },
                  { id: '10', name: '未固定工具(pin: false)不显示在工具栏:项目分享,导出文档,导入文档,全局变量' },
                  { id: '11', name: 'Tool.vue第114行:更多操作按钮显示在工具栏最右侧(data-testid="banner-tool-more-btn")' },
                ],
                checkpoints: [
                  { id: '1', name: 'operations.ts第1行:originOperaions数组定义所有工具' },
                  { id: '2', name: 'Tool.vue第93行:SDraggable组件v-model="pinOperations"渲染固定工具' },
                  { id: '3', name: 'Tool.vue第224-225行:operations和pinOperations响应式数组' },
                  { id: '4', name: 'Tool.vue第232行:initCacheOperation方法初始化工具配置' },
                  { id: '5', name: 'Tool.vue第233行:getProjectWorkbenchPinToolbarOperations从localStorage读取缓存' },
                  { id: '6', name: 'Tool.vue第257行:无缓存时使用默认pin值筛选' },
                  { id: '7', name: '每个工具的pin属性控制是否默认固定' },
                ],
                notes: [
                  { id: '1', name: '工具栏配置使用localStorage持久化,key为projectWorkbench/pinToolbarOperations' },
                  { id: '2', name: 'operations.ts中pin: true的工具默认显示在工具栏' },
                  { id: '3', name: 'SDraggable组件提供拖拽功能,item-key="name"标识每个工具' },
                  { id: '4', name: 'operations.ts中的viewOnly: true表示该工具不可在离线模式使用' },
                  { id: '5', name: 'icon字段支持两种格式:svg sprite(以#开头)和lucide-vue-next图标名称' },
                ],
              },
              {
                purpose: '工具栏图标可以自由拖拽交换顺序,刷新页面后顺序保持不变',
                precondition: [
                  { id: '1', name: '已打开项目工作区,工具栏显示默认工具' },
                  { id: '2', name: 'pinOperations数组包含多个固定工具' },
                  { id: '3', name: 'SDraggable组件已正确渲染' },
                ],
                operationSteps: [
                  { id: '1', name: '鼠标按住工具栏中的"新增文件夹"图标' },
                  { id: '2', name: '拖拽该图标到"回收站"图标右侧' },
                  { id: '3', name: '松开鼠标,观察图标位置变化' },
                  { id: '4', name: '验证pinOperations数组顺序是否更新' },
                  { id: '5', name: '检查localStorage中是否保存了新顺序' },
                  { id: '6', name: '按F5刷新页面' },
                  { id: '7', name: '等待页面重新加载' },
                  { id: '8', name: '观察工具栏图标顺序是否与拖拽后一致' },
                ],
                expectedResults: [
                  { id: '1', name: 'SDraggable组件支持拖拽排序,animation="150"提供150ms过渡动画' },
                  { id: '2', name: '拖拽过程中显示拖拽预览效果' },
                  { id: '3', name: '松开鼠标后,pinOperations数组顺序自动更新' },
                  { id: '4', name: 'Tool.vue第260-264行watch监听pinOperations变化' },
                  { id: '5', name: '第261行:projectWorkbenchCache.setProjectWorkbenchPinToolbarOperations(v)保存到localStorage' },
                  { id: '6', name: 'deep: true深度监听,数组元素顺序变化也会触发保存' },
                  { id: '7', name: '刷新页面后,initCacheOperation方法从localStorage读取缓存配置' },
                  { id: '8', name: 'Tool.vue第241-254行:localPinToolbarOperations.length > 0时使用缓存顺序' },
                  { id: '9', name: '工具栏图标顺序与拖拽后保持一致' },
                ],
                checkpoints: [
                  { id: '1', name: 'Tool.vue第93行:SDraggable组件 - v-model="pinOperations", animation="150", group="operation"' },
                  { id: '2', name: 'Tool.vue第260行:watch(pinOperations, ...)监听数组变化' },
                  { id: '3', name: 'Tool.vue第261行:setProjectWorkbenchPinToolbarOperations保存配置' },
                  { id: '4', name: 'Tool.vue第233行:getProjectWorkbenchPinToolbarOperations读取缓存' },
                  { id: '5', name: 'SDraggable的v-model双向绑定,拖拽自动更新数组顺序' },
                  { id: '6', name: 'localStorage key: projectWorkbench/pinToolbarOperations' },
                ],
                notes: [
                  { id: '1', name: 'vuedraggable库基于Sortable.js,提供Vue组件封装' },
                  { id: '2', name: 'animation属性控制拖拽动画时长,单位毫秒' },
                  { id: '3', name: 'group属性用于多个draggable组件间拖拽,相同group可互相拖拽' },
                  { id: '4', name: 'watch deep选项监听数组内部变化,包括顺序调整' },
                  { id: '5', name: '拖拽排序是用户自定义工具栏的核心功能' },
                ],
              },
              {
                purpose: '点击更多操作按钮展示更多操作,显示完整的工具列表,工具列表可以自由拖拽交换顺序,刷新页面后顺序保持不变',
                precondition: [
                  { id: '1', name: '已打开项目工作区' },
                  { id: '2', name: 'Tool.vue第114行更多操作按钮已渲染' },
                  { id: '3', name: 'operations数组包含所有工具(包括未固定的)' },
                ],
                operationSteps: [
                  { id: '1', name: '点击工具栏最右侧的"更多操作"按钮(MoreFilled图标,data-testid="banner-tool-more-btn")' },
                  { id: '2', name: '观察el-popover弹出层是否显示' },
                  { id: '3', name: '检查弹出层顶部标题是否显示"快捷操作"' },
                  { id: '4', name: '检查弹出层右上角是否显示关闭按钮(Close图标)' },
                  { id: '5', name: '观察弹出层中显示的工具列表' },
                  { id: '6', name: '验证每个工具是否显示:图标,名称,快捷键,固定按钮' },
                  { id: '7', name: '拖拽"导入文档"工具到"导出文档"上方' },
                  { id: '8', name: '观察工具顺序变化' },
                  { id: '9', name: '刷新页面,再次打开更多操作面板' },
                  { id: '10', name: '验证工具顺序是否保持' },
                ],
                expectedResults: [
                  { id: '1', name: '点击更多操作按钮后,visible.value变为true' },
                  { id: '2', name: 'Tool.vue第112-153行el-popover弹出层显示' },
                  { id: '3', name: 'popper-class="tool-panel",placement="right",width="320"' },
                  { id: '4', name: '第120行显示标题:"快捷操作"(使用i18n)' },
                  { id: '5', name: '第121-125行显示关闭按钮,点击后visible设为false' },
                  { id: '6', name: '第126行SDraggable组件v-model="operations"显示所有工具' },
                  { id: '7', name: '每个工具item包含:图标(第130-141行),名称(第142行),快捷键(第143-148行),固定按钮(第149行)' },
                  { id: '8', name: '固定按钮class="pin iconfont iconpin",已固定时添加active类' },
                  { id: '9', name: 'operations数组包含所有工具,无论是否固定' },
                  { id: '10', name: '拖拽后operations数组顺序更新,但不会保存(仅pinOperations保存)' },
                ],
                checkpoints: [
                  { id: '1', name: 'Tool.vue第114行:更多操作按钮 - @click.stop="visible = !visible"' },
                  { id: '2', name: 'Tool.vue第112行:el-popover配置 - :visible="visible", placement="right", width="320"' },
                  { id: '3', name: 'Tool.vue第226行:visible响应式变量控制弹出层显示' },
                  { id: '4', name: 'Tool.vue第126行:SDraggable - v-model="operations", group="operation2"' },
                  { id: '5', name: 'Tool.vue第128-151行:每个工具的完整UI(图标,名称,快捷键,固定按钮)' },
                  { id: '6', name: 'Tool.vue第149行:固定按钮 - @click.stop="togglePin(element)"' },
                  { id: '7', name: 'operations和pinOperations是两个独立数组,operations拖拽不触发watch保存' },
                ],
                notes: [
                  { id: '1', name: '更多操作面板显示所有工具,包括未固定的工具' },
                  { id: '2', name: 'operations数组顺序可以拖拽,但不会持久化保存' },
                  { id: '3', name: '仅pinOperations数组的顺序和内容会保存到localStorage' },
                  { id: '4', name: '@click.stop阻止事件冒泡,避免触发handleHidePopover关闭弹窗' },
                  { id: '5', name: 'group="operation2"与工具栏的group="operation"不同,避免互相拖拽' },
                ],
              },
              {
                purpose: '更多操作中的工具列表可以固定,点击固定后展示在工具栏,点击取消固定后从工具栏移除',
                precondition: [
                  { id: '1', name: '已打开更多操作面板' },
                  { id: '2', name: 'operations数组包含未固定的工具(如"导入文档",pin: false)' },
                  { id: '3', name: 'pinOperations数组包含已固定的工具' },
                ],
                operationSteps: [
                  { id: '1', name: '在更多操作面板中找到"导入文档"工具(pin: false,未固定)' },
                  { id: '2', name: '观察该工具右侧的固定按钮(iconpin图标),验证无active类' },
                  { id: '3', name: '点击"导入文档"工具的固定按钮' },
                  { id: '4', name: '观察固定按钮是否变为激活状态(添加active类)' },
                  { id: '5', name: '观察工具栏是否出现"导入文档"图标' },
                  { id: '6', name: '在更多操作面板中找到已固定的"回收站"工具' },
                  { id: '7', name: '点击"回收站"的固定按钮(取消固定)' },
                  { id: '8', name: '观察工具栏是否移除"回收站"图标' },
                  { id: '9', name: '刷新页面,验证固定状态是否保持' },
                ],
                expectedResults: [
                  { id: '1', name: '点击固定按钮触发Tool.vue第149行@click.stop="togglePin(element)"' },
                  { id: '2', name: 'Tool.vue第267-270行togglePin方法执行' },
                  { id: '3', name: '第268行:element.pin = !element.pin 切换pin状态' },
                  { id: '4', name: '第269行:pinOperations.value = operations.value.filter((v) => v.pin)重新筛选固定工具' },
                  { id: '5', name: '点击"导入文档"固定按钮后,pin从false变为true' },
                  { id: '6', name: 'pinOperations数组新增"导入文档"元素' },
                  { id: '7', name: '工具栏(第93行SDraggable)自动显示新增的"导入文档"图标' },
                  { id: '8', name: '固定按钮添加active类,图标样式变化(通常颜色高亮)' },
                  { id: '9', name: '点击"回收站"取消固定后,pin从true变为false' },
                  { id: '10', name: 'pinOperations数组移除"回收站"元素' },
                  { id: '11', name: '工具栏自动移除"回收站"图标' },
                  { id: '12', name: 'watch监听pinOperations变化,自动保存到localStorage' },
                  { id: '13', name: '刷新页面后,固定状态从localStorage恢复' },
                ],
                checkpoints: [
                  { id: '1', name: 'Tool.vue第149行:固定按钮 - class="pin iconfont iconpin" :class="{ active: element.pin }"' },
                  { id: '2', name: 'Tool.vue第149行:@click.stop="togglePin(element)"阻止冒泡并调用togglePin' },
                  { id: '3', name: 'Tool.vue第267行:togglePin方法定义' },
                  { id: '4', name: 'Tool.vue第268行:切换pin状态 - element.pin = !element.pin' },
                  { id: '5', name: 'Tool.vue第269行:重新筛选 - pinOperations.value = operations.value.filter((v) => v.pin)' },
                  { id: '6', name: 'Tool.vue第260行:watch监听pinOperations,deep: true' },
                  { id: '7', name: 'pin状态变化触发watch回调,保存到localStorage' },
                ],
                notes: [
                  { id: '1', name: 'togglePin方法修改element.pin,同时重新筛选pinOperations' },
                  { id: '2', name: 'pinOperations是computed结果,通过filter动态生成' },
                  { id: '3', name: 'active类名使固定按钮高亮,通常显示为不同颜色或填充' },
                  { id: '4', name: '@click.stop防止点击固定按钮时触发工具本身的点击事件' },
                  { id: '5', name: 'operations和pinOperations共享同一批对象,修改pin会同步反映' },
                ],
              },
              {
                purpose: '更多操作面板打开时候,点击关闭或者空白区域可以关闭面板',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '更多操作面板处于打开状态(visible.value为true)' },
                  { id: '3', name: 'el-popover组件已挂载并显示' },
                ],
                operationSteps: [
                  { id: '1', name: '定位到工具栏区域的更多操作按钮(data-testid="banner-tool-more-btn")' },
                  { id: '2', name: '点击更多操作按钮展开el-popover面板' },
                  { id: '3', name: '验证面板已打开并展示所有工具列表' },
                  { id: '4', name: '点击面板右上角的关闭按钮(带有Close图标的div.toolbar-close)' },
                  { id: '5', name: '观察面板关闭效果' },
                  { id: '6', name: '再次点击更多操作按钮展开面板' },
                  { id: '7', name: '点击面板外部的空白区域(例如banner其他区域或节点树区域)' },
                  { id: '8', name: '观察面板关闭效果' },
                ],
                expectedResults: [
                  { id: '1', name: '点击关闭按钮后,el-popover面板立即关闭' },
                  { id: '2', name: '关闭按钮点击时,visible.value被设置为false' },
                  { id: '3', name: '点击外部空白区域后,el-popover面板自动关闭' },
                  { id: '4', name: '点击外部区域时,handleHidePopover方法被触发' },
                  { id: '5', name: 'handleHidePopover方法执行时,visible.value和toggleProjectVisible.value都被设置为false' },
                  { id: '6', name: '面板关闭后,可以再次点击更多操作按钮重新打开' },
                  { id: '7', name: '面板关闭动画流畅,无闪烁或卡顿' },
                ],
                checkpoints: [
                  { id: '1', name: '关闭按钮位置在Tool.vue第121-125行' },
                  { id: '2', name: '关闭按钮点击事件:@click="visible = false"' },
                  { id: '3', name: 'handleHidePopover方法定义在Tool.vue第272-275行' },
                  { id: '4', name: 'handleHidePopover方法逻辑:visible.value = false和toggleProjectVisible.value = false' },
                  { id: '5', name: 'onMounted钩子(第276-279行)中绑定document.documentElement的click事件监听' },
                  { id: '6', name: 'onUnmounted钩子(第280-282行)中移除事件监听' },
                  { id: '7', name: 'el-popover组件的v-model绑定visible响应式变量' },
                ],
                notes: [
                  { id: '1', name: '面板关闭有两种触发方式:点击关闭按钮和点击外部区域' },
                  { id: '2', name: '关闭按钮使用@click="visible = false"直接设置状态' },
                  { id: '3', name: '点击外部区域通过全局document事件监听实现,在组件挂载时添加监听,卸载时移除' },
                  { id: '4', name: 'handleHidePopover方法同时关闭visible和toggleProjectVisible两个弹窗状态' },
                  { id: '5', name: 'el-popover组件的v-model双向绑定机制与visible变量同步,visible变化时面板自动显示/隐藏' },
                ],
              },
              {
                purpose: '点击新增目录按钮,弹出目录新增面板,可以新增目录,新增目录后,新增目录面板关闭,新增目录展示在节点树中,位置排序在根目录下最后一个目录节点下方',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: 'banner区域已加载完成,节点树已渲染' },
                  { id: '3', name: '新增目录按钮在工具栏中可见(可能在固定栏或更多操作面板中)' },
                  { id: '4', name: 'operations.ts中"新增文件夹"操作配置:op为"addRootFolder",pin默认为true' },
                ],
                operationSteps: [
                  { id: '1', name: '在工具栏区域找到"新增文件夹"按钮(icon为"#iconxinzengwenjian")' },
                  { id: '2', name: '点击"新增文件夹"按钮' },
                  { id: '3', name: '观察SAddFolderDialog对话框弹出' },
                  { id: '4', name: '在对话框中输入新目录名称(例如:"测试目录")' },
                  { id: '5', name: '点击对话框的确认按钮保存目录' },
                  { id: '6', name: '等待handleAddFileAndFolderCb回调执行' },
                  { id: '7', name: '观察对话框自动关闭' },
                  { id: '8', name: '观察新目录出现在banner左侧节点树中' },
                  { id: '9', name: '验证新目录的位置排序在根目录下最后一个目录节点下方' },
                ],
                expectedResults: [
                  { id: '1', name: '点击按钮后,handleEmit方法被调用,参数为"addRootFolder"' },
                  { id: '2', name: 'handleEmit中switch匹配到case "addRootFolder"(Tool.vue第287-289行)' },
                  { id: '3', name: 'addFolderDialogVisible.value被设置为true' },
                  { id: '4', name: 'SAddFolderDialog组件条件渲染(v-if="addFolderDialogVisible"为true)' },
                  { id: '5', name: '对话框显示在页面中央,包含目录名称输入框和确认/取消按钮' },
                  { id: '6', name: '保存成功后触发@success事件,调用handleAddFileAndFolderCb方法' },
                  { id: '7', name: 'handleAddFileAndFolderCb方法(Tool.vue第216-218行)调用addFileAndFolderCb函数处理新目录数据' },
                  { id: '8', name: 'addFolderDialogVisible.value自动设置为false,对话框关闭' },
                  { id: '9', name: '新目录节点添加到bannerStore的banner数组中' },
                  { id: '10', name: '新目录在el-tree中渲染,显示在根目录下最后一个目录节点下方' },
                  { id: '11', name: '新目录节点包含默认图标和用户输入的名称' },
                  { id: '12', name: '如果点击更多操作面板中的按钮,面板在执行操作后自动关闭(visible.value = false,Tool.vue第419行)' },
                ],
                checkpoints: [
                  { id: '1', name: 'operations.ts中"新增文件夹"配置:{ name: "新增文件夹", icon: "#iconxinzengwenjian", op: "addRootFolder", pin: true }' },
                  { id: '2', name: 'handleEmit方法中addRootFolder分支在Tool.vue第287-289行' },
                  { id: '3', name: 'addFolderDialogVisible响应式变量定义在Tool.vue第228行' },
                  { id: '4', name: 'SAddFolderDialog组件引用在Tool.vue第158-159行' },
                  { id: '5', name: 'SAddFolderDialog组件导入在Tool.vue第174行' },
                  { id: '6', name: 'handleAddFileAndFolderCb回调定义在Tool.vue第216-218行' },
                  { id: '7', name: 'addFileAndFolderCb函数导入自"../composables/curd-node"(Tool.vue第176行)' },
                  { id: '8', name: 'handleEmit方法末尾执行visible.value = false(Tool.vue第419行)关闭更多操作面板' },
                ],
                notes: [
                  { id: '1', name: '新增目录操作通过handleEmit方法的switch语句路由到addRootFolder分支' },
                  { id: '2', name: 'SAddFolderDialog是一个对话框组件,通过v-model="addFolderDialogVisible"控制显示/隐藏' },
                  { id: '3', name: '对话框保存成功后触发@success事件,传递新目录数据给handleAddFileAndFolderCb回调' },
                  { id: '4', name: 'handleAddFileAndFolderCb内部调用addFileAndFolderCb函数,该函数位于composables/curd-node中,负责将新节点添加到banner树结构' },
                  { id: '5', name: '新目录的排序位置由addFileAndFolderCb函数内部逻辑决定,按照根目录下最后一个目录节点下方的规则排序' },
                  { id: '6', name: '如果从更多操作面板点击,handleEmit方法末尾的visible.value = false会自动关闭面板' },
                ],
              },
              {
                purpose: '点击新增接口按钮,弹出接口新增面板,可以新增接口,新增接口后,新增接口面板关闭,新增接口展示在节点树中,位置排序在根接最下方(需要在httpNode,websocketNode,httpMockNode,websocketMock下)',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: 'banner区域已加载完成,节点树已渲染' },
                  { id: '3', name: '新增接口按钮在工具栏中可见(可能在固定栏或更多操作面板中)' },
                  { id: '4', name: 'operations.ts中"新增文件"操作配置:op为"addRootFile",pin默认为true' },
                ],
                operationSteps: [
                  { id: '1', name: '在工具栏区域找到"新增文件"按钮(icon为"#iconwenjian")' },
                  { id: '2', name: '点击"新增文件"按钮' },
                  { id: '3', name: '观察SAddFileDialog对话框弹出' },
                  { id: '4', name: '在对话框中选择接口类型(httpNode,websocketNode,httpMockNode或websocketMock)' },
                  { id: '5', name: '输入新接口名称(例如:"测试接口")' },
                  { id: '6', name: '点击对话框的确认按钮保存接口' },
                  { id: '7', name: '等待handleAddFileAndFolderCb回调执行' },
                  { id: '8', name: '观察对话框自动关闭' },
                  { id: '9', name: '观察新接口出现在banner左侧节点树中' },
                  { id: '10', name: '验证新接口的位置排序在根目录下对应类型节点的最下方' },
                ],
                expectedResults: [
                  { id: '1', name: '点击按钮后,handleEmit方法被调用,参数为"addRootFile"' },
                  { id: '2', name: 'handleEmit中switch匹配到case "addRootFile"(Tool.vue第290-292行)' },
                  { id: '3', name: 'addFileDialogVisible.value被设置为true' },
                  { id: '4', name: 'SAddFileDialog组件条件渲染(v-if="addFileDialogVisible"为true)' },
                  { id: '5', name: '对话框显示在页面中央,包含接口类型选择器,名称输入框和确认/取消按钮' },
                  { id: '6', name: '接口类型选择器支持httpNode,websocketNode,httpMockNode,websocketMock四种类型' },
                  { id: '7', name: '保存成功后触发@success事件,调用handleAddFileAndFolderCb方法' },
                  { id: '8', name: 'handleAddFileAndFolderCb方法(Tool.vue第216-218行)调用addFileAndFolderCb函数处理新接口数据' },
                  { id: '9', name: 'addFileDialogVisible.value自动设置为false,对话框关闭' },
                  { id: '10', name: '新接口节点添加到bannerStore的banner数组中' },
                  { id: '11', name: '新接口在el-tree中渲染,显示在根目录下对应类型节点的最下方' },
                  { id: '12', name: '新接口节点包含对应类型的默认图标,用户输入的名称和类型标识' },
                  { id: '13', name: '如果点击更多操作面板中的按钮,面板在执行操作后自动关闭(visible.value = false,Tool.vue第419行)' },
                ],
                checkpoints: [
                  { id: '1', name: 'operations.ts中"新增文件"配置:{ name: "新增文件", icon: "#iconwenjian", op: "addRootFile", pin: true }' },
                  { id: '2', name: 'handleEmit方法中addRootFile分支在Tool.vue第290-292行' },
                  { id: '3', name: 'addFileDialogVisible响应式变量定义在Tool.vue第227行' },
                  { id: '4', name: 'SAddFileDialog组件引用在Tool.vue第156-157行' },
                  { id: '5', name: 'SAddFileDialog组件导入在Tool.vue第173行' },
                  { id: '6', name: 'handleAddFileAndFolderCb回调定义在Tool.vue第216-218行' },
                  { id: '7', name: 'addFileAndFolderCb函数导入自"../composables/curd-node"(Tool.vue第176行)' },
                  { id: '8', name: 'handleEmit方法末尾执行visible.value = false(Tool.vue第419行)关闭更多操作面板' },
                ],
                notes: [
                  { id: '1', name: '新增接口操作通过handleEmit方法的switch语句路由到addRootFile分支' },
                  { id: '2', name: 'SAddFileDialog是一个对话框组件,通过v-model="addFileDialogVisible"控制显示/隐藏' },
                  { id: '3', name: '对话框支持四种接口类型选择:httpNode(HTTP接口),websocketNode(WebSocket接口),httpMockNode(HTTP Mock),websocketMock(WebSocket Mock)' },
                  { id: '4', name: '对话框保存成功后触发@success事件,传递新接口数据(包含类型和名称)给handleAddFileAndFolderCb回调' },
                  { id: '5', name: 'handleAddFileAndFolderCb内部调用addFileAndFolderCb函数,该函数位于composables/curd-node中,负责将新节点添加到banner树结构' },
                  { id: '6', name: '新接口的排序位置由addFileAndFolderCb函数内部逻辑决定,按照根目录下对应类型节点最下方的规则排序' },
                  { id: '7', name: '如果从更多操作面板点击,handleEmit方法末尾的visible.value = false会自动关闭面板' },
                ],
              },
              {
                purpose: '点击刷新按钮,刷新当前banner数据',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: 'banner区域已加载完成,节点树已渲染' },
                  { id: '3', name: '刷新按钮在工具栏中可见(可能在固定栏或更多操作面板中)' },
                  { id: '4', name: 'operations.ts中"刷新banner"操作配置:op为"freshBanner",pin默认为true,viewOnly为true(预览模式展示)' },
                ],
                operationSteps: [
                  { id: '1', name: '在工具栏区域找到"刷新banner"按钮(icon为"#iconshuaxin")' },
                  { id: '2', name: '点击"刷新banner"按钮' },
                  { id: '3', name: '观察Tool.vue组件触发fresh事件' },
                  { id: '4', name: '观察Banner.vue父组件接收fresh事件并执行刷新逻辑' },
                  { id: '5', name: '等待banner数据从远程或本地重新加载' },
                  { id: '6', name: '观察节点树重新渲染,显示最新的banner数据' },
                  { id: '7', name: '验证节点树展开状态和滚动位置保持或恢复' },
                ],
                expectedResults: [
                  { id: '1', name: '点击按钮后,handleEmit方法被调用,参数为"freshBanner"' },
                  { id: '2', name: 'handleEmit中switch匹配到case "freshBanner"(Tool.vue第293-295行)' },
                  { id: '3', name: 'emits("fresh")触发,向父组件Banner.vue发送fresh事件' },
                  { id: '4', name: 'Banner.vue接收到@fresh事件,执行绑定的刷新处理方法' },
                  { id: '5', name: '刷新方法从bannerStore或API重新获取最新的banner节点数据' },
                  { id: '6', name: 'bannerStore.banner数组被更新为最新数据' },
                  { id: '7', name: 'el-tree组件响应式重新渲染,显示更新后的节点树' },
                  { id: '8', name: '如果有新增或删除的节点,节点树立即反映这些变化' },
                  { id: '9', name: '如果点击更多操作面板中的按钮,面板在执行操作后自动关闭(visible.value = false,Tool.vue第419行)' },
                ],
                checkpoints: [
                  { id: '1', name: 'operations.ts中"刷新banner"配置:{ name: "刷新banner", icon: "#iconshuaxin", op: "freshBanner", pin: true, viewOnly: true }' },
                  { id: '2', name: 'handleEmit方法中freshBanner分支在Tool.vue第293-295行' },
                  { id: '3', name: 'emits定义在Tool.vue第213行:defineEmits(["fresh", "filter", "changeProject"])' },
                  { id: '4', name: 'Banner.vue中应该有@fresh事件监听绑定到Tool.vue组件上' },
                  { id: '5', name: 'viewOnly属性为true表示该按钮在预览模式下也会展示' },
                  { id: '6', name: 'handleEmit方法末尾执行visible.value = false(Tool.vue第419行)关闭更多操作面板' },
                ],
                notes: [
                  { id: '1', name: '刷新banner操作通过事件触发机制实现,Tool.vue发出fresh事件,Banner.vue接收并处理' },
                  { id: '2', name: 'emits("fresh")不传递参数,父组件接收到事件后自行执行刷新逻辑' },
                  { id: '3', name: 'viewOnly属性为true表示该操作在预览模式(只读模式)下也可以使用' },
                  { id: '4', name: '刷新操作不会弹出对话框,而是直接执行数据重新加载' },
                  { id: '5', name: 'Banner.vue的刷新方法应该调用bannerStore的相关action重新获取数据' },
                  { id: '6', name: '如果从更多操作面板点击,handleEmit方法末尾的visible.value = false会自动关闭面板' },
                ],
              },
              {
                purpose: '点击回收站图标,展示回收站页面',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '回收站按钮在工具栏中可见(可能在固定栏或更多操作面板中)' },
                  { id: '3', name: 'operations.ts中"回收站"操作配置:op为"recycler",pin默认为true' },
                  { id: '4', name: 'projectNavStore已初始化,支持标签页管理' },
                ],
                operationSteps: [
                  { id: '1', name: '在工具栏区域找到"回收站"按钮(icon为"#iconhuishouzhan")' },
                  { id: '2', name: '点击"回收站"按钮' },
                  { id: '3', name: '观察handleEmit方法执行recycler分支' },
                  { id: '4', name: '观察projectNavStore.addNav方法被调用,创建回收站标签页' },
                  { id: '5', name: '观察主内容区域切换到回收站页面' },
                  { id: '6', name: '验证标签栏显示"回收站"标签' },
                  { id: '7', name: '验证回收站页面显示已删除的节点列表' },
                ],
                expectedResults: [
                  { id: '1', name: '点击按钮后,handleEmit方法被调用,参数为"recycler"' },
                  { id: '2', name: 'handleEmit中switch匹配到case "recycler"(Tool.vue第341-355行)' },
                  { id: '3', name: 'projectNavStore.addNav方法被调用,传入回收站标签页配置对象' },
                  { id: '4', name: '标签页配置包含:_id为"recycler",projectId为当前项目ID,tabType为"recycler",label为国际化文本t("回收站")' },
                  { id: '5', name: '标签页配置的head对象包含icon为空字符串和color为空字符串' },
                  { id: '6', name: '标签页配置的saved为true(表示已保存状态),fixed为true(表示固定标签),selected为true(表示选中状态)' },
                  { id: '7', name: 'projectNavStore将新标签页添加到导航栏tabs数组中' },
                  { id: '8', name: '主内容区域路由切换到回收站组件,显示回收站页面' },
                  { id: '9', name: '标签栏显示"回收站"标签,且该标签处于选中状态' },
                  { id: '10', name: '回收站页面展示当前项目下所有被删除的节点(文件夹和接口)' },
                  { id: '11', name: '如果点击更多操作面板中的按钮,面板在执行操作后自动关闭(visible.value = false,Tool.vue第419行)' },
                ],
                checkpoints: [
                  { id: '1', name: 'operations.ts中"回收站"配置:{ name: "回收站", icon: "#iconhuishouzhan", op: "recycler", shortcut: ["Ctrl", "Alt", "R"], pin: true }' },
                  { id: '2', name: 'handleEmit方法中recycler分支在Tool.vue第341-355行' },
                  { id: '3', name: 'projectNavStore导入在Tool.vue第180行:import { useProjectNav } from "@/store/projectWorkbench/projectNavStore"' },
                  { id: '4', name: 'projectNavStore实例化在Tool.vue第206行:const projectNavStore = useProjectNav()' },
                  { id: '5', name: 'projectId获取在Tool.vue第284行:const projectId = router.currentRoute.value.query.id as string' },
                  { id: '6', name: 'addNav方法传入的对象包含7个属性:_id,projectId,tabType,label,head,saved,fixed,selected' },
                  { id: '7', name: 't函数来自useI18n composable(Tool.vue第207行)' },
                  { id: '8', name: 'handleEmit方法末尾执行visible.value = false(Tool.vue第419行)关闭更多操作面板' },
                ],
                notes: [
                  { id: '1', name: '回收站操作通过projectNavStore.addNav创建新的标签页实现页面切换' },
                  { id: '2', name: 'addNav方法会检查是否已存在相同_id的标签页,如果存在则激活该标签页,不存在则创建新标签页' },
                  { id: '3', name: 'tabType为"recycler"标识标签页类型,用于路由匹配和组件渲染' },
                  { id: '4', name: 'fixed为true表示该标签页为固定标签,不能被用户关闭' },
                  { id: '5', name: 'selected为true表示创建后立即选中该标签页,主内容区域切换到回收站页面' },
                  { id: '6', name: '回收站支持快捷键Ctrl+Alt+R快速打开' },
                  { id: '7', name: '如果从更多操作面板点击,handleEmit方法末尾的visible.value = false会自动关闭面板' },
                ],
              },
              {
                purpose: '点击导入文档图标,展示导入文档页面',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '导入文档按钮在工具栏中可见(可能在固定栏或更多操作面板中)' },
                  { id: '3', name: 'operations.ts中"导入文档"操作配置:op为"importDoc",pin默认为false(不固定在工具栏)' },
                  { id: '4', name: 'projectNavStore已初始化,支持标签页管理' },
                ],
                operationSteps: [
                  { id: '1', name: '在工具栏区域找到"导入文档"按钮(icon为"arrowDownToLine",lucide图标)' },
                  { id: '2', name: '点击"导入文档"按钮' },
                  { id: '3', name: '观察handleEmit方法执行importDoc分支' },
                  { id: '4', name: '观察projectNavStore.addNav方法被调用,创建导入文档标签页' },
                  { id: '5', name: '观察主内容区域切换到导入文档页面' },
                  { id: '6', name: '验证标签栏显示"导入文档"标签' },
                  { id: '7', name: '验证导入文档页面显示导入选项和文件上传区域' },
                ],
                expectedResults: [
                  { id: '1', name: '点击按钮后,handleEmit方法被调用,参数为"importDoc"' },
                  { id: '2', name: 'handleEmit中switch匹配到case "importDoc"(Tool.vue第326-340行)' },
                  { id: '3', name: 'projectNavStore.addNav方法被调用,传入导入文档标签页配置对象' },
                  { id: '4', name: '标签页配置包含:_id为"importDoc",projectId为当前项目ID,tabType为"importDoc",label为国际化文本t("导入文档")' },
                  { id: '5', name: '标签页配置的head对象包含icon为空字符串和color为空字符串' },
                  { id: '6', name: '标签页配置的saved为true(表示已保存状态),fixed为true(表示固定标签),selected为true(表示选中状态)' },
                  { id: '7', name: 'projectNavStore将新标签页添加到导航栏tabs数组中' },
                  { id: '8', name: '主内容区域路由切换到导入文档组件,显示导入文档页面' },
                  { id: '9', name: '标签栏显示"导入文档"标签,且该标签处于选中状态' },
                  { id: '10', name: '导入文档页面展示支持的导入格式(如OpenAPI,Postman,Apifox等)和文件上传区域' },
                  { id: '11', name: '如果点击更多操作面板中的按钮,面板在执行操作后自动关闭(visible.value = false,Tool.vue第419行)' },
                ],
                checkpoints: [
                  { id: '1', name: 'operations.ts中"导入文档"配置:{ name: "导入文档", icon: "arrowDownToLine", op: "importDoc", shortcut: ["Ctrl", "I"], pin: false }' },
                  { id: '2', name: 'handleEmit方法中importDoc分支在Tool.vue第326-340行' },
                  { id: '3', name: 'ArrowDownToLine图标来自lucide-vue-next库(Tool.vue第167行导入)' },
                  { id: '4', name: '工具栏渲染时,arrowDownToLine图标通过v-else-if条件渲染(Tool.vue第133-135行)' },
                  { id: '5', name: 'projectNavStore导入在Tool.vue第180行:import { useProjectNav } from "@/store/projectWorkbench/projectNavStore"' },
                  { id: '6', name: 'projectId获取在Tool.vue第284行:const projectId = router.currentRoute.value.query.id as string' },
                  { id: '7', name: 'addNav方法传入的对象包含7个属性:_id,projectId,tabType,label,head,saved,fixed,selected' },
                  { id: '8', name: '导入文档支持快捷键Ctrl+I快速打开' },
                  { id: '9', name: 'handleEmit方法末尾执行visible.value = false(Tool.vue第419行)关闭更多操作面板' },
                ],
                notes: [
                  { id: '1', name: '导入文档操作通过projectNavStore.addNav创建新的标签页实现页面切换' },
                  { id: '2', name: 'icon为"arrowDownToLine"使用lucide-vue-next图标库,不是iconfont的#icon格式' },
                  { id: '3', name: 'pin默认为false表示该按钮默认不固定在工具栏,需要在更多操作面板中找到' },
                  { id: '4', name: 'tabType为"importDoc"标识标签页类型,用于路由匹配和组件渲染' },
                  { id: '5', name: 'fixed为true表示该标签页为固定标签,不能被用户关闭' },
                  { id: '6', name: 'selected为true表示创建后立即选中该标签页,主内容区域切换到导入文档页面' },
                  { id: '7', name: '导入文档页面支持多种格式导入,如OpenAPI,Postman,Swagger,Apifox等' },
                  { id: '8', name: '如果从更多操作面板点击,handleEmit方法末尾的visible.value = false会自动关闭面板' },
                ],
              },
              {
                purpose: '点击导出文档图标,展示导出文档页面',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '导出文档按钮在工具栏中可见(可能在固定栏或更多操作面板中)' },
                  { id: '3', name: 'operations.ts中"导出文档"操作配置:op为"exportDoc",pin默认为false(不固定在工具栏)' },
                  { id: '4', name: 'projectNavStore已初始化,支持标签页管理' },
                ],
                operationSteps: [
                  { id: '1', name: '在工具栏区域找到"导出文档"按钮(icon为"arrowUpToLine",lucide图标)' },
                  { id: '2', name: '点击"导出文档"按钮' },
                  { id: '3', name: '观察handleEmit方法执行exportDoc分支' },
                  { id: '4', name: '观察projectNavStore.addNav方法被调用,创建导出文档标签页' },
                  { id: '5', name: '观察主内容区域切换到导出文档页面' },
                  { id: '6', name: '验证标签栏显示"导出文档"标签' },
                  { id: '7', name: '验证导出文档页面显示导出选项和格式选择区域' },
                ],
                expectedResults: [
                  { id: '1', name: '点击按钮后,handleEmit方法被调用,参数为"exportDoc"' },
                  { id: '2', name: 'handleEmit中switch匹配到case "exportDoc"(Tool.vue第311-325行)' },
                  { id: '3', name: 'projectNavStore.addNav方法被调用,传入导出文档标签页配置对象' },
                  { id: '4', name: '标签页配置包含:_id为"exportDoc",projectId为当前项目ID,tabType为"exportDoc",label为国际化文本t("导出文档")' },
                  { id: '5', name: '标签页配置的head对象包含icon为空字符串和color为空字符串' },
                  { id: '6', name: '标签页配置的saved为true(表示已保存状态),fixed为true(表示固定标签),selected为true(表示选中状态)' },
                  { id: '7', name: 'projectNavStore将新标签页添加到导航栏tabs数组中' },
                  { id: '8', name: '主内容区域路由切换到导出文档组件,显示导出文档页面' },
                  { id: '9', name: '标签栏显示"导出文档"标签,且该标签处于选中状态' },
                  { id: '10', name: '导出文档页面展示支持的导出格式(如OpenAPI,Markdown,HTML等)和导出选项' },
                  { id: '11', name: '如果点击更多操作面板中的按钮,面板在执行操作后自动关闭(visible.value = false,Tool.vue第419行)' },
                ],
                checkpoints: [
                  { id: '1', name: 'operations.ts中"导出文档"配置:{ name: "导出文档", icon: "arrowUpToLine", op: "exportDoc", shortcut: ["Ctrl", "E"], pin: false }' },
                  { id: '2', name: 'handleEmit方法中exportDoc分支在Tool.vue第311-325行' },
                  { id: '3', name: 'ArrowUpToLine图标来自lucide-vue-next库(Tool.vue第167行导入)' },
                  { id: '4', name: '工具栏渲染时,arrowUpToLine图标通过v-else-if条件渲染(Tool.vue第136-138行)' },
                  { id: '5', name: 'projectNavStore导入在Tool.vue第180行:import { useProjectNav } from "@/store/projectWorkbench/projectNavStore"' },
                  { id: '6', name: 'projectId获取在Tool.vue第284行:const projectId = router.currentRoute.value.query.id as string' },
                  { id: '7', name: 'addNav方法传入的对象包含7个属性:_id,projectId,tabType,label,head,saved,fixed,selected' },
                  { id: '8', name: '导出文档支持快捷键Ctrl+E快速打开' },
                  { id: '9', name: 'handleEmit方法末尾执行visible.value = false(Tool.vue第419行)关闭更多操作面板' },
                ],
                notes: [
                  { id: '1', name: '导出文档操作通过projectNavStore.addNav创建新的标签页实现页面切换' },
                  { id: '2', name: 'icon为"arrowUpToLine"使用lucide-vue-next图标库,不是iconfont的#icon格式' },
                  { id: '3', name: 'pin默认为false表示该按钮默认不固定在工具栏,需要在更多操作面板中找到' },
                  { id: '4', name: 'tabType为"exportDoc"标识标签页类型,用于路由匹配和组件渲染' },
                  { id: '5', name: 'fixed为true表示该标签页为固定标签,不能被用户关闭' },
                  { id: '6', name: 'selected为true表示创建后立即选中该标签页,主内容区域切换到导出文档页面' },
                  { id: '7', name: '导出文档页面支持多种格式导出,如OpenAPI,Markdown,HTML,Word等' },
                  { id: '8', name: '如果从更多操作面板点击,handleEmit方法末尾的visible.value = false会自动关闭面板' },
                ],
              },
              {
                purpose: '点击Cookie图标,展示Cookie页面',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: 'Cookie管理按钮在工具栏中可见(可能在固定栏或更多操作面板中)' },
                  { id: '3', name: 'operations.ts中"Cookie管理"操作配置:op为"cookies",pin默认为true' },
                  { id: '4', name: 'projectNavStore已初始化,支持标签页管理' },
                ],
                operationSteps: [
                  { id: '1', name: '在工具栏区域找到"Cookie管理"按钮(icon为"#iconCookies")' },
                  { id: '2', name: '点击"Cookie管理"按钮' },
                  { id: '3', name: '观察handleEmit方法执行cookies分支' },
                  { id: '4', name: '观察projectNavStore.addNav方法被调用,创建Cookies标签页' },
                  { id: '5', name: '观察主内容区域切换到Cookies管理页面' },
                  { id: '6', name: '验证标签栏显示"Cookies"标签' },
                  { id: '7', name: '验证Cookies页面显示当前项目的Cookie列表和管理操作' },
                ],
                expectedResults: [
                  { id: '1', name: '点击按钮后,handleEmit方法被调用,参数为"cookies"' },
                  { id: '2', name: 'handleEmit中switch匹配到case "cookies"(Tool.vue第401-415行)' },
                  { id: '3', name: 'projectNavStore.addNav方法被调用,传入Cookies标签页配置对象' },
                  { id: '4', name: '标签页配置包含:_id为"cookies",projectId为当前项目ID,tabType为"cookies",label为国际化文本t("Cookies")' },
                  { id: '5', name: '标签页配置的head对象包含icon为空字符串和color为空字符串' },
                  { id: '6', name: '标签页配置的saved为true(表示已保存状态),fixed为true(表示固定标签),selected为true(表示选中状态)' },
                  { id: '7', name: 'projectNavStore将新标签页添加到导航栏tabs数组中' },
                  { id: '8', name: '主内容区域路由切换到Cookies管理组件,显示Cookies页面' },
                  { id: '9', name: '标签栏显示"Cookies"标签,且该标签处于选中状态' },
                  { id: '10', name: 'Cookies页面展示当前项目的所有Cookie记录,包含域名,路径,名称,值,过期时间等字段' },
                  { id: '11', name: 'Cookies页面支持添加,编辑,删除Cookie操作' },
                  { id: '12', name: '如果点击更多操作面板中的按钮,面板在执行操作后自动关闭(visible.value = false,Tool.vue第419行)' },
                ],
                checkpoints: [
                  { id: '1', name: 'operations.ts中"Cookie管理"配置:{ name: "Cookie管理", icon: "#iconCookies", op: "cookies", shortcut: ["Ctrl", "Alt", "C"], pin: true }' },
                  { id: '2', name: 'handleEmit方法中cookies分支在Tool.vue第401-415行' },
                  { id: '3', name: 'projectNavStore导入在Tool.vue第180行:import { useProjectNav } from "@/store/projectWorkbench/projectNavStore"' },
                  { id: '4', name: 'projectNavStore实例化在Tool.vue第206行:const projectNavStore = useProjectNav()' },
                  { id: '5', name: 'projectId获取在Tool.vue第284行:const projectId = router.currentRoute.value.query.id as string' },
                  { id: '6', name: 'addNav方法传入的对象包含7个属性:_id,projectId,tabType,label,head,saved,fixed,selected' },
                  { id: '7', name: 't函数来自useI18n composable(Tool.vue第207行)' },
                  { id: '8', name: 'Cookies支持快捷键Ctrl+Alt+C快速打开' },
                  { id: '9', name: 'handleEmit方法末尾执行visible.value = false(Tool.vue第419行)关闭更多操作面板' },
                ],
                notes: [
                  { id: '1', name: 'Cookie管理操作通过projectNavStore.addNav创建新的标签页实现页面切换' },
                  { id: '2', name: 'tabType为"cookies"标识标签页类型,用于路由匹配和组件渲染' },
                  { id: '3', name: 'fixed为true表示该标签页为固定标签,不能被用户关闭' },
                  { id: '4', name: 'selected为true表示创建后立即选中该标签页,主内容区域切换到Cookies页面' },
                  { id: '5', name: 'Cookies数据存储在cookiesStore中,与项目关联' },
                  { id: '6', name: 'Cookies在HTTP请求时会自动添加到请求头中,支持域名和路径匹配' },
                  { id: '7', name: 'Cookies管理支持快捷键Ctrl+Alt+C快速打开' },
                  { id: '8', name: '如果从更多操作面板点击,handleEmit方法末尾的visible.value = false会自动关闭面板' },
                ],
              },
              {
                purpose: '点击变量图标,展示变量页面',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '变量管理按钮在工具栏中可见(可能在固定栏或更多操作面板中)' },
                  { id: '3', name: 'operations.ts中"全局变量"操作配置:op为"variable",pin默认为false,viewOnly为true(预览模式展示)' },
                  { id: '4', name: 'projectNavStore已初始化,支持标签页管理' },
                ],
                operationSteps: [
                  { id: '1', name: '在工具栏区域找到"全局变量"按钮(icon为"variable",lucide图标)' },
                  { id: '2', name: '点击"全局变量"按钮' },
                  { id: '3', name: '观察handleEmit方法执行variable分支' },
                  { id: '4', name: '观察projectNavStore.addNav方法被调用,创建变量标签页' },
                  { id: '5', name: '观察主内容区域切换到变量管理页面' },
                  { id: '6', name: '验证标签栏显示"变量"标签' },
                  { id: '7', name: '验证变量页面显示全局变量,环境变量,本地变量等分类和管理操作' },
                ],
                expectedResults: [
                  { id: '1', name: '点击按钮后,handleEmit方法被调用,参数为"variable"' },
                  { id: '2', name: 'handleEmit中switch匹配到case "variable"(Tool.vue第386-400行)' },
                  { id: '3', name: 'projectNavStore.addNav方法被调用,传入变量标签页配置对象' },
                  { id: '4', name: '标签页配置包含:_id为"variable",projectId为当前项目ID,tabType为"variable",label为国际化文本t("变量")' },
                  { id: '5', name: '标签页配置的head对象包含icon为空字符串和color为空字符串' },
                  { id: '6', name: '标签页配置的saved为true(表示已保存状态),fixed为true(表示固定标签),selected为true(表示选中状态)' },
                  { id: '7', name: 'projectNavStore将新标签页添加到导航栏tabs数组中' },
                  { id: '8', name: '主内容区域路由切换到变量管理组件,显示变量页面' },
                  { id: '9', name: '标签栏显示"变量"标签,且该标签处于选中状态' },
                  { id: '10', name: '变量页面展示不同作用域的变量列表:全局变量,环境变量,本地变量,会话变量' },
                  { id: '11', name: '变量页面支持添加,编辑,删除变量操作,支持变量名称和值的输入' },
                  { id: '12', name: '变量页面支持变量作用域切换,不同作用域的变量独立管理' },
                  { id: '13', name: '如果点击更多操作面板中的按钮,面板在执行操作后自动关闭(visible.value = false,Tool.vue第419行)' },
                ],
                checkpoints: [
                  { id: '1', name: 'operations.ts中"全局变量"配置:{ name: "全局变量", icon: "variable", op: "variable", pin: false, viewOnly: true }' },
                  { id: '2', name: 'handleEmit方法中variable分支在Tool.vue第386-400行' },
                  { id: '3', name: 'Variable图标来自lucide-vue-next库(Tool.vue第167行导入)' },
                  { id: '4', name: '工具栏渲染时,variable图标通过v-if条件渲染(Tool.vue第130-132行)' },
                  { id: '5', name: 'projectNavStore导入在Tool.vue第180行:import { useProjectNav } from "@/store/projectWorkbench/projectNavStore"' },
                  { id: '6', name: 'projectNavStore实例化在Tool.vue第206行:const projectNavStore = useProjectNav()' },
                  { id: '7', name: 'projectId获取在Tool.vue第284行:const projectId = router.currentRoute.value.query.id as string' },
                  { id: '8', name: 'addNav方法传入的对象包含7个属性:_id,projectId,tabType,label,head,saved,fixed,selected' },
                  { id: '9', name: 't函数来自useI18n composable(Tool.vue第207行)' },
                  { id: '10', name: 'viewOnly属性为true表示该按钮在预览模式下也会展示' },
                  { id: '11', name: 'handleEmit方法末尾执行visible.value = false(Tool.vue第419行)关闭更多操作面板' },
                ],
                notes: [
                  { id: '1', name: '变量管理操作通过projectNavStore.addNav创建新的标签页实现页面切换' },
                  { id: '2', name: 'icon为"variable"使用lucide-vue-next图标库,不是iconfont的#icon格式' },
                  { id: '3', name: 'pin默认为false表示该按钮默认不固定在工具栏,需要在更多操作面板中找到' },
                  { id: '4', name: 'viewOnly属性为true表示该操作在预览模式(只读模式)下也可以使用' },
                  { id: '5', name: 'tabType为"variable"标识标签页类型,用于路由匹配和组件渲染' },
                  { id: '6', name: 'fixed为true表示该标签页为固定标签,不能被用户关闭' },
                  { id: '7', name: 'selected为true表示创建后立即选中该标签页,主内容区域切换到变量页面' },
                  { id: '8', name: '变量数据存储在variablesStore中,支持全局,环境,本地,会话四种作用域' },
                  { id: '9', name: '变量在HTTP请求时通过{{ variableName }}语法引用,支持嵌套和动态替换' },
                  { id: '10', name: '如果从更多操作面板点击,handleEmit方法末尾的visible.value = false会自动关闭面板' },
                ],
              },
            ],
          },
          {
            modelName: 'banner详情区',
            description: 'banner详情区',
            children: [
              {
                modelName: '节点操作区域',
                description: '节点操作区域',
                children: [
                  //添加节点
                  {
                    modelName: 'addNode',
                    description: '添加节点',
                    children: [
                      {
                        modelName: '新增httpNode',
                        description: '新增http节点',
                        atomicFunc: [
                          {
                            purpose: '鼠标右键空白区域添加http节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: 'banner区域已加载完成,节点树已渲染' },
                              { id: '3', name: '节点树有空白区域可以右键点击' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标移动到banner节点树的空白区域(非节点区域)' },
                              { id: '2', name: '点击鼠标右键触发handleWrapContextmenu方法' },
                              { id: '3', name: '观察SContextmenu右键菜单弹出' },
                              { id: '4', name: '在右键菜单中点击"新建接口"选项' },
                              { id: '5', name: '观察SAddFileDialog对话框弹出' },
                              { id: '6', name: '在对话框中输入接口名称(例如:"测试HTTP接口")' },
                              { id: '7', name: '选择接口类型为"HTTP"(默认选中)' },
                              { id: '8', name: '点击确定按钮保存' },
                              { id: '9', name: '观察对话框关闭,新HTTP节点出现在节点树根目录下' },
                            ],
                            expectedResults: [
                              { id: '1', name: '右键空白区域后,handleWrapContextmenu方法被触发(Banner.vue第363-379行)' },
                              { id: '2', name: 'showContextmenu.value被设置为true,contextmenuLeft和contextmenuTop记录鼠标位置' },
                              { id: '3', name: 'currentOperationalNode.value为null(因为是空白区域,非节点操作)' },
                              { id: '4', name: 'SContextmenu组件渲染在鼠标点击位置(Banner.vue第221-245行)' },
                              { id: '5', name: '右键菜单显示"新建接口","新建文件夹","设置公共请求头"等选项' },
                              { id: '6', name: '点击"新建接口"后,handleOpenAddFileDialog方法被调用(Banner.vue第488-497行)' },
                              { id: '7', name: 'addFileDialogVisible.value被设置为true' },
                              { id: '8', name: 'SAddFileDialog组件条件渲染(Banner.vue第255-256行,v-if="addFileDialogVisible"为true)' },
                              { id: '9', name: '对话框显示接口名称输入框,接口类型选择(HTTP/WebSocket/HTTP Mock/WebSocket Mock)' },
                              { id: '10', name: '接口类型默认选中HTTP(第一个选项)' },
                              { id: '11', name: '点击确定后触发handleAddFile方法,创建新的HTTP节点' },
                              { id: '12', name: 'handleAddFileAndFolderCb回调被调用(Banner.vue第503-506行)' },
                              { id: '13', name: 'addFileAndFolderCb函数将新节点添加到banner树的根目录下(因为pid为空)' },
                              { id: '14', name: '新HTTP节点显示在节点树根目录最下方,包含用户输入的名称和HTTP图标' },
                              { id: '15', name: 'bannerStore.addExpandItem被调用,将新节点ID添加到展开列表' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleWrapContextmenu方法定义在Banner.vue第363-379行' },
                              { id: '2', name: '空白区域右键绑定:@contextmenu.prevent="handleWrapContextmenu"(Banner.vue第10行)' },
                              { id: '3', name: 'SContextmenu单节点菜单在Banner.vue第221-245行' },
                              { id: '4', name: '"新建接口"菜单项绑定:@click="handleOpenAddFileDialog"(Banner.vue第223-224行)' },
                              { id: '5', name: 'handleOpenAddFileDialog方法在Banner.vue第488-497行' },
                              { id: '6', name: 'SAddFileDialog组件引用在Banner.vue第255-256行' },
                              { id: '7', name: 'SAddFileDialog组件文件路径:dialog/addFile/AddFile.vue' },
                              { id: '8', name: '对话框接收pid属性为空字符串(表示在根目录添加)' },
                              { id: '9', name: '对话框@success事件绑定handleAddFileAndFolderCb方法' },
                              { id: '10', name: 'handleAddFileAndFolderCb方法在Banner.vue第503-506行' },
                            ],
                            notes: [
                              { id: '1', name: '空白区域右键与节点右键的区别:空白区域currentOperationalNode为null,节点右键currentOperationalNode为节点数据' },
                              { id: '2', name: '右键菜单通过v-show控制选项显示:!currentOperationalNode表示仅在空白区域或folder节点显示"新建接口"' },
                              { id: '3', name: 'SAddFileDialog对话框通过v-if="addFileDialogVisible"控制显示/隐藏' },
                              { id: '4', name: 'pid属性传递给SAddFileDialog,为空表示在根目录添加,非空表示在指定父节点下添加' },
                              { id: '5', name: 'handleAddFileAndFolderCb调用addFileAndFolderCb函数(来自composables/curd-node)完成实际的节点添加逻辑' },
                              { id: '6', name: '新节点会自动展开其父节点(通过bannerStore.addExpandItem实现)' },
                            ],
                          },
                          {
                            purpose: '鼠标右键空白区域添加http节点(AI)',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: 'banner区域已加载完成,节点树已渲染' },
                              { id: '3', name: '节点树有空白区域可以右键点击' },
                              { id: '4', name: '应用处于独立模式(runtimeStore.networkMode为"offline",isStandalone为true)' },
                              { id: '5', name: 'AI配置已完成(isAiConfigValid()返回true,已配置ApiKey)' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标移动到banner节点树的空白区域(非节点区域)' },
                              { id: '2', name: '点击鼠标右键触发handleWrapContextmenu方法' },
                              { id: '3', name: '观察SContextmenu右键菜单弹出' },
                              { id: '4', name: '在右键菜单中点击"新建接口"选项' },
                              { id: '5', name: '观察SAddFileDialog对话框弹出' },
                              { id: '6', name: '在对话框中输入接口名称(例如:"AI生成的HTTP接口")' },
                              { id: '7', name: '选择接口类型为"HTTP"' },
                              { id: '8', name: '在AI提示词输入框(CodeEditor组件)中输入提示词(例如:"创建一个获取用户列表的接口,GET请求,路径/api/users")' },
                              { id: '9', name: '点击确定按钮保存' },
                              { id: '10', name: '观察loading状态,等待AI处理完成' },
                              { id: '11', name: '观察对话框关闭,新HTTP节点出现在节点树根目录下,且包含AI生成的接口信息' },
                            ],
                            expectedResults: [
                              { id: '1', name: '对话框弹出后,因为isStandalone为true,AI提示词表单项条件渲染(AddFile.vue第24-51行,v-if="isStandalone"为true)' },
                              { id: '2', name: '如果isAiConfigValid()返回true,显示CodeEditor组件用于输入AI提示词' },
                              { id: '3', name: 'CodeEditor组件配置:language为"javascript",auto-height为true,min-height为120,max-height为300' },
                              { id: '4', name: 'CodeEditor的placeholder为"可自动识别自然语言描述,cURL请求,任意类型接口结构数据"' },
                              { id: '5', name: '如果isAiConfigValid()返回false,显示"配置ApiKey"按钮,点击后调用handleOpenAiSettings打开AI设置' },
                              { id: '6', name: '点击确定后,formData.aiPrompt有值时触发AI生成逻辑' },
                              { id: '7', name: 'handleAddFile方法中调用buildAiSystemPromptForNode构建AI系统提示词' },
                              { id: '8', name: '发送AI请求到LLM服务(通过window.electronAPI或API调用)' },
                              { id: '9', name: 'loading.value被设置为true,确定按钮显示loading状态' },
                              { id: '10', name: 'AI返回结果后解析生成HTTP节点的详细信息(URL,请求方法,headers,body等)' },
                              { id: '11', name: '新HTTP节点包含AI生成的完整接口信息,包括路径,方法,参数等' },
                              { id: '12', name: 'handleAddFileAndFolderCb回调被调用,新节点添加到banner树根目录下' },
                              { id: '13', name: 'loading.value被设置为false,对话框关闭' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'AI提示词表单项在AddFile.vue第24-51行' },
                              { id: '2', name: 'isStandalone计算属性定义:computed(() => runtimeStore.networkMode === "offline")' },
                              { id: '3', name: 'isAiConfigValid方法检查AI配置是否有效(ApiKey是否已配置)' },
                              { id: '4', name: 'CodeEditor组件导入在AddFile.vue第72行' },
                              { id: '5', name: 'buildAiSystemPromptForNode函数导入在AddFile.vue第68行' },
                              { id: '6', name: 'formData.aiPrompt存储用户输入的AI提示词' },
                              { id: '7', name: 'handleOpenAiSettings方法打开AI设置页面(router.push到AI settings)' },
                              { id: '8', name: 'ArrowRight图标来自lucide-vue-next库(AddFile.vue第75行)' },
                              { id: '9', name: 'llmProviderCache用于获取LLM配置信息(AddFile.vue第76行)' },
                              { id: '10', name: 'useLLMClientStore用于调用LLM API(AddFile.vue第77行)' },
                            ],
                            notes: [
                              { id: '1', name: 'AI功能仅在独立模式(offline模式)下可用,通过isStandalone判断' },
                              { id: '2', name: 'AI提示词输入框使用CodeEditor组件,支持自动高度调整(120px-300px)' },
                              { id: '3', name: 'AI提示词支持自然语言描述,cURL命令,接口结构数据等多种输入格式' },
                              { id: '4', name: 'buildAiSystemPromptForNode函数负责构建AI系统提示词,将用户输入转换为AI可理解的格式' },
                              { id: '5', name: 'AI生成过程中会显示loading状态,防止用户重复提交' },
                              { id: '6', name: 'AI生成失败时会显示错误提示,不会创建节点' },
                              { id: '7', name: '如果未配置ApiKey,显示"配置ApiKey"按钮,引导用户完成配置' },
                            ],
                          },
                          {
                            purpose: '鼠标右键目录添加http节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: 'banner区域已加载完成,节点树已渲染' },
                              { id: '3', name: '节点树中存在至少一个folder类型节点' },
                              { id: '4', name: 'folder节点内文件数量未达到限制(FILE_IN_FOLDER_LIMIT)' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标移动到banner节点树中的某个folder节点上' },
                              { id: '2', name: '点击鼠标右键触发handleShowContextmenu方法' },
                              { id: '3', name: '观察SContextmenu右键菜单弹出' },
                              { id: '4', name: '在右键菜单中点击"新建接口"选项' },
                              { id: '5', name: '观察SAddFileDialog对话框弹出' },
                              { id: '6', name: '在对话框中输入接口名称' },
                              { id: '7', name: '选择接口类型为"HTTP"' },
                              { id: '8', name: '点击确定按钮保存' },
                              { id: '9', name: '观察对话框关闭,新HTTP节点出现在该folder节点下' },
                            ],
                            expectedResults: [
                              { id: '1', name: '右键folder节点后,handleShowContextmenu方法被触发(Banner.vue第339-362行)' },
                              { id: '2', name: 'currentOperationalNode.value被设置为folder节点数据' },
                              { id: '3', name: 'SContextmenu组件显示,"新建接口"选项可见(v-show="!currentOperationalNode || currentOperationalNode?.type === \'folder\'"为true)' },
                              { id: '4', name: '点击"新建接口"后,handleOpenAddFileDialog方法被调用' },
                              { id: '5', name: 'handleOpenAddFileDialog方法检查folder内文件数量(childFileNodeNum)' },
                              { id: '6', name: '如果childFileNodeNum < FILE_IN_FOLDER_LIMIT,addFileDialogVisible.value被设置为true' },
                              { id: '7', name: '如果childFileNodeNum >= FILE_IN_FOLDER_LIMIT,显示警告message:"单个文件夹里面文档个数不超过X个"' },
                              { id: '8', name: 'SAddFileDialog组件渲染,pid属性为folder节点的_id' },
                              { id: '9', name: '点击确定后,新HTTP节点添加到该folder节点的children数组中' },
                              { id: '10', name: '新HTTP节点显示在folder节点下的最后位置' },
                              { id: '11', name: 'folder节点自动展开,显示新添加的HTTP节点' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleShowContextmenu方法定义在Banner.vue第339-362行' },
                              { id: '2', name: 'el-tree的@node-contextmenu绑定handleShowContextmenu(Banner.vue第23行)' },
                              { id: '3', name: '"新建接口"菜单项的v-show条件:!currentOperationalNode || currentOperationalNode?.type === \'folder\'(Banner.vue第223行)' },
                              { id: '4', name: 'handleOpenAddFileDialog中文件数量检查逻辑在第489行' },
                              { id: '5', name: 'FILE_IN_FOLDER_LIMIT常量定义了单个文件夹内文件数量限制' },
                              { id: '6', name: 'SAddFileDialog的pid属性传递currentOperationalNode?._id(Banner.vue第255行)' },
                              { id: '7', name: 'addFileAndFolderCb函数根据pid将节点添加到对应父节点的children中' },
                              { id: '8', name: 'bannerStore.addExpandItem确保父folder节点展开' },
                            ],
                            notes: [
                              { id: '1', name: '右键folder节点与右键空白区域的区别:currentOperationalNode有值且类型为folder' },
                              { id: '2', name: 'folder内文件数量限制通过childFileNodeNum计算:children.filter(v => v.type !== \'folder\').length' },
                              { id: '3', name: '只统计非folder类型的子节点,folder节点不计入限制' },
                              { id: '4', name: 'pid属性用于确定新节点的父节点,非空时添加到指定父节点下' },
                              { id: '5', name: '新节点添加成功后,父folder节点会自动展开,方便用户查看新添加的节点' },
                            ],
                          },
                          {
                            purpose: '鼠标右键目录添加http节点(AI)',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: 'banner区域已加载完成,节点树已渲染' },
                              { id: '3', name: '节点树中存在至少一个folder类型节点' },
                              { id: '4', name: 'folder节点内文件数量未达到限制' },
                              { id: '5', name: '应用处于独立模式,AI配置已完成' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标移动到folder节点上并右键' },
                              { id: '2', name: '点击"新建接口"选项' },
                              { id: '3', name: '在对话框中输入接口名称' },
                              { id: '4', name: '选择接口类型为"HTTP"' },
                              { id: '5', name: '在AI提示词框中输入提示词' },
                              { id: '6', name: '点击确定按钮' },
                              { id: '7', name: '等待AI处理完成' },
                              { id: '8', name: '观察新HTTP节点出现在folder节点下,包含AI生成的接口信息' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'currentOperationalNode.value为folder节点数据,pid为folder的_id' },
                              { id: '2', name: '对话框显示AI提示词输入框(isStandalone为true)' },
                              { id: '3', name: '填写AI提示词后,点击确定触发AI生成逻辑' },
                              { id: '4', name: 'loading状态显示,等待AI返回结果' },
                              { id: '5', name: 'AI生成完整HTTP接口信息(URL,方法,参数等)' },
                              { id: '6', name: '新HTTP节点添加到folder节点的children数组中' },
                              { id: '7', name: 'folder节点自动展开,显示新添加的节点' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'SAddFileDialog的pid属性为folder节点的_id' },
                              { id: '2', name: 'AI提示词表单项条件渲染(v-if="isStandalone")' },
                              { id: '3', name: 'buildAiSystemPromptForNode构建AI系统提示词' },
                              { id: '4', name: 'addFileAndFolderCb根据pid将节点添加到folder的children中' },
                            ],
                            notes: [
                              { id: '1', name: '结合右键目录和AI功能的综合测试用例' },
                              { id: '2', name: '新节点位置在folder节点下,而非根目录' },
                              { id: '3', name: 'AI生成的节点同样遵循folder内文件数量限制' },
                            ],
                          },
                          {
                            purpose: '点击新增按钮添加http节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: 'banner区域已加载完成' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击banner顶部工具栏的"新增文件"按钮' },
                              { id: '2', name: '观察SAddFileDialog对话框弹出' },
                              { id: '3', name: '输入接口名称' },
                              { id: '4', name: '选择接口类型为"HTTP"' },
                              { id: '5', name: '点击确定按钮' },
                              { id: '6', name: '观察新HTTP节点出现在节点树根目录下' },
                            ],
                            expectedResults: [
                              { id: '1', name: '点击"新增文件"按钮后,handleEmit方法被调用,参数为"addRootFile"(Tool.vue第290-292行)' },
                              { id: '2', name: 'addFileDialogVisible.value被设置为true' },
                              { id: '3', name: 'SAddFileDialog组件渲染,pid为空(在根目录添加)' },
                              { id: '4', name: '点击确定后,新HTTP节点添加到banner树根目录下' },
                              { id: '5', name: '新节点显示在根目录最下方' },
                            ],
                            checkpoints: [
                              { id: '1', name: '"新增文件"按钮在Tool.vue中,icon为"#iconwenjian",op为"addRootFile"' },
                              { id: '2', name: 'handleEmit中addRootFile分支在Tool.vue第290-292行' },
                              { id: '3', name: 'SAddFileDialog的pid属性为空字符串' },
                              { id: '4', name: 'addFileAndFolderCb根据pid为空将节点添加到根目录' },
                            ],
                            notes: [
                              { id: '1', name: '通过工具栏按钮添加与右键空白区域添加效果相同,都是在根目录添加' },
                              { id: '2', name: '工具栏按钮是从Tool.vue组件触发,而非Banner.vue' },
                              { id: '3', name: 'Tool.vue的handleEmit方法设置addFileDialogVisible,Banner.vue监听并显示对话框' },
                            ],
                          },
                          {
                            purpose: '点击新增按钮添加http节点(AI)',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: 'banner区域已加载完成' },
                              { id: '3', name: '应用处于独立模式,AI配置已完成' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击banner顶部工具栏的"新增文件"按钮' },
                              { id: '2', name: '观察SAddFileDialog对话框弹出' },
                              { id: '3', name: '输入接口名称' },
                              { id: '4', name: '选择接口类型为"HTTP"' },
                              { id: '5', name: '在AI提示词框中输入提示词' },
                              { id: '6', name: '点击确定按钮' },
                              { id: '7', name: '等待AI处理完成' },
                              { id: '8', name: '观察新HTTP节点出现在节点树根目录下,包含AI生成的接口信息' },
                            ],
                            expectedResults: [
                              { id: '1', name: '对话框显示AI提示词输入框(isStandalone为true)' },
                              { id: '2', name: '填写AI提示词后,点击确定触发AI生成逻辑' },
                              { id: '3', name: 'loading状态显示,等待AI返回结果' },
                              { id: '4', name: 'AI生成完整HTTP接口信息' },
                              { id: '5', name: '新HTTP节点添加到根目录下' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'SAddFileDialog的pid属性为空字符串(根目录)' },
                              { id: '2', name: 'AI提示词表单项条件渲染(v-if="isStandalone")' },
                              { id: '3', name: 'buildAiSystemPromptForNode构建AI系统提示词' },
                            ],
                            notes: [
                              { id: '1', name: '通过工具栏按钮添加,结合AI功能' },
                              { id: '2', name: '新节点位置在根目录' },
                              { id: '3', name: 'AI功能与添加方式(工具栏/右键)无关,只与isStandalone有关' },
                            ],
                          },
                        ],
                      },
                      {
                        modelName: 'websocketNode',
                        description: 'websocket节点',
                        atomicFunc: [
                          {
                            purpose: '鼠标右键空白区域添加websocket节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: 'banner区域已加载完成,节点树已渲染' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标右键空白区域' },
                              { id: '2', name: '点击"新建接口"' },
                              { id: '3', name: '输入接口名称' },
                              { id: '4', name: '选择接口类型为"WebSocket"' },
                              { id: '5', name: '点击确定' },
                              { id: '6', name: '观察新WebSocket节点出现在根目录下' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'SAddFileDialog对话框弹出,formData.type选择为"websocket"' },
                              { id: '2', name: '点击确定后调用generateEmptyWebsocketNode生成WebSocket节点' },
                              { id: '3', name: '新WebSocket节点添加到根目录,包含默认的WebSocket配置(URL,连接参数等)' },
                              { id: '4', name: '节点显示WebSocket图标和用户输入的名称' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'AddFile.vue第19行:<el-radio value="websocket">WebSocket</el-radio>' },
                              { id: '2', name: 'generateEmptyWebsocketNode函数导入在AddFile.vue第68行' },
                              { id: '3', name: '新节点type属性为"websocket"' },
                            ],
                            notes: [
                              { id: '1', name: '与HTTP节点添加流程相同,唯一区别是接口类型选择WebSocket' },
                              { id: '2', name: 'generateEmptyWebsocketNode生成的节点包含WebSocket特有的配置字段' },
                            ],
                          },
                          {
                            purpose: '鼠标右键空白区域添加websocket节点(AI)',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '应用处于独立模式,AI配置已完成' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标右键空白区域' },
                              { id: '2', name: '点击"新建接口"' },
                              { id: '3', name: '输入接口名称' },
                              { id: '4', name: '选择接口类型为"WebSocket"' },
                              { id: '5', name: '在AI提示词框中输入WebSocket相关提示词' },
                              { id: '6', name: '点击确定,等待AI处理' },
                              { id: '7', name: '观察新WebSocket节点出现,包含AI生成的配置' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'AI提示词框显示(isStandalone为true)' },
                              { id: '2', name: 'AI根据提示词生成WebSocket连接URL,消息格式等配置' },
                              { id: '3', name: '新WebSocket节点包含AI生成的完整配置信息' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'formData.type为"websocket"' },
                              { id: '2', name: 'formData.aiPrompt包含用户输入的AI提示词' },
                              { id: '3', name: 'buildAiSystemPromptForNode处理WebSocket类型节点' },
                            ],
                            notes: [
                              { id: '1', name: 'AI可以生成WebSocket特定的配置,如连接参数,消息模板等' },
                            ],
                          },
                          {
                            purpose: '鼠标右键目录添加websocket节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '节点树中存在folder节点' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标右键folder节点' },
                              { id: '2', name: '点击"新建接口"' },
                              { id: '3', name: '输入接口名称' },
                              { id: '4', name: '选择接口类型为"WebSocket"' },
                              { id: '5', name: '点击确定' },
                              { id: '6', name: '观察新WebSocket节点出现在folder节点下' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'SAddFileDialog的pid为folder节点的_id' },
                              { id: '2', name: '新WebSocket节点添加到folder的children数组中' },
                              { id: '3', name: 'folder节点自动展开' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'currentOperationalNode.value为folder节点数据' },
                              { id: '2', name: 'addFileAndFolderCb根据pid将节点添加到folder下' },
                            ],
                            notes: [
                              { id: '1', name: '遵循folder内文件数量限制' },
                            ],
                          },
                          {
                            purpose: '鼠标右键目录添加websocket节点(AI)',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '节点树中存在folder节点' },
                              { id: '3', name: '应用处于独立模式,AI配置已完成' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标右键folder节点' },
                              { id: '2', name: '点击"新建接口"' },
                              { id: '3', name: '输入接口名称,选择"WebSocket"类型' },
                              { id: '4', name: '输入AI提示词' },
                              { id: '5', name: '点击确定,等待AI处理' },
                              { id: '6', name: '观察新WebSocket节点出现在folder下' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'pid为folder的_id,AI生成的WebSocket节点添加到folder下' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'formData.type为"websocket",formData.aiPrompt有值' },
                            ],
                            notes: [
                              { id: '1', name: '结合folder和AI功能的WebSocket节点创建' },
                            ],
                          },
                          {
                            purpose: '点击新增按钮添加websocket节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击工具栏"新增文件"按钮' },
                              { id: '2', name: '输入接口名称' },
                              { id: '3', name: '选择接口类型为"WebSocket"' },
                              { id: '4', name: '点击确定' },
                              { id: '5', name: '观察新WebSocket节点出现在根目录' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'handleEmit("addRootFile")触发,addFileDialogVisible为true' },
                              { id: '2', name: 'SAddFileDialog的pid为空,新WebSocket节点添加到根目录' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'Tool.vue的"新增文件"按钮op为"addRootFile"' },
                            ],
                            notes: [
                              { id: '1', name: '通过工具栏按钮添加WebSocket节点到根目录' },
                            ],
                          },
                          {
                            purpose: '点击新增按钮添加websocket节点(AI)',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '应用处于独立模式,AI配置已完成' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击工具栏"新增文件"按钮' },
                              { id: '2', name: '输入接口名称,选择"WebSocket"类型' },
                              { id: '3', name: '输入AI提示词' },
                              { id: '4', name: '点击确定,等待AI处理' },
                              { id: '5', name: '观察新WebSocket节点出现在根目录,包含AI生成的配置' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'AI生成WebSocket节点配置并添加到根目录' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'pid为空,formData.type为"websocket",formData.aiPrompt有值' },
                            ],
                            notes: [
                              { id: '1', name: '工具栏按钮结合AI功能创建WebSocket节点' },
                            ],
                          },
                        ],
                      },
                      {
                        modelName: 'httpMockNode',
                        description: 'http mock节点',
                        atomicFunc: [
                          {
                            purpose: '鼠标右键空白区域添加httpMock节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: 'banner区域已加载完成' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标右键空白区域' },
                              { id: '2', name: '点击"新建接口"' },
                              { id: '3', name: '输入接口名称' },
                              { id: '4', name: '选择接口类型为"HTTP Mock"' },
                              { id: '5', name: '点击确定' },
                              { id: '6', name: '观察新HTTP Mock节点出现在根目录' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'formData.type选择为"httpMock"' },
                              { id: '2', name: '调用generateEmptyHttpMockNode生成HTTP Mock节点' },
                              { id: '3', name: '新节点包含Mock服务器配置(端口,路径,响应规则等)' },
                              { id: '4', name: '节点显示Mock图标和用户输入的名称' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'AddFile.vue第20行:<el-radio value="httpMock">HTTP Mock</el-radio>' },
                              { id: '2', name: 'generateEmptyHttpMockNode函数导入在AddFile.vue第68行' },
                              { id: '3', name: '新节点type属性为"httpMock"' },
                            ],
                            notes: [
                              { id: '1', name: 'HTTP Mock节点用于模拟HTTP服务器响应' },
                              { id: '2', name: 'generateEmptyHttpMockNode生成包含Mock规则的默认配置' },
                            ],
                          },
                          {
                            purpose: '鼠标右键空白区域添加httpMock节点(AI)',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '应用处于独立模式,AI配置已完成' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标右键空白区域' },
                              { id: '2', name: '点击"新建接口"' },
                              { id: '3', name: '输入接口名称,选择"HTTP Mock"类型' },
                              { id: '4', name: '在AI提示词框中输入Mock规则描述' },
                              { id: '5', name: '点击确定,等待AI处理' },
                              { id: '6', name: '观察新HTTP Mock节点出现,包含AI生成的Mock配置' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'AI根据提示词生成Mock路径,响应数据,状态码等配置' },
                              { id: '2', name: '新节点包含完整的Mock服务器规则' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'formData.type为"httpMock",formData.aiPrompt有值' },
                              { id: '2', name: 'buildAiSystemPromptForNode处理HTTP Mock类型节点' },
                            ],
                            notes: [
                              { id: '1', name: 'AI可以生成Mock响应数据,条件匹配规则等' },
                            ],
                          },
                          {
                            purpose: '鼠标右键目录添加httpMock节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '节点树中存在folder节点' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标右键folder节点' },
                              { id: '2', name: '点击"新建接口"' },
                              { id: '3', name: '输入接口名称,选择"HTTP Mock"类型' },
                              { id: '4', name: '点击确定' },
                              { id: '5', name: '观察新HTTP Mock节点出现在folder下' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'SAddFileDialog的pid为folder的_id' },
                              { id: '2', name: '新HTTP Mock节点添加到folder的children中' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'addFileAndFolderCb根据pid将节点添加到folder下' },
                            ],
                            notes: [
                              { id: '1', name: '遵循folder内文件数量限制' },
                            ],
                          },
                          {
                            purpose: '鼠标右键目录添加httpMock节点(AI)',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '节点树中存在folder节点' },
                              { id: '3', name: '应用处于独立模式,AI配置已完成' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标右键folder节点' },
                              { id: '2', name: '点击"新建接口",选择"HTTP Mock"类型' },
                              { id: '3', name: '输入AI提示词' },
                              { id: '4', name: '点击确定,等待AI处理' },
                              { id: '5', name: '观察新HTTP Mock节点出现在folder下' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'AI生成的HTTP Mock节点添加到folder下' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'pid为folder的_id,formData.type为"httpMock"' },
                            ],
                            notes: [
                              { id: '1', name: '结合folder和AI功能的HTTP Mock节点创建' },
                            ],
                          },
                          {
                            purpose: '点击新增按钮添加httpMock节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击工具栏"新增文件"按钮' },
                              { id: '2', name: '输入接口名称,选择"HTTP Mock"类型' },
                              { id: '3', name: '点击确定' },
                              { id: '4', name: '观察新HTTP Mock节点出现在根目录' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'handleEmit("addRootFile")触发' },
                              { id: '2', name: '新HTTP Mock节点添加到根目录' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'SAddFileDialog的pid为空' },
                            ],
                            notes: [
                              { id: '1', name: '通过工具栏按钮添加HTTP Mock节点到根目录' },
                            ],
                          },
                          {
                            purpose: '点击新增按钮添加httpMock节点(AI)',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '应用处于独立模式,AI配置已完成' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击工具栏"新增文件"按钮' },
                              { id: '2', name: '输入接口名称,选择"HTTP Mock"类型' },
                              { id: '3', name: '输入AI提示词' },
                              { id: '4', name: '点击确定,等待AI处理' },
                              { id: '5', name: '观察新HTTP Mock节点出现在根目录' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'AI生成HTTP Mock配置并添加到根目录' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'pid为空,formData.type为"httpMock",formData.aiPrompt有值' },
                            ],
                            notes: [
                              { id: '1', name: '工具栏按钮结合AI功能创建HTTP Mock节点' },
                            ],
                          },
                        ],
                      },
                      {
                        modelName: 'websocketMockNode',
                        description: 'websocket mock节点',
                        atomicFunc: [
                          {
                            purpose: '鼠标右键空白区域添加websocketMock节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: 'banner区域已加载完成' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标右键空白区域' },
                              { id: '2', name: '点击"新建接口"' },
                              { id: '3', name: '输入接口名称' },
                              { id: '4', name: '选择接口类型为"WebSocket Mock"' },
                              { id: '5', name: '点击确定' },
                              { id: '6', name: '观察新WebSocket Mock节点出现在根目录' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'formData.type选择为"websocketMock"' },
                              { id: '2', name: '调用generateEmptyWebSocketMockNode生成WebSocket Mock节点' },
                              { id: '3', name: '新节点包含WebSocket Mock服务器配置(端口,路径,消息规则等)' },
                              { id: '4', name: '节点显示WebSocket Mock图标和用户输入的名称' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'AddFile.vue第21行:<el-radio value="websocketMock">WebSocket Mock</el-radio>' },
                              { id: '2', name: 'generateEmptyWebSocketMockNode函数导入在AddFile.vue第68行' },
                              { id: '3', name: '新节点type属性为"websocketMock"' },
                            ],
                            notes: [
                              { id: '1', name: 'WebSocket Mock节点用于模拟WebSocket服务器' },
                              { id: '2', name: 'generateEmptyWebSocketMockNode生成包含WebSocket Mock规则的默认配置' },
                            ],
                          },
                          {
                            purpose: '鼠标右键空白区域添加websocketMock节点(AI)',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '应用处于独立模式,AI配置已完成' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标右键空白区域' },
                              { id: '2', name: '点击"新建接口"' },
                              { id: '3', name: '输入接口名称,选择"WebSocket Mock"类型' },
                              { id: '4', name: '在AI提示词框中输入WebSocket Mock规则描述' },
                              { id: '5', name: '点击确定,等待AI处理' },
                              { id: '6', name: '观察新WebSocket Mock节点出现,包含AI生成的配置' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'AI根据提示词生成WebSocket Mock消息格式,事件处理等配置' },
                              { id: '2', name: '新节点包含完整的WebSocket Mock服务器规则' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'formData.type为"websocketMock",formData.aiPrompt有值' },
                              { id: '2', name: 'buildAiSystemPromptForNode处理WebSocket Mock类型节点' },
                            ],
                            notes: [
                              { id: '1', name: 'AI可以生成WebSocket Mock消息模板,事件响应规则等' },
                            ],
                          },
                          {
                            purpose: '鼠标右键目录添加websocketMock节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '节点树中存在folder节点' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标右键folder节点' },
                              { id: '2', name: '点击"新建接口"' },
                              { id: '3', name: '输入接口名称,选择"WebSocket Mock"类型' },
                              { id: '4', name: '点击确定' },
                              { id: '5', name: '观察新WebSocket Mock节点出现在folder下' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'SAddFileDialog的pid为folder的_id' },
                              { id: '2', name: '新WebSocket Mock节点添加到folder的children中' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'addFileAndFolderCb根据pid将节点添加到folder下' },
                            ],
                            notes: [
                              { id: '1', name: '遵循folder内文件数量限制' },
                            ],
                          },
                          {
                            purpose: '鼠标右键目录添加websocketMock节点(AI)',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '节点树中存在folder节点' },
                              { id: '3', name: '应用处于独立模式,AI配置已完成' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标右键folder节点' },
                              { id: '2', name: '点击"新建接口",选择"WebSocket Mock"类型' },
                              { id: '3', name: '输入AI提示词' },
                              { id: '4', name: '点击确定,等待AI处理' },
                              { id: '5', name: '观察新WebSocket Mock节点出现在folder下' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'AI生成的WebSocket Mock节点添加到folder下' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'pid为folder的_id,formData.type为"websocketMock"' },
                            ],
                            notes: [
                              { id: '1', name: '结合folder和AI功能的WebSocket Mock节点创建' },
                            ],
                          },
                          {
                            purpose: '点击新增按钮添加websocketMock节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击工具栏"新增文件"按钮' },
                              { id: '2', name: '输入接口名称,选择"WebSocket Mock"类型' },
                              { id: '3', name: '点击确定' },
                              { id: '4', name: '观察新WebSocket Mock节点出现在根目录' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'handleEmit("addRootFile")触发' },
                              { id: '2', name: '新WebSocket Mock节点添加到根目录' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'SAddFileDialog的pid为空' },
                            ],
                            notes: [
                              { id: '1', name: '通过工具栏按钮添加WebSocket Mock节点到根目录' },
                            ],
                          },
                          {
                            purpose: '点击新增按钮添加websocketMock节点(AI)',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '应用处于独立模式,AI配置已完成' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击工具栏"新增文件"按钮' },
                              { id: '2', name: '输入接口名称,选择"WebSocket Mock"类型' },
                              { id: '3', name: '输入AI提示词' },
                              { id: '4', name: '点击确定,等待AI处理' },
                              { id: '5', name: '观察新WebSocket Mock节点出现在根目录' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'AI生成WebSocket Mock配置并添加到根目录' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'pid为空,formData.type为"websocketMock",formData.aiPrompt有值' },
                            ],
                            notes: [
                              { id: '1', name: '工具栏按钮结合AI功能创建WebSocket Mock节点' },
                            ],
                          },
                        ],
                      },
                      {
                        modelName: 'folderNode',
                        description: 'folder节点',
                        atomicFunc: [
                          {
                            purpose: '鼠标右键空白区域添加folder节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: 'banner区域已加载完成' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标右键banner树的空白区域' },
                              { id: '2', name: '点击右键菜单中的"新建文件夹"选项' },
                              { id: '3', name: '在SAddFolderDialog对话框中输入文件夹名称' },
                              { id: '4', name: '点击确定按钮' },
                              { id: '5', name: '观察新folder节点出现在根目录下' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'handleWrapContextmenu方法被触发,currentOperationalNode.value为null' },
                              { id: '2', name: '右键菜单显示"新建文件夹"选项(v-show="!currentOperationalNode || currentOperationalNode?.type === \'folder\'")' },
                              { id: '3', name: '点击"新建文件夹"后,handleOpenAddFolderDialog方法被调用(Banner.vue第499-501行)' },
                              { id: '4', name: 'addFolderDialogVisible.value被设置为true' },
                              { id: '5', name: 'SAddFolderDialog组件渲染,pid为空(在根目录添加)' },
                              { id: '6', name: '新folder节点添加到根目录最下方' },
                            ],
                            checkpoints: [
                              { id: '1', name: '"新建文件夹"菜单项绑定:@click="handleOpenAddFolderDialog"(Banner.vue第225-226行)' },
                              { id: '2', name: 'handleOpenAddFolderDialog方法在Banner.vue第499-501行' },
                              { id: '3', name: 'SAddFolderDialog组件引用在Banner.vue第257-258行' },
                              { id: '4', name: 'SAddFolderDialog的pid属性为currentOperationalNode?._id(空白区域时为undefined)' },
                            ],
                            notes: [
                              { id: '1', name: 'folder节点用于组织和分组其他节点,可以包含接口节点和子folder节点' },
                              { id: '2', name: '新建文件夹不需要选择类型,只需输入名称' },
                            ],
                          },
                          {
                            purpose: '鼠标右键目录添加folder节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '节点树中存在至少一个folder节点' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标右键某个folder节点' },
                              { id: '2', name: '点击"新建文件夹"选项' },
                              { id: '3', name: '输入文件夹名称' },
                              { id: '4', name: '点击确定' },
                              { id: '5', name: '观察新folder节点出现在父folder节点下' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'currentOperationalNode.value为父folder节点数据' },
                              { id: '2', name: 'SAddFolderDialog的pid为父folder的_id' },
                              { id: '3', name: '新folder节点添加到父folder的children数组中' },
                              { id: '4', name: '父folder节点自动展开,显示新添加的子folder' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleOpenAddFolderDialog方法不检查文件数量限制(folder不计入限制)' },
                              { id: '2', name: 'addFileAndFolderCb根据pid将folder添加到指定父节点下' },
                            ],
                            notes: [
                              { id: '1', name: 'folder可以嵌套,支持多层级结构' },
                            ],
                          },
                          {
                            purpose: '在folder节点上,点击新增按钮添加folder节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '节点树中存在folder节点' },
                              { id: '3', name: 'folder节点有"更多操作"按钮' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标悬停在folder节点上' },
                              { id: '2', name: '点击folder节点的"更多操作"按钮(data-testid="banner-node-more-btn")' },
                              { id: '3', name: '在弹出的右键菜单中点击"新建文件夹"' },
                              { id: '4', name: '输入文件夹名称' },
                              { id: '5', name: '点击确定' },
                              { id: '6', name: '观察新folder节点出现在该folder下' },
                            ],
                            expectedResults: [
                              { id: '1', name: '"更多操作"按钮点击触发handleShowContextmenu方法(@click.stop绑定)' },
                              { id: '2', name: 'currentOperationalNode.value为folder节点数据' },
                              { id: '3', name: '右键菜单显示,"新建文件夹"选项可见' },
                              { id: '4', name: '新folder添加到父folder的children中' },
                            ],
                            checkpoints: [
                              { id: '1', name: '"更多操作"按钮在Banner.vue第58-62行(folder类型)或第133-137行' },
                              { id: '2', name: '按钮绑定:@click.stop="handleShowContextmenu($event, scope.data)"' },
                            ],
                            notes: [
                              { id: '1', name: '通过"更多操作"按钮和右键点击节点效果相同' },
                            ],
                          },
                          {
                            purpose: '点击新增按钮添加folder节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击工具栏"新增文件夹"按钮' },
                              { id: '2', name: '输入文件夹名称' },
                              { id: '3', name: '点击确定' },
                              { id: '4', name: '观察新folder节点出现在根目录' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'handleEmit("addRootFolder")触发(Tool.vue第287-289行)' },
                              { id: '2', name: 'addFolderDialogVisible.value被设置为true' },
                              { id: '3', name: 'SAddFolderDialog的pid为空,新folder添加到根目录' },
                            ],
                            checkpoints: [
                              { id: '1', name: '"新增文件夹"按钮在Tool.vue中,icon为"#iconxinzengwenjian",op为"addRootFolder"' },
                              { id: '2', name: 'handleEmit中addRootFolder分支在Tool.vue第287-289行' },
                            ],
                            notes: [
                              { id: '1', name: '通过工具栏按钮添加folder到根目录' },
                            ],
                          },
                        ],
                      },
                      {
                        modelName: '边界情况测试',
                        description: '边界情况测试',
                        atomicFunc: [
                          {
                            purpose: '鼠标右键非folder节点不出现新建接口选项',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '节点树中存在非folder类型的节点(如HTTP,WebSocket等接口节点)' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标右键点击一个HTTP接口节点' },
                              { id: '2', name: '观察右键菜单内容' },
                              { id: '3', name: '验证"新建接口"选项不显示' },
                              { id: '4', name: '重复操作WebSocket,HTTP Mock,WebSocket Mock等非folder节点' },
                              { id: '5', name: '验证所有非folder节点右键菜单都不显示"新建接口"选项' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'handleShowContextmenu方法被触发,currentOperationalNode.value为接口节点数据' },
                              { id: '2', name: 'currentOperationalNode.type不等于"folder"' },
                              { id: '3', name: '"新建接口"菜单项的v-show条件:!currentOperationalNode || currentOperationalNode?.type === \'folder\'为false' },
                              { id: '4', name: '"新建接口"选项不渲染(v-show为false)' },
                              { id: '5', name: '右键菜单显示其他选项:剪切,复制,生成副本,重命名,删除等' },
                              { id: '6', name: '"新建文件夹"选项同样不显示(使用相同的v-show条件)' },
                            ],
                            checkpoints: [
                              { id: '1', name: '"新建接口"菜单项v-show条件在Banner.vue第223行' },
                              { id: '2', name: '"新建文件夹"菜单项v-show条件在Banner.vue第225行' },
                              { id: '3', name: '两个菜单项使用相同的显示条件:!currentOperationalNode || currentOperationalNode?.type === \'folder\'' },
                              { id: '4', name: '当currentOperationalNode存在且type不为folder时,v-show为false' },
                            ],
                            notes: [
                              { id: '1', name: '非folder节点不能作为父节点添加子节点,因此不显示"新建接口"和"新建文件夹"选项' },
                              { id: '2', name: '这是一个重要的边界情况测试,确保UI逻辑正确性' },
                              { id: '3', name: '右键菜单会根据节点类型动态显示/隐藏选项' },
                            ],
                          },
                          {
                            purpose: '非folder节点点击更多按钮不出现新建接口选项',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '节点树中存在非folder类型的节点' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标悬停在一个HTTP接口节点上' },
                              { id: '2', name: '点击节点的"更多操作"按钮' },
                              { id: '3', name: '观察弹出的菜单内容' },
                              { id: '4', name: '验证"新建接口"和"新建文件夹"选项不显示' },
                              { id: '5', name: '重复操作其他非folder类型节点,验证结果一致' },
                            ],
                            expectedResults: [
                              { id: '1', name: '"更多操作"按钮点击触发handleShowContextmenu方法' },
                              { id: '2', name: 'currentOperationalNode.value为接口节点数据,type不为"folder"' },
                              { id: '3', name: '右键菜单显示,但"新建接口"和"新建文件夹"选项不显示(v-show为false)' },
                              { id: '4', name: '菜单显示其他可用选项:剪切,复制,生成副本,重命名,删除' },
                            ],
                            checkpoints: [
                              { id: '1', name: '"更多操作"按钮绑定:@click.stop="handleShowContextmenu($event, scope.data)"' },
                              { id: '2', name: 'handleShowContextmenu方法设置currentOperationalNode为当前节点数据' },
                              { id: '3', name: '右键菜单使用相同的v-show条件判断选项显示' },
                            ],
                            notes: [
                              { id: '1', name: '"更多操作"按钮和右键点击触发相同的方法,菜单显示逻辑完全一致' },
                              { id: '2', name: '这个测试用例验证通过"更多操作"按钮触发的边界情况与右键触发的边界情况一致' },
                            ],
                          },
                        ],
                      },
                    ],
                  },
                  //删除节点
                  {
                    modelName: 'deleteNode',
                    description: '删除节点',
                    children: [
                      {
                        modelName: '删除httpNode',
                        description: '删除httpNode节点',
                        atomicFunc: [
                          {
                            purpose: '鼠标右键httpNode节点删除',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个httpNode节点' },
                              { id: '3', name: 'bannerStore.banner数组中包含待删除的httpNode节点数据' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到目标httpNode节点' },
                              { id: '2', name: '鼠标右键点击该httpNode节点' },
                              { id: '3', name: '在弹出的SContextmenu右键菜单中找到"删除"选项(hot-key提示:Delete)' },
                              { id: '4', name: '点击"删除"菜单项' },
                              { id: '5', name: '在弹出的ElMessageBox确认对话框中查看提示文字:确定删除 [节点名称] 节点' },
                              { id: '6', name: '点击"确定"按钮确认删除' },
                            ],
                            expectedResults: [
                              { id: '1', name: '点击右键后立即显示右键菜单,菜单中包含"删除"选项且显示快捷键提示"Delete"' },
                              { id: '2', name: '点击"删除"后弹出确认对话框,对话框类型为warning,标题为"提示"' },
                              { id: '3', name: '确认对话框中显示文字:确定删除 [节点名称] 节点' },
                              { id: '4', name: '点击"确定"后节点立即从banner文档树中移除,不再显示' },
                              { id: '5', name: '如果删除的节点当前处于active状态,删除后编辑区域清空或切换到其他节点' },
                              { id: '6', name: '如果该节点在projectNavStore的nav列表中,对应的nav项也被删除' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleShowContextmenu方法(Banner.vue:339-362)正确处理右键点击事件' },
                              { id: '2', name: 'currentOperationalNode.value被设置为当前右键点击的httpNode节点' },
                              { id: '3', name: 'showContextmenu.value设置为true,contextmenuLeft和contextmenuTop设置为鼠标位置' },
                              { id: '4', name: 'SContextmenu组件条件渲染(Banner.vue:221,v-if="showContextmenu && selectNodes.length <= 1")' },
                              { id: '5', name: '"删除"菜单项条件显示(Banner.vue:243,v-show="currentOperationalNode")' },
                              { id: '6', name: '点击"删除"触发handleDeleteNodes方法(Banner.vue:526-527)' },
                              { id: '7', name: 'handleDeleteNodes内部调用deleteNode函数,传入selectNodes.value数组' },
                              { id: '8', name: 'deleteNode函数(curd-node.ts:33-133)收集deleteIds数组,包含节点_id' },
                              { id: '9', name: 'ElMessageBox.confirm显示确认对话框(curd-node.ts:121-132)' },
                              { id: '10', name: '离线模式:调用apiNodesCache.deleteNodes(deleteIds)删除IndexedDB中的节点数据' },
                              { id: '11', name: '在线模式:调用request.delete("/api/project/doc", params)删除服务器节点数据' },
                              { id: '12', name: 'bannerStore.splice方法从banner数组中移除节点(curd-node.ts:81-84)' },
                              { id: '13', name: 'projectNavStore.deleteNavByIds删除nav项(curd-node.ts:107-111)' },
                              { id: '14', name: '触发eventEmitter.emit("apidoc/deleteDocs")事件(curd-node.ts:112)' },
                            ],
                            notes: [
                              { id: '1', name: '右键菜单通过@node-contextmenu事件绑定到el-tree组件' },
                              { id: '2', name: 'deleteNode函数支持单个或多个节点删除,通过selectNodes数组参数传入' },
                              { id: '3', name: '删除操作需要用户确认,使用ElMessageBox.confirm组件' },
                              { id: '4', name: '删除httpNode时不会递归删除子节点(因为httpNode不是folder类型)' },
                              { id: '5', name: 'projectNavStore.deleteNavByIds只删除非folder类型节点的nav项(curd-node.ts:102-105)' },
                            ],
                          },
                          {
                            purpose: '鼠标移动到httpNode节点,点击更多操作删除节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个httpNode节点' },
                              { id: '3', name: 'bannerStore.banner数组中包含待删除的httpNode节点数据' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到目标httpNode节点' },
                              { id: '2', name: '将鼠标移动到该httpNode节点上(触发@mouseenter.stop="handleNodeHover"事件)' },
                              { id: '3', name: '观察节点右侧出现"更多操作"按钮(.more元素,包含MoreFilled图标)' },
                              { id: '4', name: '点击"更多操作"按钮(data-testid="banner-node-more-btn")' },
                              { id: '5', name: '在弹出的右键菜单中找到"删除"选项' },
                              { id: '6', name: '点击"删除"菜单项' },
                              { id: '7', name: '在弹出的ElMessageBox确认对话框中点击"确定"按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: '鼠标悬停节点时,节点右侧显示"更多操作"按钮,按钮包含MoreFilled图标' },
                              { id: '2', name: '点击"更多操作"按钮后显示右键菜单,菜单内容与右键节点相同' },
                              { id: '3', name: '菜单中包含"删除"选项,显示快捷键提示"Delete"' },
                              { id: '4', name: '点击"删除"后弹出确认对话框,对话框类型为warning' },
                              { id: '5', name: '点击"确定"后节点立即从banner文档树中移除' },
                              { id: '6', name: '节点对应的nav项从projectNavStore中删除' },
                              { id: '7', name: '离线模式下IndexedDB中的节点数据被删除,在线模式下服务器数据被删除' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'httpNode节点渲染包含.more按钮(Banner.vue:58-62)' },
                              { id: '2', name: '.more按钮绑定@click.stop事件,阻止冒泡并调用handleShowContextmenu' },
                              { id: '3', name: 'handleShowContextmenu($event, scope.data)接收节点数据作为参数' },
                              { id: '4', name: 'currentOperationalNode.value被设置为点击的httpNode节点' },
                              { id: '5', name: 'showContextmenu.value设置为true' },
                              { id: '6', name: 'contextmenuLeft和contextmenuTop设置为$event.clientX和$event.clientY' },
                              { id: '7', name: 'SContextmenu组件根据showContextmenu和selectNodes.length条件渲染' },
                              { id: '8', name: '点击"删除"触发handleDeleteNodes方法' },
                              { id: '9', name: 'deleteNode函数执行删除逻辑,包含确认对话框' },
                              { id: '10', name: 'bannerStore.splice从数组中移除节点数据' },
                              { id: '11', name: 'projectNavStore.deleteNavByIds删除nav项' },
                              { id: '12', name: '触发apidoc/deleteDocs事件' },
                            ],
                            notes: [
                              { id: '1', name: '更多操作按钮通过@mouseenter事件触发显示,鼠标悬停时可见' },
                              { id: '2', name: '点击更多操作按钮和右键节点最终都调用同一个handleShowContextmenu方法' },
                              { id: '3', name: '更多操作按钮使用@click.stop阻止事件冒泡,避免触发节点点击事件' },
                              { id: '4', name: 'data-testid="banner-node-more-btn"可用于E2E测试定位按钮元素' },
                              { id: '5', name: '删除操作的后续流程与右键删除完全相同,复用deleteNode函数' },
                            ],
                          },
                          {
                            purpose: '按住ctrl鼠标左键批量选择httpNode节点,鼠标右键批量删除',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少2个httpNode节点' },
                              { id: '3', name: 'bannerStore.banner数组中包含多个待删除的httpNode节点数据' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到多个目标httpNode节点' },
                              { id: '2', name: '按住键盘上的Ctrl键不放' },
                              { id: '3', name: '按住Ctrl键的同时,依次鼠标左键点击第一个httpNode节点' },
                              { id: '4', name: '观察第一个节点被选中,节点添加.select-node类名高亮显示' },
                              { id: '5', name: '继续按住Ctrl键,鼠标左键点击第二个httpNode节点' },
                              { id: '6', name: '观察第二个节点也被选中,两个节点同时高亮显示' },
                              { id: '7', name: '继续按住Ctrl键,可以点击更多httpNode节点进行多选' },
                              { id: '8', name: '释放Ctrl键,在任意一个已选中的节点上点击鼠标右键' },
                              { id: '9', name: '在弹出的批量操作右键菜单中找到"批量删除"选项(hot-key:Delete)' },
                              { id: '10', name: '点击"批量删除"菜单项' },
                              { id: '11', name: '在弹出的ElMessageBox确认对话框中查看提示文字:确定批量删除 [数量] 个节点?' },
                              { id: '12', name: '点击"确定"按钮确认批量删除' },
                            ],
                            expectedResults: [
                              { id: '1', name: '按住Ctrl键点击节点时,事件冒泡被阻止(e.stopPropagation),不触发文件夹展开' },
                              { id: '2', name: '每次按住Ctrl键点击节点后,节点添加.select-node类名,背景色变化表示选中状态' },
                              { id: '3', name: 'selectNodes.value数组包含所有选中的节点对象,数组长度等于选中节点数量' },
                              { id: '4', name: '再次按住Ctrl键点击已选中的节点,该节点被取消选中,从selectNodes数组中移除' },
                              { id: '5', name: '右键点击已选中节点后显示批量操作菜单(v-if="showContextmenu && selectNodes.length > 1")' },
                              { id: '6', name: '批量操作菜单包含"批量剪切","批量复制","批量删除"三个选项' },
                              { id: '7', name: '点击"批量删除"后确认对话框显示总删除数量(包括所有选中节点)' },
                              { id: '8', name: '点击"确定"后所有选中的节点同时从banner文档树中移除' },
                              { id: '9', name: '所有被删除节点的nav项从projectNavStore中批量删除' },
                              { id: '10', name: '离线模式下所有节点数据从IndexedDB批量删除,在线模式下通过一次API请求批量删除' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'pressCtrl变量(Banner.vue:387)跟踪Ctrl键按下状态' },
                              { id: '2', name: 'document keydown事件监听器(Banner.vue:710)检测Ctrl键按下,设置pressCtrl.value = true' },
                              { id: '3', name: 'handleClickNode方法(Banner.vue:391-411)处理节点点击,判断pressCtrl.value' },
                              { id: '4', name: 'pressCtrl.value为true时,使用e.stopPropagation()阻止冒泡(Banner.vue:396)' },
                              { id: '5', name: '检查节点是否已在selectNodes.value数组中(Banner.vue:397)' },
                              { id: '6', name: '如果已存在则splice移除(取消选中),否则push添加(选中)(Banner.vue:399-406)' },
                              { id: '7', name: 'selectNodes数组包含projectId字段(ApidocBannerWithProjectId类型)' },
                              { id: '8', name: '批量操作菜单条件渲染(Banner.vue:247,v-if="showContextmenu && selectNodes.length > 1")' },
                              { id: '9', name: '"批量删除"菜单项绑定handleDeleteNodes点击事件(Banner.vue:251)' },
                              { id: '10', name: 'deleteNode函数接收selectNodes.value数组,遍历收集所有_id到deleteIds(curd-node.ts:39-48)' },
                              { id: '11', name: '确认对话框文字判断selectNodes.length > 1显示批量删除提示(curd-node.ts:49)' },
                              { id: '12', name: '删除操作通过单次apiNodesCache.deleteNodes或API请求批量执行' },
                              { id: '13', name: 'selectNodes数组每个节点调用bannerStore.splice移除(curd-node.ts:77-98)' },
                              { id: '14', name: 'projectNavStore.deleteNavByIds一次性删除所有选中节点的nav项(curd-node.ts:107-111)' },
                            ],
                            notes: [
                              { id: '1', name: '批量选择功能依赖pressCtrl变量和document级别的keydown/keyup事件监听' },
                              { id: '2', name: 'Ctrl键按下时点击节点会阻止事件冒泡,避免触发文件夹展开/收起' },
                              { id: '3', name: '再次点击已选中节点会取消选中,实现toggle效果' },
                              { id: '4', name: '批量删除时deleteIds数组包含所有选中节点的_id,不包含子节点(httpNode没有子节点)' },
                              { id: '5', name: '批量删除确认对话框显示的数量为deleteIds.length,不是selectNodes.length' },
                              { id: '6', name: 'Delete键盘快捷键(Banner.vue:715)也可以触发批量删除,无需点击菜单' },
                            ],
                          },
                        ],
                      },
                      {
                        modelName: '删除websocketNode',
                        description: '删除websocketNode节点',
                        atomicFunc: [
                          {
                            purpose: '鼠标右键websocketNode节点删除',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个websocketNode节点' },
                              { id: '3', name: 'bannerStore.banner数组中包含待删除的websocketNode节点数据' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到目标websocketNode节点(图标显示WS或WSS)' },
                              { id: '2', name: '鼠标右键点击该websocketNode节点' },
                              { id: '3', name: '在弹出的SContextmenu右键菜单中找到"删除"选项(hot-key提示:Delete)' },
                              { id: '4', name: '点击"删除"菜单项' },
                              { id: '5', name: '在弹出的ElMessageBox确认对话框中查看提示文字:确定删除 [节点名称] 节点' },
                              { id: '6', name: '点击"确定"按钮确认删除' },
                            ],
                            expectedResults: [
                              { id: '1', name: '点击右键后立即显示右键菜单,菜单中包含"删除"选项且显示快捷键提示"Delete"' },
                              { id: '2', name: '点击"删除"后弹出确认对话框,对话框类型为warning,标题为"提示"' },
                              { id: '3', name: '确认对话框中显示文字:确定删除 [节点名称] 节点' },
                              { id: '4', name: '点击"确定"后websocketNode节点立即从banner文档树中移除,不再显示' },
                              { id: '5', name: '如果删除的websocketNode当前处于active状态,删除后编辑区域清空或切换到其他节点' },
                              { id: '6', name: 'websocketNode对应的nav项从projectNavStore中删除' },
                              { id: '7', name: '如果该websocketNode有正在运行的连接,连接会被自动断开' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleShowContextmenu方法正确处理websocketNode的右键点击事件' },
                              { id: '2', name: 'currentOperationalNode.value被设置为当前右键点击的websocketNode节点' },
                              { id: '3', name: 'websocketNode节点的type字段值为"websocket"' },
                              { id: '4', name: 'showContextmenu.value设置为true,contextmenuLeft和contextmenuTop设置为鼠标位置' },
                              { id: '5', name: 'SContextmenu组件条件渲染(v-if="showContextmenu && selectNodes.length <= 1")' },
                              { id: '6', name: '"删除"菜单项条件显示(v-show="currentOperationalNode")' },
                              { id: '7', name: '点击"删除"触发handleDeleteNodes方法,调用deleteNode函数' },
                              { id: '8', name: 'deleteNode函数收集deleteIds数组,包含websocketNode的_id' },
                              { id: '9', name: 'ElMessageBox.confirm显示确认对话框' },
                              { id: '10', name: '离线模式:调用apiNodesCache.deleteNodes(deleteIds)删除IndexedDB中的websocketNode数据' },
                              { id: '11', name: '在线模式:调用request.delete("/api/project/doc", params)删除服务器websocketNode数据' },
                              { id: '12', name: 'bannerStore.splice方法从banner数组中移除websocketNode节点' },
                              { id: '13', name: 'projectNavStore.deleteNavByIds删除websocketNode的nav项' },
                              { id: '14', name: '触发eventEmitter.emit("apidoc/deleteDocs")事件' },
                            ],
                            notes: [
                              { id: '1', name: 'websocketNode节点在树中显示.ws-icon图标,内容为节点的protocol字段(WS/WSS)转大写' },
                              { id: '2', name: 'deleteNode函数对websocketNode和httpNode的处理逻辑相同,都是非folder类型' },
                              { id: '3', name: 'websocketNode节点渲染在Banner.vue:139-163,包含protocol,url.path等字段' },
                              { id: '4', name: '删除websocketNode时不会递归删除子节点(websocketNode不是folder类型)' },
                              { id: '5', name: 'websocketNode的nav项会从projectNavStore中删除,清理导航历史' },
                            ],
                          },
                          {
                            purpose: '鼠标移动到websocketNode节点,点击更多操作删除节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个websocketNode节点' },
                              { id: '3', name: 'bannerStore.banner数组中包含待删除的websocketNode节点数据' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到目标websocketNode节点(图标显示WS或WSS)' },
                              { id: '2', name: '将鼠标移动到该websocketNode节点上(触发@mouseenter.stop="handleNodeHover"事件)' },
                              { id: '3', name: '观察节点右侧出现"更多操作"按钮(.more元素,包含MoreFilled图标)' },
                              { id: '4', name: '点击"更多操作"按钮' },
                              { id: '5', name: '在弹出的右键菜单中找到"删除"选项' },
                              { id: '6', name: '点击"删除"菜单项' },
                              { id: '7', name: '在弹出的ElMessageBox确认对话框中点击"确定"按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: '鼠标悬停websocketNode时,节点右侧显示"更多操作"按钮,按钮包含MoreFilled图标' },
                              { id: '2', name: '点击"更多操作"按钮后显示右键菜单,菜单内容与右键节点相同' },
                              { id: '3', name: '菜单中包含"删除"选项,显示快捷键提示"Delete"' },
                              { id: '4', name: '点击"删除"后弹出确认对话框,对话框类型为warning' },
                              { id: '5', name: '点击"确定"后websocketNode节点立即从banner文档树中移除' },
                              { id: '6', name: 'websocketNode对应的nav项从projectNavStore中删除' },
                              { id: '7', name: '离线模式下IndexedDB中的websocketNode数据被删除,在线模式下服务器数据被删除' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'websocketNode节点渲染包含.more按钮(Banner.vue:158-162)' },
                              { id: '2', name: '.more按钮绑定@click.stop事件,阻止冒泡并调用handleShowContextmenu' },
                              { id: '3', name: 'handleShowContextmenu($event, scope.data)接收websocketNode数据作为参数' },
                              { id: '4', name: 'currentOperationalNode.value被设置为点击的websocketNode节点' },
                              { id: '5', name: 'showContextmenu.value设置为true' },
                              { id: '6', name: 'contextmenuLeft和contextmenuTop设置为$event.clientX和$event.clientY' },
                              { id: '7', name: 'SContextmenu组件根据showContextmenu和selectNodes.length条件渲染' },
                              { id: '8', name: '点击"删除"触发handleDeleteNodes方法' },
                              { id: '9', name: 'deleteNode函数执行删除逻辑,包含确认对话框' },
                              { id: '10', name: 'bannerStore.splice从数组中移除websocketNode数据' },
                              { id: '11', name: 'projectNavStore.deleteNavByIds删除websocketNode的nav项' },
                              { id: '12', name: '触发apidoc/deleteDocs事件' },
                            ],
                            notes: [
                              { id: '1', name: 'websocketNode的更多操作按钮位于节点右侧,与httpNode布局一致' },
                              { id: '2', name: '点击更多操作按钮和右键websocketNode最终都调用同一个handleShowContextmenu方法' },
                              { id: '3', name: '更多操作按钮使用@click.stop阻止事件冒泡,避免触发节点点击事件' },
                              { id: '4', name: '删除操作的后续流程与右键删除完全相同,复用deleteNode函数' },
                              { id: '5', name: 'websocketNode显示.ws-icon,内容为scope.data.protocol.toUpperCase()(WS或WSS)' },
                            ],
                          },
                          {
                            purpose: '按住ctrl鼠标左键批量选择websocketNode节点,鼠标右键批量删除',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少2个websocketNode节点' },
                              { id: '3', name: 'bannerStore.banner数组中包含多个待删除的websocketNode节点数据' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到多个目标websocketNode节点' },
                              { id: '2', name: '按住键盘上的Ctrl键不放' },
                              { id: '3', name: '按住Ctrl键的同时,依次鼠标左键点击第一个websocketNode节点' },
                              { id: '4', name: '观察第一个websocketNode被选中,节点添加.select-node类名高亮显示' },
                              { id: '5', name: '继续按住Ctrl键,鼠标左键点击第二个websocketNode节点' },
                              { id: '6', name: '观察第二个websocketNode也被选中,两个节点同时高亮显示' },
                              { id: '7', name: '继续按住Ctrl键,可以点击更多websocketNode节点进行多选' },
                              { id: '8', name: '释放Ctrl键,在任意一个已选中的websocketNode上点击鼠标右键' },
                              { id: '9', name: '在弹出的批量操作右键菜单中找到"批量删除"选项(hot-key:Delete)' },
                              { id: '10', name: '点击"批量删除"菜单项' },
                              { id: '11', name: '在弹出的ElMessageBox确认对话框中查看提示文字:确定批量删除 [数量] 个节点?' },
                              { id: '12', name: '点击"确定"按钮确认批量删除' },
                            ],
                            expectedResults: [
                              { id: '1', name: '按住Ctrl键点击websocketNode时,事件冒泡被阻止(e.stopPropagation),不触发文件夹展开' },
                              { id: '2', name: '每次按住Ctrl键点击websocketNode后,节点添加.select-node类名,背景色变化表示选中状态' },
                              { id: '3', name: 'selectNodes.value数组包含所有选中的websocketNode对象,数组长度等于选中节点数量' },
                              { id: '4', name: '再次按住Ctrl键点击已选中的websocketNode,该节点被取消选中,从selectNodes数组中移除' },
                              { id: '5', name: '右键点击已选中websocketNode后显示批量操作菜单(v-if="showContextmenu && selectNodes.length > 1")' },
                              { id: '6', name: '批量操作菜单包含"批量剪切","批量复制","批量删除"三个选项' },
                              { id: '7', name: '点击"批量删除"后确认对话框显示总删除数量(包括所有选中的websocketNode)' },
                              { id: '8', name: '点击"确定"后所有选中的websocketNode同时从banner文档树中移除' },
                              { id: '9', name: '所有被删除websocketNode的nav项从projectNavStore中批量删除' },
                              { id: '10', name: '离线模式下所有websocketNode数据从IndexedDB批量删除,在线模式下通过一次API请求批量删除' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'pressCtrl变量跟踪Ctrl键按下状态' },
                              { id: '2', name: 'document keydown事件监听器检测Ctrl键按下,设置pressCtrl.value = true' },
                              { id: '3', name: 'handleClickNode方法处理websocketNode点击,判断pressCtrl.value' },
                              { id: '4', name: 'pressCtrl.value为true时,使用e.stopPropagation()阻止冒泡' },
                              { id: '5', name: '检查websocketNode是否已在selectNodes.value数组中' },
                              { id: '6', name: '如果已存在则splice移除(取消选中),否则push添加(选中)' },
                              { id: '7', name: 'selectNodes数组包含projectId字段(ApidocBannerWithProjectId类型)' },
                              { id: '8', name: '批量操作菜单条件渲染(v-if="showContextmenu && selectNodes.length > 1")' },
                              { id: '9', name: '"批量删除"菜单项绑定handleDeleteNodes点击事件' },
                              { id: '10', name: 'deleteNode函数接收selectNodes.value数组,遍历收集所有websocketNode的_id到deleteIds' },
                              { id: '11', name: '确认对话框文字判断selectNodes.length > 1显示批量删除提示' },
                              { id: '12', name: '删除操作通过单次apiNodesCache.deleteNodes或API请求批量执行' },
                              { id: '13', name: 'selectNodes数组每个websocketNode调用bannerStore.splice移除' },
                              { id: '14', name: 'projectNavStore.deleteNavByIds一次性删除所有选中websocketNode的nav项' },
                            ],
                            notes: [
                              { id: '1', name: '批量选择websocketNode的逻辑与httpNode完全相同,复用相同的批量选择机制' },
                              { id: '2', name: 'Ctrl键按下时点击websocketNode会阻止事件冒泡,避免触发文件夹展开/收起' },
                              { id: '3', name: '再次点击已选中websocketNode会取消选中,实现toggle效果' },
                              { id: '4', name: '批量删除websocketNode时deleteIds数组包含所有选中节点的_id,不包含子节点(websocketNode没有子节点)' },
                              { id: '5', name: 'Delete键盘快捷键也可以触发websocketNode批量删除,无需点击菜单' },
                            ],
                          },
                        ],
                      },
                      {
                        modelName: '删除httpMockNode',
                        description: '删除httpMockNode节点',
                        atomicFunc: [
                          {
                            purpose: '鼠标右键httpMockNode节点删除',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个httpMockNode节点' },
                              { id: '3', name: 'bannerStore.banner数组中包含待删除的httpMockNode节点数据' },
                              { id: '4', name: 'httpMockNode节点可能处于任意状态(未运行,running,starting,stopping,error)' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到目标httpMockNode节点(图标显示"mock")' },
                              { id: '2', name: '鼠标右键点击该httpMockNode节点' },
                              { id: '3', name: '在弹出的SContextmenu右键菜单中找到"删除"选项(hot-key提示:Delete)' },
                              { id: '4', name: '点击"删除"菜单项' },
                              { id: '5', name: '在弹出的ElMessageBox确认对话框中查看提示文字:确定删除 [节点名称] 节点' },
                              { id: '6', name: '点击"确定"按钮确认删除' },
                            ],
                            expectedResults: [
                              { id: '1', name: '点击右键后立即显示右键菜单,菜单中包含"删除"选项且显示快捷键提示"Delete"' },
                              { id: '2', name: '点击"删除"后弹出确认对话框,对话框类型为warning,标题为"提示"' },
                              { id: '3', name: '确认对话框中显示文字:确定删除 [节点名称] 节点' },
                              { id: '4', name: '点击"确定"后httpMockNode节点立即从banner文档树中移除,不再显示' },
                              { id: '5', name: '如果httpMockNode处于running状态,删除时会自动停止Mock服务器' },
                              { id: '6', name: '如果节点当前处于active状态,删除后编辑区域清空或切换到其他节点' },
                              { id: '7', name: 'httpMockNode对应的nav项从projectNavStore中删除' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleShowContextmenu方法正确处理httpMockNode的右键点击事件' },
                              { id: '2', name: 'currentOperationalNode.value被设置为当前右键点击的httpMockNode节点' },
                              { id: '3', name: 'httpMockNode节点的type字段值为"httpMock"' },
                              { id: '4', name: 'showContextmenu.value设置为true' },
                              { id: '5', name: 'SContextmenu组件条件渲染' },
                              { id: '6', name: '"删除"菜单项条件显示(v-show="currentOperationalNode")' },
                              { id: '7', name: '点击"删除"触发handleDeleteNodes方法' },
                              { id: '8', name: 'deleteNode函数收集deleteIds数组,包含httpMockNode的_id' },
                              { id: '9', name: 'ElMessageBox.confirm显示确认对话框' },
                              { id: '10', name: '离线模式:调用apiNodesCache.deleteNodes(deleteIds)删除IndexedDB中的httpMockNode数据' },
                              { id: '11', name: '在线模式:调用request.delete("/api/project/doc", params)删除服务器httpMockNode数据' },
                              { id: '12', name: 'bannerStore.splice方法从banner数组中移除httpMockNode节点' },
                              { id: '13', name: 'projectNavStore.deleteNavByIds删除httpMockNode的nav项' },
                              { id: '14', name: '触发eventEmitter.emit("apidoc/deleteDocs")事件' },
                            ],
                            notes: [
                              { id: '1', name: 'httpMockNode节点在树中显示.mock-icon图标,内容为"mock"文字(Banner.vue:65-69)' },
                              { id: '2', name: 'httpMockNode可能包含.mock-status状态指示器,显示running/starting/stopping/error状态(Banner.vue:88-109)' },
                              { id: '3', name: 'deleteNode函数对httpMockNode和httpNode的处理逻辑相同,都是非folder类型' },
                              { id: '4', name: '删除httpMockNode时不会递归删除子节点(httpMockNode不是folder类型)' },
                              { id: '5', name: 'httpMockNode节点渲染在Banner.vue:65-115,包含state,port等特有字段' },
                            ],
                          },
                          {
                            purpose: '鼠标移动到httpMockNode节点,点击更多操作删除节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个httpMockNode节点' },
                              { id: '3', name: 'bannerStore.banner数组中包含待删除的httpMockNode节点数据' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到目标httpMockNode节点(图标显示"mock")' },
                              { id: '2', name: '将鼠标移动到该httpMockNode节点上(触发@mouseenter.stop="handleNodeHover"事件)' },
                              { id: '3', name: '观察节点右侧出现"更多操作"按钮(.more元素,包含MoreFilled图标)' },
                              { id: '4', name: '点击"更多操作"按钮' },
                              { id: '5', name: '在弹出的右键菜单中找到"删除"选项' },
                              { id: '6', name: '点击"删除"菜单项' },
                              { id: '7', name: '在弹出的ElMessageBox确认对话框中点击"确定"按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: '鼠标悬停httpMockNode时,节点右侧显示"更多操作"按钮' },
                              { id: '2', name: '如果httpMockNode处于running状态,节点会显示状态指示器(绿色圆点)' },
                              { id: '3', name: '点击"更多操作"按钮后显示右键菜单,菜单内容与右键节点相同' },
                              { id: '4', name: '菜单中包含"删除"选项,显示快捷键提示"Delete"' },
                              { id: '5', name: '点击"删除"后弹出确认对话框' },
                              { id: '6', name: '点击"确定"后httpMockNode节点立即从banner文档树中移除' },
                              { id: '7', name: '离线模式下IndexedDB中的httpMockNode数据被删除,在线模式下服务器数据被删除' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'httpMockNode节点渲染包含.more按钮(Banner.vue:110-114)' },
                              { id: '2', name: '.more按钮绑定@click.stop事件,阻止冒泡并调用handleShowContextmenu' },
                              { id: '3', name: 'handleShowContextmenu($event, scope.data)接收httpMockNode数据作为参数' },
                              { id: '4', name: 'currentOperationalNode.value被设置为点击的httpMockNode节点' },
                              { id: '5', name: 'showContextmenu.value设置为true' },
                              { id: '6', name: 'SContextmenu组件根据showContextmenu和selectNodes.length条件渲染' },
                              { id: '7', name: '点击"删除"触发handleDeleteNodes方法' },
                              { id: '8', name: 'deleteNode函数执行删除逻辑,包含确认对话框' },
                              { id: '9', name: 'bannerStore.splice从数组中移除httpMockNode数据' },
                              { id: '10', name: 'projectNavStore.deleteNavByIds删除httpMockNode的nav项' },
                            ],
                            notes: [
                              { id: '1', name: 'httpMockNode的更多操作按钮位于节点右侧,布局包含Mock状态指示器(如果有状态)' },
                              { id: '2', name: '点击更多操作按钮和右键httpMockNode最终都调用同一个handleShowContextmenu方法' },
                              { id: '3', name: '更多操作按钮使用@click.stop阻止事件冒泡,避免触发节点点击事件' },
                              { id: '4', name: '删除操作的后续流程与右键删除完全相同,复用deleteNode函数' },
                            ],
                          },
                          {
                            purpose: '按住ctrl鼠标左键批量选择httpMockNode节点,鼠标右键批量删除',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少2个httpMockNode节点' },
                              { id: '3', name: 'bannerStore.banner数组中包含多个待删除的httpMockNode节点数据' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到多个目标httpMockNode节点' },
                              { id: '2', name: '按住键盘上的Ctrl键不放' },
                              { id: '3', name: '按住Ctrl键的同时,依次鼠标左键点击多个httpMockNode节点' },
                              { id: '4', name: '观察每个httpMockNode被选中后添加.select-node类名高亮显示' },
                              { id: '5', name: '释放Ctrl键,在任意一个已选中的httpMockNode上点击鼠标右键' },
                              { id: '6', name: '在弹出的批量操作右键菜单中找到"批量删除"选项' },
                              { id: '7', name: '点击"批量删除"菜单项' },
                              { id: '8', name: '在弹出的ElMessageBox确认对话框中查看提示文字:确定批量删除 [数量] 个节点?' },
                              { id: '9', name: '点击"确定"按钮确认批量删除' },
                            ],
                            expectedResults: [
                              { id: '1', name: '按住Ctrl键点击httpMockNode时,节点添加.select-node类名高亮显示' },
                              { id: '2', name: 'selectNodes.value数组包含所有选中的httpMockNode对象' },
                              { id: '3', name: '右键点击已选中httpMockNode后显示批量操作菜单' },
                              { id: '4', name: '点击"批量删除"后确认对话框显示总删除数量' },
                              { id: '5', name: '点击"确定"后所有选中的httpMockNode同时从banner文档树中移除' },
                              { id: '6', name: '如果批量删除的httpMockNode中有running状态的节点,对应的Mock服务器会被停止' },
                              { id: '7', name: '所有被删除httpMockNode的nav项从projectNavStore中批量删除' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'pressCtrl变量跟踪Ctrl键按下状态' },
                              { id: '2', name: 'handleClickNode方法处理httpMockNode点击,判断pressCtrl.value' },
                              { id: '3', name: 'pressCtrl.value为true时,使用e.stopPropagation()阻止冒泡' },
                              { id: '4', name: '检查httpMockNode是否已在selectNodes.value数组中' },
                              { id: '5', name: '批量操作菜单条件渲染(v-if="showContextmenu && selectNodes.length > 1")' },
                              { id: '6', name: '"批量删除"菜单项绑定handleDeleteNodes点击事件' },
                              { id: '7', name: 'deleteNode函数接收selectNodes.value数组,遍历收集所有httpMockNode的_id到deleteIds' },
                              { id: '8', name: '删除操作通过单次apiNodesCache.deleteNodes或API请求批量执行' },
                              { id: '9', name: 'projectNavStore.deleteNavByIds一次性删除所有选中httpMockNode的nav项' },
                            ],
                            notes: [
                              { id: '1', name: '批量选择httpMockNode的逻辑与其他节点类型完全相同' },
                              { id: '2', name: '批量删除httpMockNode时deleteIds数组包含所有选中节点的_id' },
                              { id: '3', name: 'Delete键盘快捷键也可以触发httpMockNode批量删除' },
                              { id: '4', name: '批量删除可能包含不同状态的httpMockNode节点(running,stopped等)' },
                            ],
                          },
                        ],
                      },
                      {
                        modelName: '删除websocketMockNode',
                        description: '删除websocketMockNode节点',
                        atomicFunc: [
                          {
                            purpose: '鼠标右键websocketMockNode节点删除',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个websocketMockNode节点' },
                              { id: '3', name: 'bannerStore.banner数组中包含待删除的websocketMockNode节点数据' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到目标websocketMockNode节点(图标显示Radio图标)' },
                              { id: '2', name: '鼠标右键点击该websocketMockNode节点' },
                              { id: '3', name: '在弹出的SContextmenu右键菜单中找到"删除"选项(hot-key提示:Delete)' },
                              { id: '4', name: '点击"删除"菜单项' },
                              { id: '5', name: '在弹出的ElMessageBox确认对话框中查看提示文字:确定删除 [节点名称] 节点' },
                              { id: '6', name: '点击"确定"按钮确认删除' },
                            ],
                            expectedResults: [
                              { id: '1', name: '点击右键后立即显示右键菜单,菜单中包含"删除"选项且显示快捷键提示"Delete"' },
                              { id: '2', name: '点击"删除"后弹出确认对话框,对话框类型为warning,标题为"提示"' },
                              { id: '3', name: '确认对话框中显示文字:确定删除 [节点名称] 节点' },
                              { id: '4', name: '点击"确定"后websocketMockNode节点立即从banner文档树中移除' },
                              { id: '5', name: '如果websocketMockNode处于active状态,删除后编辑区域清空或切换到其他节点' },
                              { id: '6', name: 'websocketMockNode对应的nav项从projectNavStore中删除' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleShowContextmenu方法正确处理websocketMockNode的右键点击事件' },
                              { id: '2', name: 'currentOperationalNode.value被设置为当前右键点击的websocketMockNode节点' },
                              { id: '3', name: 'websocketMockNode节点的type字段值为"websocketMock"' },
                              { id: '4', name: 'showContextmenu.value设置为true' },
                              { id: '5', name: 'SContextmenu组件条件渲染' },
                              { id: '6', name: '"删除"菜单项条件显示(v-show="currentOperationalNode")' },
                              { id: '7', name: '点击"删除"触发handleDeleteNodes方法' },
                              { id: '8', name: 'deleteNode函数收集deleteIds数组,包含websocketMockNode的_id' },
                              { id: '9', name: 'ElMessageBox.confirm显示确认对话框' },
                              { id: '10', name: '离线模式:调用apiNodesCache.deleteNodes删除IndexedDB中的websocketMockNode数据' },
                              { id: '11', name: '在线模式:调用request.delete("/api/project/doc", params)删除服务器数据' },
                              { id: '12', name: 'bannerStore.splice方法从banner数组中移除websocketMockNode节点' },
                              { id: '13', name: 'projectNavStore.deleteNavByIds删除websocketMockNode的nav项' },
                              { id: '14', name: '触发eventEmitter.emit("apidoc/deleteDocs")事件' },
                            ],
                            notes: [
                              { id: '1', name: 'websocketMockNode节点在树中显示Radio图标(Banner.vue:166)' },
                              { id: '2', name: 'websocketMockNode节点显示path字段而非url字段(Banner.vue:170-171)' },
                              { id: '3', name: 'deleteNode函数对websocketMockNode的处理逻辑与其他非folder类型节点相同' },
                              { id: '4', name: '删除websocketMockNode时不会递归删除子节点(websocketMockNode不是folder类型)' },
                            ],
                          },
                          {
                            purpose: '鼠标移动到websocketMockNode节点,点击更多操作删除节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个websocketMockNode节点' },
                              { id: '3', name: 'bannerStore.banner数组中包含待删除的websocketMockNode节点数据' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到目标websocketMockNode节点(图标显示Radio图标)' },
                              { id: '2', name: '将鼠标移动到该websocketMockNode节点上(触发@mouseenter.stop="handleNodeHover"事件)' },
                              { id: '3', name: '观察节点右侧出现"更多操作"按钮(.more元素,包含MoreFilled图标)' },
                              { id: '4', name: '点击"更多操作"按钮' },
                              { id: '5', name: '在弹出的右键菜单中找到"删除"选项' },
                              { id: '6', name: '点击"删除"菜单项' },
                              { id: '7', name: '在弹出的ElMessageBox确认对话框中点击"确定"按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: '鼠标悬停websocketMockNode时,节点右侧显示"更多操作"按钮' },
                              { id: '2', name: '点击"更多操作"按钮后显示右键菜单,菜单内容与右键节点相同' },
                              { id: '3', name: '菜单中包含"删除"选项,显示快捷键提示"Delete"' },
                              { id: '4', name: '点击"删除"后弹出确认对话框' },
                              { id: '5', name: '点击"确定"后websocketMockNode节点立即从banner文档树中移除' },
                              { id: '6', name: 'websocketMockNode对应的nav项从projectNavStore中删除' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'websocketMockNode节点渲染包含.more按钮' },
                              { id: '2', name: '.more按钮绑定@click.stop事件,调用handleShowContextmenu' },
                              { id: '3', name: 'handleShowContextmenu接收websocketMockNode数据作为参数' },
                              { id: '4', name: 'currentOperationalNode.value被设置为点击的websocketMockNode节点' },
                              { id: '5', name: 'showContextmenu.value设置为true' },
                              { id: '6', name: 'SContextmenu组件根据showContextmenu条件渲染' },
                              { id: '7', name: '点击"删除"触发handleDeleteNodes方法' },
                              { id: '8', name: 'deleteNode函数执行删除逻辑' },
                              { id: '9', name: 'bannerStore.splice从数组中移除websocketMockNode数据' },
                              { id: '10', name: 'projectNavStore.deleteNavByIds删除websocketMockNode的nav项' },
                            ],
                            notes: [
                              { id: '1', name: 'websocketMockNode的更多操作按钮位于节点右侧' },
                              { id: '2', name: '点击更多操作按钮和右键websocketMockNode都调用handleShowContextmenu方法' },
                              { id: '3', name: '更多操作按钮使用@click.stop阻止事件冒泡' },
                              { id: '4', name: '删除操作复用deleteNode函数' },
                            ],
                          },
                          {
                            purpose: '按住ctrl鼠标左键批量选择websocketMockNode节点,鼠标右键批量删除',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少2个websocketMockNode节点' },
                              { id: '3', name: 'bannerStore.banner数组中包含多个待删除的websocketMockNode节点数据' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到多个目标websocketMockNode节点' },
                              { id: '2', name: '按住键盘上的Ctrl键不放' },
                              { id: '3', name: '按住Ctrl键的同时,依次鼠标左键点击多个websocketMockNode节点' },
                              { id: '4', name: '观察每个websocketMockNode被选中后添加.select-node类名高亮显示' },
                              { id: '5', name: '释放Ctrl键,在任意一个已选中的websocketMockNode上点击鼠标右键' },
                              { id: '6', name: '在弹出的批量操作右键菜单中找到"批量删除"选项' },
                              { id: '7', name: '点击"批量删除"菜单项' },
                              { id: '8', name: '在弹出的ElMessageBox确认对话框中查看提示文字:确定批量删除 [数量] 个节点?' },
                              { id: '9', name: '点击"确定"按钮确认批量删除' },
                            ],
                            expectedResults: [
                              { id: '1', name: '按住Ctrl键点击websocketMockNode时,节点添加.select-node类名高亮显示' },
                              { id: '2', name: 'selectNodes.value数组包含所有选中的websocketMockNode对象' },
                              { id: '3', name: '右键点击已选中websocketMockNode后显示批量操作菜单' },
                              { id: '4', name: '点击"批量删除"后确认对话框显示总删除数量' },
                              { id: '5', name: '点击"确定"后所有选中的websocketMockNode同时从banner文档树中移除' },
                              { id: '6', name: '所有被删除websocketMockNode的nav项从projectNavStore中批量删除' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'pressCtrl变量跟踪Ctrl键按下状态' },
                              { id: '2', name: 'handleClickNode方法处理websocketMockNode点击,判断pressCtrl.value' },
                              { id: '3', name: 'pressCtrl.value为true时,使用e.stopPropagation()阻止冒泡' },
                              { id: '4', name: '检查websocketMockNode是否已在selectNodes.value数组中' },
                              { id: '5', name: '批量操作菜单条件渲染(v-if="showContextmenu && selectNodes.length > 1")' },
                              { id: '6', name: '"批量删除"菜单项绑定handleDeleteNodes点击事件' },
                              { id: '7', name: 'deleteNode函数接收selectNodes.value数组,遍历收集所有websocketMockNode的_id到deleteIds' },
                              { id: '8', name: '删除操作通过单次apiNodesCache.deleteNodes或API请求批量执行' },
                              { id: '9', name: 'projectNavStore.deleteNavByIds一次性删除所有选中websocketMockNode的nav项' },
                            ],
                            notes: [
                              { id: '1', name: '批量选择websocketMockNode的逻辑与其他节点类型完全相同' },
                              { id: '2', name: '批量删除websocketMockNode时deleteIds数组包含所有选中节点的_id' },
                              { id: '3', name: 'Delete键盘快捷键也可以触发websocketMockNode批量删除' },
                            ],
                          },
                        ],
                      },
                      {
                        modelName: '删除folder',
                        description: '删除folder节点',
                        atomicFunc: [
                          {
                            purpose: '鼠标右键folder节点删除',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个folder节点' },
                              { id: '3', name: 'bannerStore.banner数组中包含待删除的folder节点数据' },
                              { id: '4', name: 'folder节点可能包含子节点(httpNode,websocketNode,httpMockNode,websocketMockNode,子folder)或为空文件夹' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到目标folder节点(图标显示文件夹图标)' },
                              { id: '2', name: '鼠标右键点击该folder节点' },
                              { id: '3', name: '在弹出的SContextmenu右键菜单中找到"删除"选项(hot-key提示:Delete)' },
                              { id: '4', name: '点击"删除"菜单项' },
                              { id: '5', name: '在弹出的ElMessageBox确认对话框中查看提示文字' },
                              { id: '6', name: '如果folder包含子节点,确认对话框显示删除数量包含所有子节点' },
                              { id: '7', name: '点击"确定"按钮确认删除' },
                            ],
                            expectedResults: [
                              { id: '1', name: '点击右键后立即显示右键菜单,菜单中包含"删除"选项且显示快捷键提示"Delete"' },
                              { id: '2', name: '点击"删除"后弹出确认对话框,对话框类型为warning,标题为"提示"' },
                              { id: '3', name: '如果folder为空,确认对话框显示:确定删除 [folder名称] 节点' },
                              { id: '4', name: '如果folder包含子节点,确认对话框显示:确定删除 [folder名称] 节点(删除数量包含folder本身及所有子节点)' },
                              { id: '5', name: '点击"确定"后folder节点立即从banner文档树中移除' },
                              { id: '6', name: 'folder的所有子节点(包括嵌套的子文件夹及其内容)同时被删除' },
                              { id: '7', name: '所有被删除的非folder类型子节点的nav项从projectNavStore中删除' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleShowContextmenu方法正确处理folder的右键点击事件' },
                              { id: '2', name: 'currentOperationalNode.value被设置为当前右键点击的folder节点' },
                              { id: '3', name: 'folder节点的type字段值为"folder"' },
                              { id: '4', name: 'showContextmenu.value设置为true' },
                              { id: '5', name: 'SContextmenu组件条件渲染' },
                              { id: '6', name: '"删除"菜单项条件显示(v-show="currentOperationalNode")' },
                              { id: '7', name: '点击"删除"触发handleDeleteNodes方法' },
                              { id: '8', name: 'deleteNode函数收集deleteIds数组,包含folder的_id及所有子节点_id(curd-node.ts:40-47)' },
                              { id: '9', name: 'forEachForest递归遍历folder.children,收集所有子节点_id(curd-node.ts:42-46)' },
                              { id: '10', name: 'ElMessageBox.confirm显示确认对话框,deleteTip包含总删除数量deleteIds.length' },
                              { id: '11', name: '离线模式:调用apiNodesCache.deleteNodes(deleteIds)删除IndexedDB中的folder及所有子节点数据' },
                              { id: '12', name: '在线模式:调用request.delete("/api/project/doc", params)批量删除服务器数据' },
                              { id: '13', name: 'bannerStore.splice方法从banner数组中移除folder节点' },
                              { id: '14', name: 'projectNavStore.deleteNavByIds删除所有非folder类型子节点的nav项(curd-node.ts:101-111)' },
                              { id: '15', name: '触发eventEmitter.emit("apidoc/deleteDocs")事件' },
                            ],
                            notes: [
                              { id: '1', name: 'folder节点在树中显示.folder-icon文件夹图标(Banner.vue:118)' },
                              { id: '2', name: '删除folder时会递归删除所有子节点,包括嵌套的子文件夹及其所有内容' },
                              { id: '3', name: 'forEachForest函数遍历children树形结构,确保收集所有后代节点(curd-node.ts:42-46)' },
                              { id: '4', name: '删除folder时只删除非folder类型子节点的nav项,folder本身不在nav中' },
                              { id: '5', name: '确认对话框显示的删除数量为deleteIds.length,不是selectNodes.length' },
                            ],
                          },
                          {
                            purpose: '鼠标移动到folder节点,点击更多操作删除节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个folder节点' },
                              { id: '3', name: 'bannerStore.banner数组中包含待删除的folder节点数据' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到目标folder节点(图标显示文件夹图标)' },
                              { id: '2', name: '将鼠标移动到该folder节点上(触发@mouseenter.stop="handleNodeHover"事件)' },
                              { id: '3', name: '观察节点右侧出现"更多操作"按钮(.more元素,包含MoreFilled图标)' },
                              { id: '4', name: '点击"更多操作"按钮' },
                              { id: '5', name: '在弹出的右键菜单中找到"删除"选项' },
                              { id: '6', name: '点击"删除"菜单项' },
                              { id: '7', name: '在弹出的ElMessageBox确认对话框中点击"确定"按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: '鼠标悬停folder时,节点右侧显示"更多操作"按钮' },
                              { id: '2', name: '如果folder包含正在运行的Mock接口,节点会显示.folder-mock-indicator指示器(Banner.vue:128-131)' },
                              { id: '3', name: '点击"更多操作"按钮后显示右键菜单,菜单内容与右键节点相同' },
                              { id: '4', name: '菜单中包含"删除"选项,显示快捷键提示"Delete"' },
                              { id: '5', name: '点击"删除"后弹出确认对话框' },
                              { id: '6', name: '点击"确定"后folder节点及其所有子节点立即从banner文档树中移除' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'folder节点渲染包含.more按钮(Banner.vue:132-136)' },
                              { id: '2', name: '.more按钮绑定@click.stop事件,调用handleShowContextmenu' },
                              { id: '3', name: 'handleShowContextmenu接收folder数据作为参数' },
                              { id: '4', name: 'currentOperationalNode.value被设置为点击的folder节点' },
                              { id: '5', name: 'showContextmenu.value设置为true' },
                              { id: '6', name: 'SContextmenu组件根据showContextmenu条件渲染' },
                              { id: '7', name: '点击"删除"触发handleDeleteNodes方法' },
                              { id: '8', name: 'deleteNode函数执行删除逻辑,递归收集folder所有子节点_id' },
                              { id: '9', name: 'bannerStore.splice从数组中移除folder数据' },
                              { id: '10', name: 'projectNavStore.deleteNavByIds删除所有非folder类型子节点的nav项' },
                            ],
                            notes: [
                              { id: '1', name: 'folder的更多操作按钮位于节点右侧' },
                              { id: '2', name: '点击更多操作按钮和右键folder都调用handleShowContextmenu方法' },
                              { id: '3', name: '更多操作按钮使用@click.stop阻止事件冒泡' },
                              { id: '4', name: '删除操作复用deleteNode函数,自动处理子节点递归删除' },
                            ],
                          },
                          {
                            purpose: '按住ctrl鼠标左键批量选择folder节点,鼠标右键批量删除',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少2个folder节点' },
                              { id: '3', name: 'bannerStore.banner数组中包含多个待删除的folder节点数据' },
                              { id: '4', name: '多个folder可能包含不同数量的子节点或为空文件夹' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到多个目标folder节点' },
                              { id: '2', name: '按住键盘上的Ctrl键不放' },
                              { id: '3', name: '按住Ctrl键的同时,依次鼠标左键点击多个folder节点' },
                              { id: '4', name: '观察每个folder被选中后添加.select-node类名高亮显示' },
                              { id: '5', name: '释放Ctrl键,在任意一个已选中的folder上点击鼠标右键' },
                              { id: '6', name: '在弹出的批量操作右键菜单中找到"批量删除"选项' },
                              { id: '7', name: '点击"批量删除"菜单项' },
                              { id: '8', name: '在弹出的ElMessageBox确认对话框中查看提示文字:确定批量删除 [总数量] 个节点?' },
                              { id: '9', name: '注意总数量包含所有选中的folder及其所有子节点' },
                              { id: '10', name: '点击"确定"按钮确认批量删除' },
                            ],
                            expectedResults: [
                              { id: '1', name: '按住Ctrl键点击folder时,节点添加.select-node类名高亮显示' },
                              { id: '2', name: 'selectNodes.value数组包含所有选中的folder对象' },
                              { id: '3', name: '右键点击已选中folder后显示批量操作菜单' },
                              { id: '4', name: '点击"批量删除"后确认对话框显示总删除数量(所有folder + 所有子节点)' },
                              { id: '5', name: '点击"确定"后所有选中的folder及其所有子节点同时从banner文档树中移除' },
                              { id: '6', name: '所有被删除的非folder类型节点的nav项从projectNavStore中批量删除' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'pressCtrl变量跟踪Ctrl键按下状态' },
                              { id: '2', name: 'handleClickNode方法处理folder点击,判断pressCtrl.value' },
                              { id: '3', name: 'pressCtrl.value为true时,使用e.stopPropagation()阻止冒泡,不触发folder展开/收起' },
                              { id: '4', name: '检查folder是否已在selectNodes.value数组中' },
                              { id: '5', name: '批量操作菜单条件渲染(v-if="showContextmenu && selectNodes.length > 1")' },
                              { id: '6', name: '"批量删除"菜单项绑定handleDeleteNodes点击事件' },
                              { id: '7', name: 'deleteNode函数接收selectNodes.value数组,遍历每个folder收集所有_id到deleteIds' },
                              { id: '8', name: '对每个folder调用forEachForest递归收集子节点_id(curd-node.ts:40-47)' },
                              { id: '9', name: 'deleteIds数组去重,避免重复删除(curd-node.ts:43-44检查!deleteIds.find)' },
                              { id: '10', name: '删除操作通过单次apiNodesCache.deleteNodes或API请求批量执行' },
                              { id: '11', name: 'projectNavStore.deleteNavByIds一次性删除所有非folder类型节点的nav项' },
                            ],
                            notes: [
                              { id: '1', name: '批量选择folder的逻辑与其他节点类型完全相同' },
                              { id: '2', name: '批量删除folder时deleteIds数组包含所有选中folder及其所有后代节点的_id' },
                              { id: '3', name: '如果多个folder之间存在父子关系,deleteIds会去重,避免重复删除' },
                              { id: '4', name: 'Delete键盘快捷键也可以触发folder批量删除' },
                              { id: '5', name: '确认对话框显示的数量可能远大于选中的folder数量(因为包含所有子节点)' },
                            ],
                          },
                        ],
                      },
                      {
                        modelName: '删除混合节点',
                        description: '删除混合节点',
                        atomicFunc: [
                          {
                            purpose: '按住ctrl鼠标左键批量选择httpNode,websocketNode,httpMockNode,websocketMockNode,folder节点,鼠标右键批量删除',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中存在多种类型的节点:httpNode,websocketNode,httpMockNode,websocketMockNode,folder' },
                              { id: '3', name: 'bannerStore.banner数组中包含多种类型的节点数据' },
                              { id: '4', name: '至少存在2个不同类型的节点可供批量选择' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到不同类型的节点' },
                              { id: '2', name: '按住键盘上的Ctrl键不放' },
                              { id: '3', name: '按住Ctrl键的同时,依次鼠标左键点击一个httpNode节点(显示GET/POST等方法标签)' },
                              { id: '4', name: '继续按住Ctrl键,点击一个websocketNode节点(显示WS/WSS图标)' },
                              { id: '5', name: '继续按住Ctrl键,点击一个httpMockNode节点(显示"mock"图标)' },
                              { id: '6', name: '继续按住Ctrl键,点击一个websocketMockNode节点(显示Radio图标)' },
                              { id: '7', name: '继续按住Ctrl键,点击一个folder节点(显示文件夹图标)' },
                              { id: '8', name: '观察所有被选中的节点都添加.select-node类名高亮显示' },
                              { id: '9', name: '释放Ctrl键,在任意一个已选中的节点上点击鼠标右键' },
                              { id: '10', name: '在弹出的批量操作右键菜单中找到"批量删除"选项' },
                              { id: '11', name: '点击"批量删除"菜单项' },
                              { id: '12', name: '在弹出的ElMessageBox确认对话框中查看提示文字:确定批量删除 [总数量] 个节点?' },
                              { id: '13', name: '点击"确定"按钮确认批量删除' },
                            ],
                            expectedResults: [
                              { id: '1', name: '按住Ctrl键点击不同类型的节点时,所有节点都能被正确选中并高亮显示' },
                              { id: '2', name: 'selectNodes.value数组包含所有选中的混合类型节点对象' },
                              { id: '3', name: '右键点击任意已选中节点后显示批量操作菜单' },
                              { id: '4', name: '批量操作菜单包含"批量剪切","批量复制","批量删除"选项' },
                              { id: '5', name: '点击"批量删除"后确认对话框显示总删除数量(如果包含folder,数量包含folder的所有子节点)' },
                              { id: '6', name: '点击"确定"后所有选中的不同类型节点同时从banner文档树中移除' },
                              { id: '7', name: '如果选中的folder包含子节点,子节点也同时被删除' },
                              { id: '8', name: '所有被删除的非folder类型节点的nav项从projectNavStore中批量删除' },
                              { id: '9', name: '离线模式下所有节点数据从IndexedDB批量删除,在线模式下通过一次API请求批量删除' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'pressCtrl变量跟踪Ctrl键按下状态' },
                              { id: '2', name: 'handleClickNode方法处理所有类型节点的点击,判断pressCtrl.value' },
                              { id: '3', name: 'selectNodes.value数组可以包含不同type字段值的节点(http,websocket,httpMock,websocketMock,folder)' },
                              { id: '4', name: '批量操作菜单条件渲染(v-if="showContextmenu && selectNodes.length > 1")' },
                              { id: '5', name: '"批量删除"菜单项绑定handleDeleteNodes点击事件' },
                              { id: '6', name: 'deleteNode函数接收混合类型的selectNodes.value数组(curd-node.ts:33)' },
                              { id: '7', name: 'selectNodes.forEach遍历所有节点,对folder类型节点递归收集子节点(curd-node.ts:39-48)' },
                              { id: '8', name: 'deleteIds数组包含所有选中节点及folder的所有子节点的_id' },
                              { id: '9', name: 'ElMessageBox.confirm显示确认对话框,deleteTip根据selectNodes.length > 1显示批量删除文字' },
                              { id: '10', name: '删除操作通过单次apiNodesCache.deleteNodes(deleteIds)或API请求批量执行' },
                              { id: '11', name: 'forEachForest遍历selectNodes过滤出非folder类型节点收集到delNodeIds(curd-node.ts:101-105)' },
                              { id: '12', name: 'projectNavStore.deleteNavByIds批量删除所有非folder类型节点的nav项' },
                              { id: '13', name: 'bannerStore.splice对每个选中节点执行移除操作(curd-node.ts:77-98)' },
                              { id: '14', name: '触发eventEmitter.emit("apidoc/deleteDocs")事件' },
                            ],
                            notes: [
                              { id: '1', name: '混合节点批量删除复用与单一类型节点相同的deleteNode函数' },
                              { id: '2', name: 'deleteNode函数通过node.type === "folder"判断区分处理(curd-node.ts:41)' },
                              { id: '3', name: '混合删除时deleteIds可能包含httpNode,websocketNode,httpMockNode,websocketMockNode,folder及folder子节点的_id' },
                              { id: '4', name: 'Delete键盘快捷键也可以触发混合节点批量删除' },
                              { id: '5', name: '确认对话框显示的数量为deleteIds.length,可能远大于selectNodes.length(因为包含folder子节点)' },
                              { id: '6', name: '批量删除通过一次数据库操作或API请求完成,保证原子性' },
                            ],
                          },
                        ],
                      },
                    ],
                  },
                  //重命名节点
                  {
                    modelName: '重命名节点',
                    description: '重命名节点',
                    children: [
                      {
                        modelName: '重命名节点httpNode节点',
                        description: '重命名节点httpNode节点',
                        atomicFunc: [
                          {
                            purpose: 'active 节点,点击节点右键,点击重命名,输入名称,回车或blur',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个httpNode节点' },
                              { id: '3', name: 'httpNode节点当前未处于编辑状态(editNode.value为null)' },
                              { id: '4', name: 'httpNode节点的readonly字段为false(可编辑)' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到目标httpNode节点' },
                              { id: '2', name: '鼠标右键点击该httpNode节点' },
                              { id: '3', name: '在弹出的SContextmenu右键菜单中找到"重命名"选项(hot-key提示:F2)' },
                              { id: '4', name: '点击"重命名"菜单项' },
                              { id: '5', name: '观察节点名称变为可编辑的输入框(.rename-ipt),输入框自动获得焦点' },
                              { id: '6', name: '在输入框中输入新的节点名称,例如"新的接口名称"' },
                              { id: '7', name: '按下回车键或点击输入框外部区域触发blur事件' },
                            ],
                            expectedResults: [
                              { id: '1', name: '点击"重命名"后,节点名称立即变为可编辑的输入框' },
                              { id: '2', name: '输入框(.rename-ipt)自动获得焦点,可以直接输入' },
                              { id: '3', name: '输入框显示当前节点的原始名称' },
                              { id: '4', name: '输入新名称后按回车或blur,输入框消失,节点名称更新为新名称' },
                              { id: '5', name: 'bannerStore中该节点的name字段更新为新名称' },
                              { id: '6', name: 'projectNavStore中该节点的label字段更新为新名称' },
                              { id: '7', name: 'httpNodeStore中的节点名称更新为新名称' },
                              { id: '8', name: '离线模式下IndexedDB中的节点名称更新,在线模式下服务器数据更新' },
                            ],
                            checkpoints: [
                              { id: '1', name: '右键菜单中"重命名"选项条件显示(Banner.vue:241-242,v-show="currentOperationalNode && !currentOperationalNode.readonly")' },
                              { id: '2', name: '点击"重命名"触发handleRenameNode方法(Banner.vue:608-614)' },
                              { id: '3', name: 'handleRenameNode设置editNode.value = currentOperationalNode.value(Banner.vue:609)' },
                              { id: '4', name: 'setTimeout后调用document.querySelector(".rename-ipt").focus()使输入框获得焦点(Banner.vue:611)' },
                              { id: '5', name: 'enableDrag.value设置为false,禁用拖拽(Banner.vue:612)' },
                              { id: '6', name: 'httpNode节点渲染逻辑判断editNode?._id !== scope.data._id决定显示输入框还是文本(Banner.vue:41)' },
                              { id: '7', name: '输入框绑定@blur和@keydown.stop.enter事件,都调用handleChangeNodeName(Banner.vue:54-56)' },
                              { id: '8', name: 'handleChangeNodeName调用renameNode.call(this, e, data)(Banner.vue:617)' },
                              { id: '9', name: 'renameNode函数检查iptValue.trim()是否为空(curd-node.ts:668-670)' },
                              { id: '10', name: 'renameNode函数设置isRename标志防止重复重命名(curd-node.ts:671)' },
                              { id: '11', name: 'bannerStore.changeBannerInfoById更新name字段(curd-node.ts:673-677)' },
                              { id: '12', name: 'projectNavStore.changeNavInfoById更新label字段(curd-node.ts:679-683)' },
                              { id: '13', name: 'httpNodeStore.changeHttpNodeName更新httpNode名称(curd-node.ts:685)' },
                              { id: '14', name: '离线模式:调用apiNodesCache.updateNodeName(data._id, iptValue)(curd-node.ts:690)' },
                              { id: '15', name: '在线模式:调用request.put("/api/project/change_doc_info", params)(curd-node.ts:722)' },
                              { id: '16', name: '重命名完成后editNode.value设置为null(Banner.vue:618)' },
                              { id: '17', name: 'enableDrag.value设置为true,恢复拖拽(Banner.vue:619)' },
                            ],
                            notes: [
                              { id: '1', name: '重命名功能通过editNode变量控制,editNode不为null时节点显示输入框' },
                              { id: '2', name: '输入框自动获得焦点通过setTimeout延迟执行focus()实现' },
                              { id: '3', name: '重命名期间禁用拖拽功能,避免冲突' },
                              { id: '4', name: '重命名同时更新三个store:bannerStore,projectNavStore,httpNodeStore' },
                              { id: '5', name: '重命名失败时会自动回滚所有前端状态到originValue(curd-node.ts:700-711)' },
                              { id: '6', name: 'readonly字段为true的节点不显示"重命名"菜单项' },
                            ],
                          },
                          {
                            purpose: 'active 节点,F2重命名,输入名称,回车或blur',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个httpNode节点' },
                              { id: '3', name: 'httpNode节点当前处于active状态(currentOperationalNode.value为该节点)' },
                              { id: '4', name: 'httpNode节点的readonly字段为false(可编辑)' },
                              { id: '5', name: '当前没有其他节点处于编辑状态(editNode.value为null)' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中点击选中目标httpNode节点,使其处于active状态' },
                              { id: '2', name: '观察节点添加.active-node类名高亮显示' },
                              { id: '3', name: '按下键盘F2键' },
                              { id: '4', name: '观察节点名称变为可编辑的输入框,输入框自动获得焦点' },
                              { id: '5', name: '在输入框中输入新的节点名称' },
                              { id: '6', name: '按下回车键或点击输入框外部区域触发blur事件' },
                            ],
                            expectedResults: [
                              { id: '1', name: '按下F2键后,active状态的httpNode节点名称立即变为可编辑的输入框' },
                              { id: '2', name: '输入框自动获得焦点,可以直接输入' },
                              { id: '3', name: '输入新名称后按回车或blur,输入框消失,节点名称更新为新名称' },
                              { id: '4', name: 'bannerStore,projectNavStore,httpNodeStore中的节点名称同步更新' },
                              { id: '5', name: '离线模式下IndexedDB更新,在线模式下服务器数据更新' },
                              { id: '6', name: '如果httpNode节点readonly为true,按F2键无任何反应' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'document的keydown事件监听器捕获F2键按下(Banner.vue:716-717)' },
                              { id: '2', name: '检查e.code === "F2"且!currentOperationalNode.value?.readonly(Banner.vue:716)' },
                              { id: '3', name: '条件满足时调用handleRenameNode()(Banner.vue:717)' },
                              { id: '4', name: 'handleRenameNode设置editNode.value = currentOperationalNode.value' },
                              { id: '5', name: 'F2快捷键只对active状态的节点生效,currentOperationalNode.value必须不为null' },
                              { id: '6', name: '输入框显示和焦点逻辑与右键重命名完全相同' },
                              { id: '7', name: '@keydown.stop.enter事件阻止事件冒泡并调用handleChangeNodeName' },
                              { id: '8', name: 'handleChangeNodeName内部调用renameNode函数执行重命名' },
                              { id: '9', name: '重命名完成后editNode.value设置为null,enableDrag.value恢复为true' },
                            ],
                            notes: [
                              { id: '1', name: 'F2快捷键是全局document级别的keydown事件监听(Banner.vue:709)' },
                              { id: '2', name: 'F2快捷键必须在节点处于active状态时才能使用' },
                              { id: '3', name: 'readonly节点即使处于active状态也无法通过F2重命名' },
                              { id: '4', name: 'F2快捷键和右键菜单"重命名"最终都调用handleRenameNode方法' },
                              { id: '5', name: '如果editNode.value不为null(已有节点在编辑),F2键会被阻止(Banner.vue:718-724检查!editNode.value)' },
                            ],
                          },
                          {
                            purpose: '点击节点更多操作,点击重命名,输入名称,回车或blur',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个httpNode节点' },
                              { id: '3', name: 'httpNode节点的readonly字段为false(可编辑)' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到目标httpNode节点' },
                              { id: '2', name: '将鼠标移动到该httpNode节点上,观察右侧出现"更多操作"按钮' },
                              { id: '3', name: '点击"更多操作"按钮(.more元素,包含MoreFilled图标)' },
                              { id: '4', name: '在弹出的右键菜单中找到"重命名"选项(hot-key提示:F2)' },
                              { id: '5', name: '点击"重命名"菜单项' },
                              { id: '6', name: '观察节点名称变为可编辑的输入框,输入框自动获得焦点' },
                              { id: '7', name: '在输入框中输入新的节点名称' },
                              { id: '8', name: '按下回车键或点击输入框外部区域触发blur事件' },
                            ],
                            expectedResults: [
                              { id: '1', name: '鼠标悬停httpNode时,节点右侧显示"更多操作"按钮' },
                              { id: '2', name: '点击"更多操作"按钮后显示右键菜单,菜单中包含"重命名"选项' },
                              { id: '3', name: '点击"重命名"后,节点名称立即变为可编辑的输入框' },
                              { id: '4', name: '输入框自动获得焦点,可以直接输入' },
                              { id: '5', name: '输入新名称后按回车或blur,节点名称更新为新名称' },
                              { id: '6', name: 'bannerStore,projectNavStore,httpNodeStore中的节点名称同步更新' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'httpNode节点渲染包含.more按钮(Banner.vue:58-62)' },
                              { id: '2', name: '.more按钮绑定@click.stop事件,调用handleShowContextmenu' },
                              { id: '3', name: 'handleShowContextmenu设置currentOperationalNode.value为当前httpNode' },
                              { id: '4', name: 'SContextmenu组件中"重命名"选项条件显示(v-show="currentOperationalNode && !currentOperationalNode.readonly")' },
                              { id: '5', name: '点击"重命名"触发handleRenameNode方法' },
                              { id: '6', name: 'handleRenameNode后续逻辑与右键重命名完全相同' },
                              { id: '7', name: 'renameNode函数执行重命名操作,更新所有相关store' },
                            ],
                            notes: [
                              { id: '1', name: '更多操作按钮和右键菜单最终都调用同一个handleShowContextmenu方法' },
                              { id: '2', name: '点击更多操作按钮的"重命名"和右键点击"重命名"效果完全相同' },
                              { id: '3', name: '重命名功能的三种触发方式(右键菜单,F2快捷键,更多操作)最终都调用handleRenameNode方法' },
                            ],
                          },
                          {
                            purpose: '节点名称未填写不允许重命名',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个httpNode节点' },
                              { id: '3', name: 'httpNode节点当前处于重命名编辑状态(editNode.value不为null)' },
                              { id: '4', name: '输入框(.rename-ipt)已获得焦点并可编辑' },
                            ],
                            operationSteps: [
                              { id: '1', name: '通过右键菜单,F2快捷键或更多操作按钮触发httpNode节点的重命名' },
                              { id: '2', name: '观察节点名称变为可编辑的输入框' },
                              { id: '3', name: '删除输入框中的所有文字,使其内容为空字符串或纯空格' },
                              { id: '4', name: '观察输入框样式变化' },
                              { id: '5', name: '尝试按下回车键或点击输入框外部区域触发blur事件' },
                            ],
                            expectedResults: [
                              { id: '1', name: '输入框内容为空或纯空格时,输入框自动添加.error类名' },
                              { id: '2', name: '.error类名使输入框显示错误状态样式(如红色边框)' },
                              { id: '3', name: '按下回车键或blur时,重命名操作被阻止,不执行任何更新' },
                              { id: '4', name: '输入框继续保持编辑状态,不消失' },
                              { id: '5', name: 'bannerStore,projectNavStore,httpNodeStore中的节点名称保持原值不变' },
                              { id: '6', name: '不向服务器或IndexedDB发送更新请求' },
                              { id: '7', name: '用户必须输入非空内容或按Esc取消编辑' },
                            ],
                            checkpoints: [
                              { id: '1', name: '输入框绑定@input事件,调用handleWatchNodeInput方法(Banner.vue:55)' },
                              { id: '2', name: 'handleWatchNodeInput检查iptValue.trim() === ""(Banner.vue:624)' },
                              { id: '3', name: '如果为空,调用classList.add("error")添加错误类名(Banner.vue:625)' },
                              { id: '4', name: '如果不为空,调用classList.remove("error")移除错误类名(Banner.vue:627)' },
                              { id: '5', name: '输入框包含.error类名时显示错误样式(通过CSS定义)' },
                              { id: '6', name: 'handleChangeNodeName调用renameNode函数' },
                              { id: '7', name: 'renameNode函数检查iptValue.trim() === ""(curd-node.ts:668)' },
                              { id: '8', name: '如果为空,直接return不执行任何重命名操作(curd-node.ts:669)' },
                              { id: '9', name: 'renameNode函数在return前移除.error类名(curd-node.ts:667)' },
                              { id: '10', name: 'editNode.value在handleChangeNodeName中被设置为null(Banner.vue:618)' },
                              { id: '11', name: '输入框消失,节点恢复显示原始名称(因为name字段未更新)' },
                            ],
                            notes: [
                              { id: '1', name: '空值验证分两层:输入时实时显示错误样式,提交时阻止执行' },
                              { id: '2', name: 'handleWatchNodeInput提供实时反馈,renameNode提供最终拦截' },
                              { id: '3', name: '即使输入框为空触发blur,输入框也会消失(因为editNode.value被设置为null)' },
                              { id: '4', name: '但节点名称不会更新,仍显示原始名称,达到"不允许重命名"的效果' },
                              { id: '5', name: 'placeholder提示文字为"不能为空"(Banner.vue:50)' },
                            ],
                          },
                        ],
                      },
                      {
                        modelName: '重命名节点websocketNode节点',
                        description: '重命名节点websocketNode节点',
                        atomicFunc: [
                          {
                            purpose: 'active 节点,点击节点右键,点击重命名,输入名称,回车或blur',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个websocketNode节点' },
                              { id: '3', name: 'websocketNode节点当前未处于编辑状态(editNode.value为null)' },
                              { id: '4', name: 'websocketNode节点的readonly字段为false(可编辑)' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的文档树中找到目标websocketNode节点(显示WS/WSS图标)' },
                              { id: '2', name: '鼠标右键点击该websocketNode节点' },
                              { id: '3', name: '在弹出的SContextmenu右键菜单中找到"重命名"选项' },
                              { id: '4', name: '点击"重命名"菜单项' },
                              { id: '5', name: '观察节点名称变为可编辑的输入框,输入框自动获得焦点' },
                              { id: '6', name: '在输入框中输入新的节点名称' },
                              { id: '7', name: '按下回车键或点击输入框外部区域触发blur事件' },
                            ],
                            expectedResults: [
                              { id: '1', name: '点击"重命名"后,websocketNode节点名称立即变为可编辑的输入框' },
                              { id: '2', name: '输入框自动获得焦点,可以直接输入' },
                              { id: '3', name: '输入新名称后按回车或blur,节点名称更新为新名称' },
                              { id: '4', name: 'bannerStore中该websocketNode的name字段更新为新名称' },
                              { id: '5', name: 'projectNavStore中该websocketNode的label字段更新为新名称' },
                              { id: '6', name: '离线模式下IndexedDB更新,在线模式下服务器数据更新' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'websocketNode节点渲染逻辑判断editNode?._id !== scope.data._id(Banner.vue:141)' },
                              { id: '2', name: '输入框绑定@blur和@keydown.stop.enter事件调用handleChangeNodeName' },
                              { id: '3', name: 'handleChangeNodeName调用renameNode函数' },
                              { id: '4', name: 'renameNode函数更新bannerStore.changeBannerInfoById' },
                              { id: '5', name: 'renameNode函数更新projectNavStore.changeNavInfoById' },
                              { id: '6', name: '离线模式调用apiNodesCache.updateNodeName' },
                              { id: '7', name: '在线模式调用request.put("/api/project/change_doc_info")' },
                            ],
                            notes: [
                              { id: '1', name: 'websocketNode重命名逻辑与httpNode完全相同' },
                              { id: '2', name: 'websocketNode显示.ws-icon图标(WS/WSS)' },
                              { id: '3', name: '重命名失败时会自动回滚前端状态' },
                            ],
                          },
                          {
                            purpose: 'active 节点,F2重命名,输入名称,回车或blur',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个websocketNode节点' },
                              { id: '3', name: 'websocketNode节点当前处于active状态' },
                              { id: '4', name: 'websocketNode节点的readonly字段为false' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击选中目标websocketNode节点,使其处于active状态' },
                              { id: '2', name: '按下键盘F2键' },
                              { id: '3', name: '观察节点名称变为可编辑的输入框' },
                              { id: '4', name: '在输入框中输入新的节点名称' },
                              { id: '5', name: '按下回车键或点击输入框外部区域' },
                            ],
                            expectedResults: [
                              { id: '1', name: '按下F2键后,websocketNode节点名称立即变为可编辑的输入框' },
                              { id: '2', name: '输入新名称后按回车或blur,节点名称更新为新名称' },
                              { id: '3', name: 'bannerStore,projectNavStore中的节点名称同步更新' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'document keydown事件监听器捕获F2键' },
                              { id: '2', name: '检查currentOperationalNode.value不为null且readonly为false' },
                              { id: '3', name: '调用handleRenameNode方法' },
                              { id: '4', name: 'renameNode函数执行重命名逻辑' },
                            ],
                            notes: [
                              { id: '1', name: 'F2快捷键必须在websocketNode处于active状态时才能使用' },
                              { id: '2', name: 'readonly节点无法通过F2重命名' },
                            ],
                          },
                          {
                            purpose: '点击节点更多操作,点击重命名,输入名称,回车或blur',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个websocketNode节点' },
                              { id: '3', name: 'websocketNode节点的readonly字段为false' },
                            ],
                            operationSteps: [
                              { id: '1', name: '将鼠标移动到websocketNode节点上' },
                              { id: '2', name: '点击"更多操作"按钮' },
                              { id: '3', name: '在弹出的右键菜单中点击"重命名"选项' },
                              { id: '4', name: '在输入框中输入新的节点名称' },
                              { id: '5', name: '按下回车键或blur' },
                            ],
                            expectedResults: [
                              { id: '1', name: '点击"更多操作"按钮后显示右键菜单' },
                              { id: '2', name: '点击"重命名"后节点名称变为可编辑输入框' },
                              { id: '3', name: '输入新名称后节点名称更新' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'websocketNode节点渲染包含.more按钮(Banner.vue:158-162)' },
                              { id: '2', name: 'handleShowContextmenu设置currentOperationalNode' },
                              { id: '3', name: '点击"重命名"触发handleRenameNode方法' },
                            ],
                            notes: [
                              { id: '1', name: '更多操作按钮和右键菜单效果相同' },
                            ],
                          },
                          {
                            purpose: '节点名称未填写不允许重命名',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: 'websocketNode节点处于重命名编辑状态' },
                            ],
                            operationSteps: [
                              { id: '1', name: '触发websocketNode节点的重命名' },
                              { id: '2', name: '删除输入框中的所有文字' },
                              { id: '3', name: '尝试按下回车键或blur' },
                            ],
                            expectedResults: [
                              { id: '1', name: '输入框内容为空时添加.error类名显示错误样式' },
                              { id: '2', name: '重命名操作被阻止,不执行任何更新' },
                              { id: '3', name: '节点名称保持原值不变' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleWatchNodeInput实时检查输入框是否为空' },
                              { id: '2', name: 'renameNode函数检查iptValue.trim() === ""' },
                              { id: '3', name: '如果为空直接return不执行重命名' },
                            ],
                            notes: [
                              { id: '1', name: '空值验证分两层:实时反馈和最终拦截' },
                            ],
                          },
                        ],
                      },
                      {
                        modelName: '重命名节点httpMockNode节点',
                        description: '重命名节点httpMockNode节点',
                        atomicFunc: [
                          {
                            purpose: 'active 节点,点击节点右键,点击重命名,输入名称,回车或blur',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个httpMockNode节点' },
                              { id: '3', name: 'httpMockNode节点未处于编辑状态' },
                              { id: '4', name: 'httpMockNode节点readonly为false' },
                            ],
                            operationSteps: [
                              { id: '1', name: '找到目标httpMockNode节点(显示"mock"图标)' },
                              { id: '2', name: '鼠标右键点击该httpMockNode节点' },
                              { id: '3', name: '在弹出的右键菜单中点击"重命名"' },
                              { id: '4', name: '在输入框中输入新名称' },
                              { id: '5', name: '按回车或blur' },
                            ],
                            expectedResults: [
                              { id: '1', name: '节点名称变为可编辑输入框' },
                              { id: '2', name: '输入框自动获得焦点' },
                              { id: '3', name: '输入新名称后节点名称更新' },
                              { id: '4', name: 'bannerStore和projectNavStore同步更新' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'httpMockNode节点渲染逻辑判断editNode?._id !== scope.data._id(Banner.vue:70)' },
                              { id: '2', name: 'handleChangeNodeName调用renameNode函数' },
                              { id: '3', name: 'renameNode更新bannerStore和projectNavStore' },
                            ],
                            notes: [
                              { id: '1', name: 'httpMockNode重命名逻辑与其他节点类型相同' },
                            ],
                          },
                          {
                            purpose: 'active 节点,F2重命名,输入名称,回车或blur',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: 'httpMockNode节点处于active状态' },
                              { id: '3', name: 'readonly为false' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击选中httpMockNode节点' },
                              { id: '2', name: '按F2键' },
                              { id: '3', name: '输入新名称并回车或blur' },
                            ],
                            expectedResults: [
                              { id: '1', name: '按F2后节点名称变为可编辑输入框' },
                              { id: '2', name: '节点名称更新成功' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'F2快捷键触发handleRenameNode' },
                              { id: '2', name: 'renameNode函数执行更新逻辑' },
                            ],
                            notes: [
                              { id: '1', name: 'F2快捷键必须在active状态下使用' },
                            ],
                          },
                          {
                            purpose: '点击节点更多操作,点击重命名,输入名称,回车或blur',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: 'httpMockNode节点readonly为false' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标悬停httpMockNode节点' },
                              { id: '2', name: '点击"更多操作"按钮' },
                              { id: '3', name: '点击"重命名"' },
                              { id: '4', name: '输入新名称并回车或blur' },
                            ],
                            expectedResults: [
                              { id: '1', name: '节点名称变为可编辑输入框' },
                              { id: '2', name: '节点名称更新成功' },
                            ],
                            checkpoints: [
                              { id: '1', name: '.more按钮触发handleShowContextmenu' },
                              { id: '2', name: '点击"重命名"触发handleRenameNode' },
                            ],
                            notes: [
                              { id: '1', name: '更多操作按钮和右键菜单效果相同' },
                            ],
                          },
                          {
                            purpose: '节点名称未填写不允许重命名',
                            precondition: [
                              { id: '1', name: 'httpMockNode节点处于编辑状态' },
                            ],
                            operationSteps: [
                              { id: '1', name: '触发重命名' },
                              { id: '2', name: '删除所有文字' },
                              { id: '3', name: '尝试回车或blur' },
                            ],
                            expectedResults: [
                              { id: '1', name: '输入框显示错误样式' },
                              { id: '2', name: '重命名被阻止' },
                              { id: '3', name: '节点名称保持原值' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleWatchNodeInput实时检查' },
                              { id: '2', name: 'renameNode检查空值并return' },
                            ],
                            notes: [
                              { id: '1', name: '空值验证分两层' },
                            ],
                          },
                        ],
                      },
                      {
                        modelName: '重命名节点websocketMock节点',
                        description: '重命名节点websocketMock节点',
                        atomicFunc: [
                          {
                            purpose: 'active 节点,点击节点右键,点击重命名,输入名称,回车或blur',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个websocketMockNode节点' },
                              { id: '3', name: 'websocketMockNode节点未处于编辑状态' },
                              { id: '4', name: 'readonly为false' },
                            ],
                            operationSteps: [
                              { id: '1', name: '找到websocketMockNode节点(显示Radio图标)' },
                              { id: '2', name: '鼠标右键点击该节点' },
                              { id: '3', name: '点击"重命名"' },
                              { id: '4', name: '输入新名称并回车或blur' },
                            ],
                            expectedResults: [
                              { id: '1', name: '节点名称变为可编辑输入框' },
                              { id: '2', name: '节点名称更新成功' },
                              { id: '3', name: 'bannerStore和projectNavStore同步更新' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'websocketMockNode节点渲染逻辑判断editNode(Banner.vue:167)' },
                              { id: '2', name: 'renameNode函数执行更新逻辑' },
                            ],
                            notes: [
                              { id: '1', name: 'websocketMockNode重命名逻辑与其他节点类型相同' },
                            ],
                          },
                          {
                            purpose: 'active 节点,F2重命名,输入名称,回车或blur',
                            precondition: [
                              { id: '1', name: 'websocketMockNode节点处于active状态' },
                              { id: '2', name: 'readonly为false' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击选中websocketMockNode节点' },
                              { id: '2', name: '按F2键' },
                              { id: '3', name: '输入新名称并回车或blur' },
                            ],
                            expectedResults: [
                              { id: '1', name: '按F2后节点名称变为输入框' },
                              { id: '2', name: '节点名称更新成功' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'F2快捷键触发handleRenameNode' },
                              { id: '2', name: 'renameNode函数执行' },
                            ],
                            notes: [
                              { id: '1', name: 'F2快捷键在active状态下生效' },
                            ],
                          },
                          {
                            purpose: '点击节点更多操作,点击重命名,输入名称,回车或blur',
                            precondition: [
                              { id: '1', name: 'websocketMockNode节点readonly为false' },
                            ],
                            operationSteps: [
                              { id: '1', name: '鼠标悬停websocketMockNode节点' },
                              { id: '2', name: '点击"更多操作"按钮' },
                              { id: '3', name: '点击"重命名"并输入新名称' },
                            ],
                            expectedResults: [
                              { id: '1', name: '节点名称更新成功' },
                            ],
                            checkpoints: [
                              { id: '1', name: '.more按钮触发handleShowContextmenu' },
                            ],
                            notes: [
                              { id: '1', name: '更多操作和右键菜单效果相同' },
                            ],
                          },
                          {
                            purpose: '节点名称未填写不允许重命名',
                            precondition: [
                              { id: '1', name: 'websocketMockNode节点处于编辑状态' },
                            ],
                            operationSteps: [
                              { id: '1', name: '触发重命名并删除所有文字' },
                              { id: '2', name: '尝试回车或blur' },
                            ],
                            expectedResults: [
                              { id: '1', name: '重命名被阻止,节点名称保持原值' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'renameNode检查空值并return' },
                            ],
                            notes: [
                              { id: '1', name: '空值验证阻止重命名' },
                            ],
                          },
                        ],
                      },
                      {
                        modelName: '重命名节点folder节点',
                        description: '重命名节点folder节点',
                        atomicFunc: [
                          {
                            purpose: 'active 节点,点击节点右键,点击重命名,输入名称,回车或blur',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中已存在至少一个folder节点' },
                              { id: '3', name: 'folder节点未处于编辑状态' },
                              { id: '4', name: 'folder节点readonly为false' },
                            ],
                            operationSteps: [
                              { id: '1', name: '找到目标folder节点(显示文件夹图标)' },
                              { id: '2', name: '鼠标右键点击该folder节点' },
                              { id: '3', name: '在弹出的右键菜单中点击"重命名"' },
                              { id: '4', name: '在输入框中输入新的文件夹名称' },
                              { id: '5', name: '按回车或点击输入框外部区域' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'folder节点名称变为可编辑输入框' },
                              { id: '2', name: '输入框自动获得焦点' },
                              { id: '3', name: '输入新名称后folder节点名称更新' },
                              { id: '4', name: 'bannerStore中该folder的name字段更新为新名称' },
                              { id: '5', name: '重命名成功后自动调用getCommonHeaders()重新拉取公共请求头' },
                              { id: '6', name: '离线模式下IndexedDB更新,在线模式下服务器数据更新' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'folder节点渲染逻辑判断editNode?._id !== scope.data._id(Banner.vue:119)' },
                              { id: '2', name: '输入框绑定@blur和@keydown.stop.enter事件调用handleChangeNodeName' },
                              { id: '3', name: 'handleChangeNodeName调用renameNode函数' },
                              { id: '4', name: 'renameNode函数检查data.type === "folder"(curd-node.ts:693或723)' },
                              { id: '5', name: '如果是folder类型,调用getCommonHeaders()重新拉取公共请求头(curd-node.ts:694或724)' },
                              { id: '6', name: 'bannerStore.changeBannerInfoById更新name字段' },
                              { id: '7', name: '离线模式调用apiNodesCache.updateNodeName' },
                              { id: '8', name: '在线模式调用request.put("/api/project/change_doc_info")' },
                            ],
                            notes: [
                              { id: '1', name: 'folder重命名有特殊逻辑:重命名成功后需要重新拉取公共请求头' },
                              { id: '2', name: '公共请求头可能与folder名称相关,因此需要重新获取' },
                              { id: '3', name: 'folder重命名不更新projectNavStore(folder不在nav中)' },
                              { id: '4', name: 'folder显示.folder-icon文件夹图标(Banner.vue:118)' },
                            ],
                          },
                          {
                            purpose: 'active 节点,F2重命名,输入名称,回车或blur',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: 'folder节点处于active状态' },
                              { id: '3', name: 'folder节点readonly为false' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击选中目标folder节点,使其处于active状态' },
                              { id: '2', name: '按下键盘F2键' },
                              { id: '3', name: '观察folder节点名称变为可编辑的输入框' },
                              { id: '4', name: '在输入框中输入新的文件夹名称' },
                              { id: '5', name: '按下回车键或点击输入框外部区域' },
                            ],
                            expectedResults: [
                              { id: '1', name: '按F2键后folder节点名称立即变为可编辑输入框' },
                              { id: '2', name: '输入新名称后folder节点名称更新' },
                              { id: '3', name: 'bannerStore中的folder名称同步更新' },
                              { id: '4', name: '自动调用getCommonHeaders()重新拉取公共请求头' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'document keydown事件监听器捕获F2键' },
                              { id: '2', name: '检查currentOperationalNode.value不为null且readonly为false' },
                              { id: '3', name: '调用handleRenameNode方法' },
                              { id: '4', name: 'renameNode函数执行重命名逻辑' },
                              { id: '5', name: '检查data.type === "folder"后调用getCommonHeaders()' },
                            ],
                            notes: [
                              { id: '1', name: 'F2快捷键必须在folder处于active状态时才能使用' },
                              { id: '2', name: 'folder重命名成功后会触发公共请求头的重新获取' },
                            ],
                          },
                          {
                            purpose: '点击节点更多操作,点击重命名,输入名称,回车或blur',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: 'folder节点readonly为false' },
                            ],
                            operationSteps: [
                              { id: '1', name: '将鼠标移动到folder节点上' },
                              { id: '2', name: '点击"更多操作"按钮' },
                              { id: '3', name: '在弹出的右键菜单中点击"重命名"' },
                              { id: '4', name: '在输入框中输入新的文件夹名称' },
                              { id: '5', name: '按回车或blur' },
                            ],
                            expectedResults: [
                              { id: '1', name: '点击"更多操作"按钮后显示右键菜单' },
                              { id: '2', name: '点击"重命名"后folder节点名称变为可编辑输入框' },
                              { id: '3', name: '输入新名称后folder节点名称更新' },
                              { id: '4', name: '自动调用getCommonHeaders()重新拉取公共请求头' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'folder节点渲染包含.more按钮(Banner.vue:132-136)' },
                              { id: '2', name: '.more按钮绑定@click.stop事件,调用handleShowContextmenu' },
                              { id: '3', name: 'handleShowContextmenu设置currentOperationalNode' },
                              { id: '4', name: '点击"重命名"触发handleRenameNode方法' },
                              { id: '5', name: 'renameNode函数检查folder类型并调用getCommonHeaders()' },
                            ],
                            notes: [
                              { id: '1', name: '更多操作按钮和右键菜单效果相同' },
                              { id: '2', name: 'folder节点可能显示.folder-mock-indicator(如果包含运行中的Mock接口)' },
                            ],
                          },
                          {
                            purpose: '节点名称未填写不允许重命名',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: 'folder节点处于重命名编辑状态' },
                            ],
                            operationSteps: [
                              { id: '1', name: '触发folder节点的重命名' },
                              { id: '2', name: '删除输入框中的所有文字,使其内容为空' },
                              { id: '3', name: '观察输入框样式变化' },
                              { id: '4', name: '尝试按下回车键或blur' },
                            ],
                            expectedResults: [
                              { id: '1', name: '输入框内容为空时添加.error类名显示错误样式' },
                              { id: '2', name: '重命名操作被阻止,不执行任何更新' },
                              { id: '3', name: 'folder节点名称保持原值不变' },
                              { id: '4', name: '不调用getCommonHeaders()(因为重命名被阻止)' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleWatchNodeInput实时检查输入框是否为空' },
                              { id: '2', name: 'renameNode函数检查iptValue.trim() === ""' },
                              { id: '3', name: '如果为空直接return不执行重命名' },
                              { id: '4', name: 'getCommonHeaders()不会被调用(重命名未成功)' },
                            ],
                            notes: [
                              { id: '1', name: '空值验证分两层:实时反馈和最终拦截' },
                              { id: '2', name: 'folder节点的空值验证逻辑与其他节点类型完全相同' },
                            ],
                          },
                        ],
                      },
                    ],
                  },
                  //复制节点
                  {
                    modelName: '复制节点',
                    description: '复制节点',
                    children: [
                      //复制httpNode节点
                      {
                        modelName: '复制httpNode节点',
                        description: '复制httpNode节点',
                        children: [
                          {
                            modelName: '复制单个httpNode节点',
                            description: '复制单个httpNode节点',
                            atomicFunc: [
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个httpNode节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '项目中存在至少一个httpNode节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner节点树中,右键点击一个httpNode节点(显示GET/POST等方法图标)' },
                                  { id: '2', name: '在右键菜单中点击"复制"选项(快捷键Ctrl+C)' },
                                  { id: '3', name: '观察复制操作完成,无明显UI反馈' },
                                  { id: '4', name: '在banner空白区域右键点击(或按Ctrl+V)' },
                                  { id: '5', name: '在右键菜单中点击"粘贴"选项' },
                                  { id: '6', name: '观察节点树变化,新节点被添加到根节点下' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '点击"复制"后,handleCopyNode方法被触发' },
                                  { id: '2', name: 'selectNodes数组(包含被复制的httpNode)被写入剪贴板' },
                                  { id: '3', name: '剪贴板数据格式:{ type: "apiflow-apidoc-node", data: [httpNode数据] }' },
                                  { id: '4', name: 'cutNodes.value被清空(区分复制和剪切)' },
                                  { id: '5', name: '点击"粘贴"后,handlePasteNode方法被触发' },
                                  { id: '6', name: '从剪贴板读取数据并解析JSON' },
                                  { id: '7', name: '调用pasteNodes函数,currentOperationalNode.value为null(表示根节点)' },
                                  { id: '8', name: '生成新的节点ID(使用nanoid)' },
                                  { id: '9', name: '新节点的pid设置为空字符串(根节点)' },
                                  { id: '10', name: '新节点保存到apiNodesCache(离线模式)或调用/api/project/paste_docs(在线模式)' },
                                  { id: '11', name: '新节点被添加到banner节点树的根层级' },
                                  { id: '12', name: '新节点的所有数据(URL,headers,body等)与原节点完全相同,仅ID不同' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'Banner.vue第536-544行:handleCopyNode方法将selectNodes写入剪贴板' },
                                  { id: '2', name: 'Banner.vue第540-543行:navigator.clipboard.writeText写入JSON字符串' },
                                  { id: '3', name: 'Banner.vue第537行:cutNodes.value = []清空剪切节点' },
                                  { id: '4', name: 'Banner.vue第559-579行:handlePasteNode方法从剪贴板读取并粘贴' },
                                  { id: '5', name: 'Banner.vue第560行:检查currentOperationalNode.type !== "folder"时return(仅folder和根节点可粘贴)' },
                                  { id: '6', name: 'Banner.vue第563-564行:navigator.clipboard.readText读取剪贴板' },
                                  { id: '7', name: 'Banner.vue第565-567行:检查copyDataJson.type === "apiflow-apidoc-node"' },
                                  { id: '8', name: 'curd-node.ts第285-431行:pasteNodes函数实现粘贴逻辑' },
                                  { id: '9', name: 'curd-node.ts第286行:深拷贝节点JSON.parse(JSON.stringify(pastedNodes))' },
                                  { id: '10', name: 'curd-node.ts第336-347行:生成新ID并创建processedDoc' },
                                  { id: '11', name: 'curd-node.ts第357-361行:设置pid为currentOperationalNode.value?._id || ""' },
                                  { id: '12', name: 'curd-node.ts第366行:await apiNodesCache.addNode(doc)保存节点' },
                                  { id: '13', name: 'curd-node.ts第386行:addFileAndFolderCb更新UI' },
                                ],
                                notes: [
                                  { id: '1', name: '复制使用浏览器剪贴板API(navigator.clipboard)而非Electron clipboard' },
                                  { id: '2', name: '剪贴板数据包含type字段用于验证数据来源,防止粘贴非法数据' },
                                  { id: '3', name: '复制后可以在任意支持粘贴的位置粘贴,包括跨项目粘贴' },
                                  { id: '4', name: '粘贴到根节点时,currentOperationalNode为null,pid设置为空字符串' },
                                  { id: '5', name: 'nanoid用于生成唯一ID,避免与现有节点冲突' },
                                  { id: '6', name: '复制不会删除原节点,与剪切(cutNodes)区分' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个httpNode节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '项目中存在至少一个httpNode节点' },
                                  { id: '3', name: '项目中存在至少一个folder节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '右键点击一个httpNode节点,选择"复制"(或按Ctrl+C)' },
                                  { id: '2', name: '右键点击一个folder节点(显示folder图标)' },
                                  { id: '3', name: '在右键菜单中点击"粘贴"选项(或按Ctrl+V)' },
                                  { id: '4', name: '观察folder节点展开,新节点被添加到该folder下' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '复制操作将httpNode写入剪贴板' },
                                  { id: '2', name: '粘贴操作检查currentOperationalNode为folder类型' },
                                  { id: '3', name: '调用pasteNodes函数,currentOperationalNode.value为folder节点' },
                                  { id: '4', name: '生成新节点ID(nanoid)' },
                                  { id: '5', name: '新节点的pid设置为folder节点的_id' },
                                  { id: '6', name: '新节点保存到数据库,成为folder的子节点' },
                                  { id: '7', name: 'folder节点自动展开(bannerStore.changeExpandItems)' },
                                  { id: '8', name: '新节点显示在folder节点的子列表中' },
                                  { id: '9', name: '新节点的层级缩进比folder深一级' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'Banner.vue第560行:检查currentOperationalNode.type,folder类型不会return' },
                                  { id: '2', name: 'curd-node.ts第357行:pid = currentOperationalNode.value?._id(folder的_id)' },
                                  { id: '3', name: 'curd-node.ts第385行:pasteNode.pid = currentOperationalNode.value?._id' },
                                  { id: '4', name: 'Banner.vue第575行:bannerStore.changeExpandItems([folder._id])自动展开folder' },
                                  { id: '5', name: 'addFileAndFolderCb函数将新节点添加到folder的children数组' },
                                ],
                                notes: [
                                  { id: '1', name: 'folder节点可以接收粘贴,非folder节点不行' },
                                  { id: '2', name: '粘贴后folder自动展开,方便用户查看新添加的节点' },
                                  { id: '3', name: '新节点成为folder的直接子节点,pid指向folder' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个httpNode节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [
                                  { id: '1', name: '已登录并创建至少两个项目:项目A和项目B' },
                                  { id: '2', name: '项目A中存在至少一个httpNode节点' },
                                  { id: '3', name: '项目B中存在至少一个folder节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '打开项目A工作区' },
                                  { id: '2', name: '右键点击项目A中的一个httpNode节点,选择"复制"' },
                                  { id: '3', name: '切换到项目B工作区(通过顶部tab或主页项目列表)' },
                                  { id: '4', name: '右键点击项目B中的一个folder节点' },
                                  { id: '5', name: '在右键菜单中点击"粘贴"' },
                                  { id: '6', name: '观察节点被添加到项目B的folder下' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '复制操作在项目A中将httpNode写入剪贴板,数据包含projectId字段' },
                                  { id: '2', name: '切换项目不会清空剪贴板数据' },
                                  { id: '3', name: '粘贴操作检测到fromProjectId !== currentProjectId(跨项目粘贴)' },
                                  { id: '4', name: '从项目A的apiNodesCache.getNodesByProjectId获取完整文档数据' },
                                  { id: '5', name: '生成新ID并更新projectId为项目B的ID' },
                                  { id: '6', name: '新节点的pid设置为项目B的folder._id' },
                                  { id: '7', name: '新节点保存到项目B的数据库' },
                                  { id: '8', name: '新节点显示在项目B的folder下,包含完整的请求数据(URL,headers,body等)' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'curd-node.ts第292行:fromProjectId = pastedNodes[0].projectId' },
                                  { id: '2', name: 'curd-node.ts第303行:if (fromProjectId !== currentProjectId)判断跨项目' },
                                  { id: '3', name: 'curd-node.ts第305行:apiNodesCache.getNodesByProjectId(fromProjectId)获取源项目数据' },
                                  { id: '4', name: 'curd-node.ts第342行:processedDoc.projectId = currentProjectId更新项目ID' },
                                  { id: '5', name: 'curd-node.ts第366行:保存到当前项目的数据库' },
                                ],
                                notes: [
                                  { id: '1', name: '跨项目复制是常见需求,用于复用API配置' },
                                  { id: '2', name: '剪贴板使用浏览器API,切换项目不影响剪贴板数据' },
                                  { id: '3', name: '跨项目复制需要获取完整文档数据,因为不同项目的缓存独立' },
                                  { id: '4', name: '新节点的projectId必须更新为目标项目,否则会导致数据混乱' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个httpNode节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [
                                  { id: '1', name: '已登录系统并创建了项目A和项目B' },
                                  { id: '2', name: '项目A中包含至少一个httpNode节点' },
                                  { id: '3', name: '当前在项目A的工作台页面,banner树展开显示节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在项目A的banner树中,右键点击要复制的httpNode节点' },
                                  { id: '2', name: '在右键菜单中点击"复制"选项(或使用ctrl+c快捷键)' },
                                  { id: '3', name: '切换到项目B的工作台页面' },
                                  { id: '4', name: '在banner树的空白区域右键点击(非任何节点上)' },
                                  { id: '5', name: '在右键菜单中点击"粘贴"选项(或使用ctrl+v快捷键)' },
                                  { id: '6', name: '观察项目B的banner树根节点变化' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '复制操作成功,剪贴板包含节点数据(clipboard格式:{"type":"apiflow-apidoc-node","data":[节点数组]})' },
                                  { id: '2', name: '在banner空白区域右键时,菜单显示"粘贴"选项' },
                                  { id: '3', name: '粘贴操作成功,项目B的banner根节点下新增一个httpNode节点' },
                                  { id: '4', name: '新节点被添加到banner树的根节点末尾位置(bannerStore.banner数组末尾)' },
                                  { id: '5', name: '新节点拥有全新的_id(使用nanoid生成)' },
                                  { id: '6', name: '新节点的pid为空字符串(表示根节点)' },
                                  { id: '7', name: '新节点的projectId为项目B的ID' },
                                  { id: '8', name: '新节点的其他属性(url,method,headers,body等)与源节点完全一致' },
                                  { id: '9', name: '源节点(项目A)保持不变,不受影响' },
                                  { id: '10', name: '新节点在项目B的IndexedDB中成功保存' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'Banner.vue的handleCopyNode函数被调用,向剪贴板写入数据(line 535-544)' },
                                  { id: '2', name: 'navigator.clipboard.writeText写入的数据格式正确,type为"apiflow-apidoc-node"' },
                                  { id: '3', name: 'Banner.vue的handlePasteNode函数被调用(line 559-579)' },
                                  { id: '4', name: 'handlePasteNode中currentOperationalNode.value为null(banner空白区域右键)' },
                                  { id: '5', name: 'curd-node.ts的pasteNodes函数被调用(line 285)' },
                                  { id: '6', name: 'pasteNodes检测到跨项目粘贴(fromProjectId !== currentProjectId,line 292)' },
                                  { id: '7', name: 'apiNodesCache.getNodesByProjectId被调用,获取源项目完整doc数据(line 305)' },
                                  { id: '8', name: 'ID映射Map正确生成,源_id映射到新nanoid(line 342)' },
                                  { id: '9', name: '新节点的pid被设置为空字符串(currentOperationalNode.value为null,line 378, 385)' },
                                  { id: '10', name: 'addFileAndFolderCb函数进入else分支,插入到根节点(curd-node.ts line 168)' },
                                  { id: '11', name: 'bannerStore.splice被调用,start为bannerStore.banner.length(添加到数组末尾,line 186)' },
                                  { id: '12', name: 'apiNodesCache.addNodes被调用,保存新节点到IndexedDB(line 366)' },
                                  { id: '13', name: 'bannerStore.banner数组包含新节点' },
                                ],
                                notes: [
                                  { id: '1', name: 'banner空白区域右键时,currentOperationalNode为null,触发插入到根节点的逻辑' },
                                  { id: '2', name: '根节点下的httpNode节点统一添加到数组末尾,folder节点会按特殊规则插入' },
                                  { id: '3', name: '跨项目粘贴必须获取源项目完整doc数据,因为不同项目的IndexedDB缓存相互独立' },
                                  { id: '4', name: 'pid为空字符串表示该节点属于根节点,与pid为projectId效果相同' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个httpNode节点,在非folder节点鼠标右键不会出现粘贴操作',
                                precondition: [
                                  { id: '1', name: '已登录系统并打开项目工作台' },
                                  { id: '2', name: '项目中包含至少两个httpNode节点(节点A和节点B)' },
                                  { id: '3', name: 'banner树展开显示所有节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '右键点击httpNode节点A,选择"复制"(或使用ctrl+c)' },
                                  { id: '2', name: '右键点击httpNode节点B(非folder类型节点)' },
                                  { id: '3', name: '观察右键菜单内容' },
                                  { id: '4', name: '检查菜单中是否有"粘贴"选项' },
                                  { id: '5', name: '检查菜单中是否有"生成副本"选项' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '节点A复制成功,剪贴板包含节点数据' },
                                  { id: '2', name: '在httpNode节点B上右键时,右键菜单正常弹出' },
                                  { id: '3', name: '右键菜单中不显示"粘贴"选项' },
                                  { id: '4', name: '右键菜单中显示"生成副本"选项(热键Ctrl+V)' },
                                  { id: '5', name: '菜单中显示其他常规选项:重命名,删除,复制,剪切等' },
                                  { id: '6', name: '此限制同样适用于其他非folder类型节点(websocket,httpMock,websocketMock等)' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'Banner.vue中粘贴选项的v-show条件为:!currentOperationalNode || currentOperationalNode?.type === "folder"(line 238)' },
                                  { id: '2', name: 'currentOperationalNode.value指向节点B,其type为"http"' },
                                  { id: '3', name: 'v-show条件计算结果为false(因为节点B存在且type不是folder)' },
                                  { id: '4', name: 'SContextmenuItem粘贴组件不渲染到DOM中' },
                                  { id: '5', name: 'Banner.vue中生成副本选项的v-show条件为:currentOperationalNode && currentOperationalNode.type !== "folder"(line 236)' },
                                  { id: '6', name: 'v-show条件计算结果为true(节点B存在且不是folder)' },
                                  { id: '7', name: 'SContextmenuItem生成副本组件渲染到DOM中,绑定Ctrl+V热键' },
                                  { id: '8', name: 'handlePasteNode函数有二次校验(line 560),即使被调用也会直接return' },
                                ],
                                notes: [
                                  { id: '1', name: '粘贴操作只允许在folder节点或banner空白区域执行,这是设计约束' },
                                  { id: '2', name: '在非folder节点上,Ctrl+V热键绑定到"生成副本"功能而非粘贴功能' },
                                  { id: '3', name: '粘贴选项和生成副本选项是互斥的,通过v-show条件控制显示' },
                                  { id: '4', name: '此设计避免了将节点粘贴到不合理位置的错误操作' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个httpNode节点,focus非folder节点ctrl+v不生效',
                                precondition: [
                                  { id: '1', name: '已登录系统并打开项目工作台' },
                                  { id: '2', name: '项目中包含至少两个httpNode节点(节点A和节点B)' },
                                  { id: '3', name: 'banner树展开显示所有节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '右键点击httpNode节点A,选择"复制"(或使用ctrl+c)' },
                                  { id: '2', name: '单击选中httpNode节点B(非folder类型节点),使其获得焦点' },
                                  { id: '3', name: '按下Ctrl+V快捷键' },
                                  { id: '4', name: '观察banner树变化和新节点的创建情况' },
                                  { id: '5', name: '检查新节点的名称和位置' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '节点A复制成功,剪贴板包含节点数据' },
                                  { id: '2', name: '节点B获得焦点,在banner树中高亮显示' },
                                  { id: '3', name: '按下Ctrl+V后,未触发粘贴操作(不从剪贴板粘贴节点A)' },
                                  { id: '4', name: '触发了生成副本操作,创建了节点B的副本节点' },
                                  { id: '5', name: '副本节点的名称为"节点B的名称_副本"' },
                                  { id: '6', name: '副本节点插入到节点B的下一个位置(相邻兄弟节点之间)' },
                                  { id: '7', name: '副本节点拥有全新的_id(使用nanoid生成)' },
                                  { id: '8', name: '副本节点的其他属性(url,method,headers等)与节点B完全一致' },
                                  { id: '9', name: '剪贴板中的节点A数据未被使用' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'Banner.vue中粘贴选项绑定Ctrl+V的v-show条件为false(line 238)' },
                                  { id: '2', name: 'Banner.vue中生成副本选项绑定Ctrl+V的v-show条件为true(line 236-237)' },
                                  { id: '3', name: '按下Ctrl+V时,触发handleForkNode函数(line 546-548)' },
                                  { id: '4', name: 'handleForkNode调用curd-node.ts的forkNode函数(line 436)' },
                                  { id: '5', name: 'forkNode从apiNodesCache获取节点B的完整数据(line 443)' },
                                  { id: '6', name: 'forkNode生成新的nanoid作为副本_id(line 452)' },
                                  { id: '7', name: '副本文档的name字段添加"_副本"后缀(line 460)' },
                                  { id: '8', name: '副本的sort值通过计算插入位置确定(line 450)' },
                                  { id: '9', name: 'apiNodesCache.addNode被调用保存副本到IndexedDB(line 464)' },
                                  { id: '10', name: 'handlePasteNode函数未被调用' },
                                  { id: '11', name: 'navigator.clipboard.readText未被调用(不读取剪贴板)' },
                                ],
                                notes: [
                                  { id: '1', name: '在非folder节点上,Ctrl+V快捷键被生成副本功能独占,不触发粘贴功能' },
                                  { id: '2', name: '生成副本(fork)和粘贴(paste)是两个完全不同的功能:副本复制当前节点,粘贴使用剪贴板数据' },
                                  { id: '3', name: '副本节点的插入位置由sort值控制,插入到原节点的紧邻下一个位置' },
                                  { id: '4', name: '此设计确保在非folder节点上快捷键Ctrl+V有明确的语义(生成副本),不会引起歧义' },
                                ],
                              },
                              {
                                purpose: `A httpNode节点切换到B httpNode节点,按ctrl+c复制节点,可以粘贴(验证各种粘贴模式,不同节点(如:复制到根节点下,复制到folder节点下等)和不同粘贴模式(快捷键和鼠标右键)组合,)`,
                                precondition: [
                                  { id: '1', name: '已登录系统并打开项目工作台' },
                                  { id: '2', name: '项目中包含httpNode节点A,httpNode节点B,folder节点F' },
                                  { id: '3', name: 'banner树展开显示所有节点' },
                                  { id: '4', name: '当前正在编辑httpNode节点A(右侧内容区显示节点A的详情)' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner树中点击httpNode节点B,切换到节点B的编辑界面' },
                                  { id: '2', name: '确认右侧内容区显示节点B的详情(URL,请求参数等)' },
                                  { id: '3', name: '在banner树中单击选中节点B,按ctrl+c复制节点B' },
                                  { id: '4', name: '场景1:在banner空白区域右键,点击"粘贴"' },
                                  { id: '5', name: '验证节点B的副本粘贴到根节点下' },
                                  { id: '6', name: '场景2:在banner空白区域按ctrl+v' },
                                  { id: '7', name: '验证节点B的副本再次粘贴到根节点下' },
                                  { id: '8', name: '场景3:在folder节点F上右键,点击"粘贴"' },
                                  { id: '9', name: '验证节点B的副本粘贴到folder节点F的子节点中' },
                                  { id: '10', name: '场景4:在folder节点F上按ctrl+v' },
                                  { id: '11', name: '验证节点B的副本再次粘贴到folder节点F的子节点中' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '节点切换成功,右侧内容区从节点A切换到节点B' },
                                  { id: '2', name: '在节点B上按ctrl+c,复制操作成功,剪贴板包含节点B数据' },
                                  { id: '3', name: '场景1:右键粘贴到根节点成功,创建节点B的副本在根节点末尾' },
                                  { id: '4', name: '场景2:ctrl+v粘贴到根节点成功,创建节点B的副本在根节点末尾' },
                                  { id: '5', name: '场景3:右键粘贴到folder成功,创建节点B的副本在folder的子节点末尾' },
                                  { id: '6', name: '场景4:ctrl+v粘贴到folder成功,创建节点B的副本在folder的子节点末尾' },
                                  { id: '7', name: '所有粘贴的副本节点拥有全新的_id(使用nanoid生成)' },
                                  { id: '8', name: '所有粘贴的副本节点的其他属性与节点B完全一致' },
                                  { id: '9', name: '所有粘贴的副本节点正确保存到IndexedDB' },
                                  { id: '10', name: '剪贴板数据在多次粘贴后保持不变,可以重复粘贴' },
                                ],
                                checkpoints: [
                                  { id: '1', name: '点击节点B后,projectNavStore更新,节点B的selected属性为true' },
                                  { id: '2', name: 'Banner.vue的handleCopyNode函数被调用(line 535-544)' },
                                  { id: '3', name: 'navigator.clipboard.writeText写入节点B的数据' },
                                  { id: '4', name: '场景1和2:handlePasteNode被调用,currentOperationalNode为null(根节点)' },
                                  { id: '5', name: '场景3和4:handlePasteNode被调用,currentOperationalNode为folder节点F' },
                                  { id: '6', name: 'pasteNodes函数被调用4次,每次都读取剪贴板数据(line 285)' },
                                  { id: '7', name: '每次粘贴都生成新的nanoid,4个副本节点拥有不同的_id' },
                                  { id: '8', name: '场景1和2:addFileAndFolderCb进入根节点插入分支(curd-node.ts line 168)' },
                                  { id: '9', name: '场景3和4:addFileAndFolderCb进入folder子节点插入分支(curd-node.ts line 142)' },
                                  { id: '10', name: 'apiNodesCache.addNodes被调用4次,每次保存一个副本节点' },
                                  { id: '11', name: 'bannerStore.banner数组包含所有新粘贴的节点' },
                                ],
                                notes: [
                                  { id: '1', name: '此测试用例验证节点切换不影响复制粘贴功能的正常工作' },
                                  { id: '2', name: '验证了粘贴操作的两种方式(右键菜单和快捷键)都能正常工作' },
                                  { id: '3', name: '验证了粘贴到两种不同位置(根节点和folder节点)都能正常工作' },
                                  { id: '4', name: '剪贴板数据不会因为粘贴操作而清空,支持多次粘贴' },
                                  { id: '5', name: '每次粘贴都会生成全新的节点副本,互不影响' },
                                ],
                              },
                            ],
                          },
                          {
                            modelName: '复制多个httpNode节点',
                            description: '复制多个httpNode节点',
                            atomicFunc: [
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个httpNode节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [
                                  { id: '1', name: '已登录系统并打开项目工作台' },
                                  { id: '2', name: '项目中包含至少3个httpNode节点(节点A,B,C)' },
                                  { id: '3', name: 'banner树展开显示所有节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '点击选中httpNode节点A' },
                                  { id: '2', name: '按住Ctrl键,依次点击httpNode节点B和节点C,完成多选' },
                                  { id: '3', name: '验证3个节点都处于选中状态(高亮显示)' },
                                  { id: '4', name: '在任意选中节点上右键,打开批量操作菜单' },
                                  { id: '5', name: '点击"批量复制"选项(或使用ctrl+c快捷键)' },
                                  { id: '6', name: '在banner树的空白区域右键点击' },
                                  { id: '7', name: '点击"粘贴"选项(或使用ctrl+v快捷键)' },
                                  { id: '8', name: '观察banner根节点的变化' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '多选操作成功,3个节点同时高亮显示' },
                                  { id: '2', name: '右键菜单显示批量操作选项:批量剪切,批量复制,批量删除' },
                                  { id: '3', name: '批量复制成功,剪贴板包含3个节点的数据数组' },
                                  { id: '4', name: '粘贴操作成功,在根节点下新增3个httpNode节点' },
                                  { id: '5', name: '3个新节点的名称和属性分别与源节点A,B,C一致' },
                                  { id: '6', name: '3个新节点都被添加到banner根节点末尾,保持原有的相对顺序' },
                                  { id: '7', name: '3个新节点都拥有全新的_id(各自使用nanoid生成)' },
                                  { id: '8', name: '3个新节点的pid都为空字符串(表示根节点)' },
                                  { id: '9', name: '源节点A,B,C保持不变,不受影响' },
                                  { id: '10', name: '3个新节点都成功保存到IndexedDB' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'selectNodes数组包含3个节点(line 315)' },
                                  { id: '2', name: '右键菜单条件selectNodes.length > 1为true,显示批量操作菜单(line 247)' },
                                  { id: '3', name: 'Banner.vue的handleCopyNode函数被调用(line 535-544)' },
                                  { id: '4', name: 'navigator.clipboard.writeText写入包含3个节点的数组,type为"apiflow-apidoc-node"(line 542)' },
                                  { id: '5', name: 'Banner.vue的handlePasteNode函数被调用(line 559-579)' },
                                  { id: '6', name: 'curd-node.ts的pasteNodes函数被调用,pastedNodes参数包含3个节点(line 285)' },
                                  { id: '7', name: 'pasteNodes函数遍历copyPasteNodes数组,使用flatTree展开所有节点(line 299)' },
                                  { id: '8', name: '为3个节点分别生成新的nanoid作为_id(line 342)' },
                                  { id: '9', name: '3个新节点的pid都被设置为空字符串(currentOperationalNode为null,line 378, 385)' },
                                  { id: '10', name: 'addFileAndFolderCb函数被调用3次,每次插入一个节点到根节点(line 386)' },
                                  { id: '11', name: 'bannerStore.splice被调用3次,依次添加到banner数组末尾(curd-node.ts line 186)' },
                                  { id: '12', name: 'apiNodesCache.addNodes被调用,批量保存3个节点到IndexedDB(line 366)' },
                                  { id: '13', name: 'bannerStore.banner数组包含所有3个新节点' },
                                ],
                                notes: [
                                  { id: '1', name: '多选通过按住Ctrl键依次点击节点实现,selectNodes数组记录所有选中节点' },
                                  { id: '2', name: '多选时右键菜单只显示批量操作选项,不显示单个节点的操作选项如"生成副本"' },
                                  { id: '3', name: '批量复制将整个selectNodes数组写入剪贴板,粘贴时批量处理所有节点' },
                                  { id: '4', name: '批量粘贴时节点的相对顺序保持不变,按照selectNodes数组的顺序依次插入' },
                                  { id: '5', name: 'pasteNodes函数使用flatTree展开嵌套节点,确保folder下的子节点也被正确复制' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个httpNode节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [
                                  { id: '1', name: '已登录系统并打开项目工作台' },
                                  { id: '2', name: '项目中包含至少3个httpNode节点(节点A,B,C)和1个folder节点F' },
                                  { id: '3', name: 'banner树展开显示所有节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '按住Ctrl键,依次点击httpNode节点A,B,C,完成多选' },
                                  { id: '2', name: '在任意选中节点上右键,点击"批量复制"(或使用ctrl+c)' },
                                  { id: '3', name: '在folder节点F上右键点击' },
                                  { id: '4', name: '点击"粘贴"选项(或使用ctrl+v快捷键)' },
                                  { id: '5', name: '观察folder节点F的子节点变化' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '多选操作成功,3个节点同时高亮' },
                                  { id: '2', name: '批量复制成功,剪贴板包含3个节点的数据' },
                                  { id: '3', name: '粘贴操作成功,folder节点F下新增3个httpNode节点' },
                                  { id: '4', name: '3个新节点被添加到folder F的子节点列表末尾' },
                                  { id: '5', name: '3个新节点的pid都为folder节点F的_id' },
                                  { id: '6', name: '3个新节点都拥有全新的_id' },
                                  { id: '7', name: '3个新节点的其他属性与源节点一致' },
                                  { id: '8', name: 'folder节点F自动展开显示新粘贴的子节点' },
                                  { id: '9', name: '3个新节点成功保存到IndexedDB' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'selectNodes数组包含3个httpNode节点' },
                                  { id: '2', name: 'handleCopyNode写入3个节点到剪贴板(Banner.vue line 542)' },
                                  { id: '3', name: 'handlePasteNode被调用,currentOperationalNode为folder节点F(line 560)' },
                                  { id: '4', name: 'pasteNodes函数被调用,处理3个节点的粘贴(curd-node.ts line 285)' },
                                  { id: '5', name: '3个新节点的pid都被设置为folder F的_id(line 378, 385)' },
                                  { id: '6', name: 'addFileAndFolderCb被调用3次,插入到folder子节点末尾(line 162)' },
                                  { id: '7', name: 'bannerStore.changeExpandItems被调用,展开folder节点F(Banner.vue line 576)' },
                                  { id: '8', name: 'apiNodesCache.addNodes批量保存3个节点(curd-node.ts line 366)' },
                                ],
                                notes: [
                                  { id: '1', name: '批量粘贴到folder时,所有节点都成为folder的直接子节点' },
                                  { id: '2', name: 'folder节点会自动展开以显示新粘贴的子节点' },
                                  { id: '3', name: '粘贴后节点的相对顺序保持不变' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个httpNode节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [
                                  { id: '1', name: '已登录系统并创建了项目A和项目B' },
                                  { id: '2', name: '项目A中包含至少3个httpNode节点' },
                                  { id: '3', name: '项目B中包含至少1个folder节点F' },
                                  { id: '4', name: '当前在项目A的工作台页面' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在项目A中,按住Ctrl键多选3个httpNode节点' },
                                  { id: '2', name: '右键点击"批量复制"(或ctrl+c)' },
                                  { id: '3', name: '切换到项目B的工作台页面' },
                                  { id: '4', name: '在folder节点F上右键点击' },
                                  { id: '5', name: '点击"粘贴"选项(或ctrl+v)' },
                                  { id: '6', name: '观察folder节点F的子节点变化' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '批量复制成功,剪贴板包含项目A的3个节点数据' },
                                  { id: '2', name: '粘贴操作成功,项目B的folder F下新增3个httpNode节点' },
                                  { id: '3', name: '3个新节点的projectId都为项目B的ID' },
                                  { id: '4', name: '3个新节点的pid都为folder F的_id' },
                                  { id: '5', name: '3个新节点都拥有全新的_id' },
                                  { id: '6', name: '3个新节点的其他属性与源节点一致' },
                                  { id: '7', name: '项目A的源节点保持不变' },
                                  { id: '8', name: '3个新节点保存到项目B的IndexedDB' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'pasteNodes检测到跨项目粘贴(fromProjectId !== currentProjectId,line 292)' },
                                  { id: '2', name: 'apiNodesCache.getNodesByProjectId获取项目A的完整doc数据(line 305)' },
                                  { id: '3', name: '为3个节点分别生成新的_id(line 342)' },
                                  { id: '4', name: '3个新节点的projectId更新为项目B的ID' },
                                  { id: '5', name: '3个新节点的pid设置为folder F的_id(line 378)' },
                                  { id: '6', name: 'addFileAndFolderCb被调用3次,插入到folder F的子节点(line 386)' },
                                  { id: '7', name: 'apiNodesCache.addNodes保存到项目B的IndexedDB(line 366)' },
                                ],
                                notes: [
                                  { id: '1', name: '跨项目批量粘贴需要从源项目获取完整文档数据' },
                                  { id: '2', name: '所有新节点的projectId必须更新为目标项目ID' },
                                  { id: '3', name: '批量操作在跨项目时的处理逻辑与单个节点一致' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个httpNode节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [
                                  { id: '1', name: '已登录系统并创建了项目A和项目B' },
                                  { id: '2', name: '项目A中包含至少3个httpNode节点' },
                                  { id: '3', name: '当前在项目A的工作台页面' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在项目A中,按住Ctrl键多选3个httpNode节点' },
                                  { id: '2', name: '右键点击"批量复制"(或ctrl+c)' },
                                  { id: '3', name: '切换到项目B的工作台页面' },
                                  { id: '4', name: '在banner空白区域右键点击' },
                                  { id: '5', name: '点击"粘贴"选项(或ctrl+v)' },
                                  { id: '6', name: '观察项目B的banner根节点变化' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '批量复制成功,剪贴板包含项目A的3个节点数据' },
                                  { id: '2', name: '粘贴操作成功,项目B的根节点下新增3个httpNode节点' },
                                  { id: '3', name: '3个新节点被添加到banner根节点末尾' },
                                  { id: '4', name: '3个新节点的projectId都为项目B的ID' },
                                  { id: '5', name: '3个新节点的pid都为空字符串(根节点)' },
                                  { id: '6', name: '3个新节点都拥有全新的_id' },
                                  { id: '7', name: '项目A的源节点保持不变' },
                                  { id: '8', name: '3个新节点保存到项目B的IndexedDB' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'pasteNodes检测到跨项目粘贴(fromProjectId !== currentProjectId,line 292)' },
                                  { id: '2', name: 'apiNodesCache.getNodesByProjectId获取项目A的完整doc数据(line 305)' },
                                  { id: '3', name: 'currentOperationalNode为null(banner空白区域)' },
                                  { id: '4', name: '为3个节点分别生成新的_id(line 342)' },
                                  { id: '5', name: '3个新节点的pid设置为空字符串(line 378, 385)' },
                                  { id: '6', name: 'addFileAndFolderCb进入根节点插入分支(curd-node.ts line 168)' },
                                  { id: '7', name: 'bannerStore.splice被调用3次,添加到banner数组末尾(line 186)' },
                                  { id: '8', name: 'apiNodesCache.addNodes保存到项目B的IndexedDB(line 366)' },
                                ],
                                notes: [
                                  { id: '1', name: '跨项目批量粘贴到根节点时,所有节点的pid为空字符串' },
                                  { id: '2', name: '批量操作保持节点的原有顺序不变' },
                                  { id: '3', name: '跨项目粘贴必须更新projectId,避免数据混乱' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个httpNode节点,在非folder节点鼠标右键不会出现粘贴操作',
                                precondition: [
                                  { id: '1', name: '已登录系统并打开项目工作台' },
                                  { id: '2', name: '项目中包含至少4个httpNode节点' },
                                  { id: '3', name: 'banner树展开显示所有节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '按住Ctrl键,多选3个httpNode节点' },
                                  { id: '2', name: '右键点击"批量复制"(或ctrl+c)' },
                                  { id: '3', name: '右键点击另一个httpNode节点D(非folder类型)' },
                                  { id: '4', name: '观察右键菜单内容' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '批量复制成功,剪贴板包含3个节点数据' },
                                  { id: '2', name: '在节点D上右键时,右键菜单正常弹出' },
                                  { id: '3', name: '右键菜单中不显示"粘贴"选项' },
                                  { id: '4', name: '右键菜单显示单个节点操作选项(重命名,删除,复制,生成副本等)' },
                                  { id: '5', name: '此限制同样适用于其他非folder类型节点' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'selectNodes数组包含3个httpNode节点' },
                                  { id: '2', name: '点击节点D后,selectNodes数组重置为只包含节点D(单选模式,line 411)' },
                                  { id: '3', name: '右键菜单条件selectNodes.length <= 1为true,显示单选菜单(line 221)' },
                                  { id: '4', name: '粘贴选项的v-show条件为false(节点D存在且不是folder,line 238)' },
                                  { id: '5', name: '生成副本选项的v-show条件为true(line 236)' },
                                ],
                                notes: [
                                  { id: '1', name: '在非folder节点上右键会退出多选模式,进入单选模式' },
                                  { id: '2', name: '粘贴选项只在folder节点或banner空白区域显示' },
                                  { id: '3', name: '多选复制后,在非folder节点右键不能粘贴,只能在folder或空白区域粘贴' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个httpNode节点,focus 非folder节点ctrl+v不生效',
                                precondition: [
                                  { id: '1', name: '已登录系统并打开项目工作台' },
                                  { id: '2', name: '项目中包含至少4个httpNode节点' },
                                  { id: '3', name: 'banner树展开显示所有节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '按住Ctrl键,多选3个httpNode节点' },
                                  { id: '2', name: '右键点击"批量复制"(或ctrl+c)' },
                                  { id: '3', name: '单击选中另一个httpNode节点D,使其获得焦点' },
                                  { id: '4', name: '按下Ctrl+V快捷键' },
                                  { id: '5', name: '观察banner树变化' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '批量复制成功,剪贴板包含3个节点数据' },
                                  { id: '2', name: '节点D获得焦点,在banner树中高亮显示' },
                                  { id: '3', name: '按下Ctrl+V后,未触发粘贴操作(不从剪贴板粘贴3个节点)' },
                                  { id: '4', name: '触发了生成副本操作,创建了节点D的副本节点' },
                                  { id: '5', name: '副本节点的名称为"节点D的名称_副本"' },
                                  { id: '6', name: '副本节点插入到节点D的下一个位置' },
                                  { id: '7', name: '剪贴板中的3个节点数据未被使用' },
                                ],
                                checkpoints: [
                                  { id: '1', name: '点击节点D后,selectNodes数组重置为只包含节点D' },
                                  { id: '2', name: '粘贴选项绑定Ctrl+V的v-show条件为false(line 238)' },
                                  { id: '3', name: '生成副本选项绑定Ctrl+V的v-show条件为true(line 236-237)' },
                                  { id: '4', name: '按下Ctrl+V时,触发handleForkNode函数(line 546-548)' },
                                  { id: '5', name: 'forkNode生成节点D的副本(curd-node.ts line 436)' },
                                  { id: '6', name: 'handlePasteNode函数未被调用' },
                                  { id: '7', name: 'navigator.clipboard.readText未被调用(不读取剪贴板)' },
                                ],
                                notes: [
                                  { id: '1', name: '在非folder节点上,Ctrl+V快捷键触发生成副本功能,不触发粘贴功能' },
                                  { id: '2', name: '即使剪贴板中有多个节点数据,也不会被粘贴' },
                                  { id: '3', name: '生成副本只复制当前焦点节点,与剪贴板内容无关' },
                                ],
                              },
                            ],
                          },
                        ],
                      },
                      //复制websocketNode节点
                      {
                        modelName: '复制websocketNode节点',
                        description: '复制websocketNode节点',
                        children: [
                          {
                            modelName: '复制单个websocketNode节点',
                            description: '复制单个websocketNode节点',
                            atomicFunc: [
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个websocketNode节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [
                                  { id: '1', name: '已登录系统并打开项目工作台' },
                                  { id: '2', name: '项目中包含至少一个websocketNode节点' },
                                  { id: '3', name: 'banner树展开显示节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner树中右键点击websocketNode节点' },
                                  { id: '2', name: '在右键菜单中点击"复制"选项(或使用ctrl+c快捷键)' },
                                  { id: '3', name: '在banner树的空白区域右键点击' },
                                  { id: '4', name: '在右键菜单中点击"粘贴"选项(或使用ctrl+v快捷键)' },
                                  { id: '5', name: '观察banner根节点的变化' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '复制操作成功,剪贴板包含websocketNode节点数据' },
                                  { id: '2', name: '在空白区域右键时,菜单显示"粘贴"选项' },
                                  { id: '3', name: '粘贴操作成功,在根节点下新增一个websocketNode节点' },
                                  { id: '4', name: '新节点被添加到banner根节点末尾' },
                                  { id: '5', name: '新节点拥有全新的_id(使用nanoid生成)' },
                                  { id: '6', name: '新节点的pid为空字符串(表示根节点)' },
                                  { id: '7', name: '新节点的type为"websocket"' },
                                  { id: '8', name: '新节点的其他属性(url,连接参数等)与源节点完全一致' },
                                  { id: '9', name: '源节点保持不变,不受影响' },
                                  { id: '10', name: '新节点成功保存到IndexedDB' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'Banner.vue的handleCopyNode函数被调用(line 535-544)' },
                                  { id: '2', name: 'navigator.clipboard.writeText写入websocketNode数据,type为"apiflow-apidoc-node"' },
                                  { id: '3', name: 'Banner.vue的handlePasteNode函数被调用(line 559-579)' },
                                  { id: '4', name: 'currentOperationalNode.value为null(banner空白区域)' },
                                  { id: '5', name: 'curd-node.ts的pasteNodes函数被调用(line 285)' },
                                  { id: '6', name: '生成新的nanoid作为_id(line 342)' },
                                  { id: '7', name: '新节点的pid被设置为空字符串(line 378, 385)' },
                                  { id: '8', name: 'addFileAndFolderCb进入根节点插入分支(curd-node.ts line 168)' },
                                  { id: '9', name: 'bannerStore.splice添加到banner数组末尾(line 186)' },
                                  { id: '10', name: 'apiNodesCache.addNodes保存到IndexedDB(line 366)' },
                                ],
                                notes: [
                                  { id: '1', name: 'websocketNode的复制粘贴逻辑与httpNode完全相同' },
                                  { id: '2', name: '粘贴到根节点时pid为空字符串,表示该节点属于根节点' },
                                  { id: '3', name: '复制粘贴支持所有节点类型(http,websocket,httpMock,websocketMock,folder)' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个websocketNode节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [
                                  { id: '1', name: '已登录系统并打开项目工作台' },
                                  { id: '2', name: '项目中包含至少一个websocketNode节点和一个folder节点' },
                                  { id: '3', name: 'banner树展开显示所有节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '右键点击websocketNode节点,选择"复制"(或ctrl+c)' },
                                  { id: '2', name: '右键点击folder节点' },
                                  { id: '3', name: '点击"粘贴"选项(或ctrl+v)' },
                                  { id: '4', name: '观察folder节点的子节点变化' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '复制成功,剪贴板包含websocketNode数据' },
                                  { id: '2', name: '粘贴成功,folder节点下新增一个websocketNode节点' },
                                  { id: '3', name: '新节点添加到folder的子节点列表末尾' },
                                  { id: '4', name: '新节点的pid为folder节点的_id' },
                                  { id: '5', name: '新节点拥有全新的_id' },
                                  { id: '6', name: '新节点的其他属性与源节点一致' },
                                  { id: '7', name: 'folder节点自动展开显示新节点' },
                                  { id: '8', name: '新节点成功保存到IndexedDB' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCopyNode写入websocketNode到剪贴板' },
                                  { id: '2', name: 'handlePasteNode被调用,currentOperationalNode为folder节点(line 560)' },
                                  { id: '3', name: 'pasteNodes函数处理粘贴(line 285)' },
                                  { id: '4', name: '新节点的pid设置为folder的_id(line 378)' },
                                  { id: '5', name: 'addFileAndFolderCb插入到folder子节点末尾(line 162)' },
                                  { id: '6', name: 'bannerStore.changeExpandItems展开folder(Banner.vue line 576)' },
                                  { id: '7', name: 'apiNodesCache.addNodes保存节点(line 366)' },
                                ],
                                notes: [
                                  { id: '1', name: '粘贴到folder时,新节点成为folder的直接子节点' },
                                  { id: '2', name: 'folder会自动展开以显示新粘贴的子节点' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个websocketNode节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [
                                  { id: '1', name: '已登录系统并创建了项目A和项目B' },
                                  { id: '2', name: '项目A中包含至少一个websocketNode节点' },
                                  { id: '3', name: '项目B中包含至少一个folder节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在项目A中右键复制websocketNode节点' },
                                  { id: '2', name: '切换到项目B' },
                                  { id: '3', name: '在folder节点上右键粘贴' },
                                  { id: '4', name: '观察folder节点变化' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,项目B的folder下新增websocketNode节点' },
                                  { id: '2', name: '新节点的projectId为项目B的ID' },
                                  { id: '3', name: '新节点的pid为folder的_id' },
                                  { id: '4', name: '新节点拥有全新的_id' },
                                  { id: '5', name: '新节点的其他属性与源节点一致' },
                                  { id: '6', name: '项目A的源节点保持不变' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'pasteNodes检测到跨项目粘贴(line 292)' },
                                  { id: '2', name: 'apiNodesCache.getNodesByProjectId获取项目A的完整doc数据(line 305)' },
                                  { id: '3', name: '新节点的projectId更新为项目B的ID' },
                                  { id: '4', name: '新节点的pid设置为folder的_id(line 378)' },
                                  { id: '5', name: 'apiNodesCache.addNodes保存到项目B的IndexedDB(line 366)' },
                                ],
                                notes: [
                                  { id: '1', name: '跨项目粘贴需要获取源项目完整文档数据' },
                                  { id: '2', name: 'projectId必须更新为目标项目ID' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个websocketNode节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [
                                  { id: '1', name: '已登录系统并创建了项目A和项目B' },
                                  { id: '2', name: '项目A中包含至少一个websocketNode节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在项目A中右键复制websocketNode节点' },
                                  { id: '2', name: '切换到项目B' },
                                  { id: '3', name: '在banner空白区域右键粘贴' },
                                  { id: '4', name: '观察项目B的banner根节点变化' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,项目B的根节点下新增websocketNode节点' },
                                  { id: '2', name: '新节点添加到banner根节点末尾' },
                                  { id: '3', name: '新节点的projectId为项目B的ID' },
                                  { id: '4', name: '新节点的pid为空字符串' },
                                  { id: '5', name: '新节点拥有全新的_id' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'pasteNodes检测到跨项目粘贴(line 292)' },
                                  { id: '2', name: 'currentOperationalNode为null(banner空白区域)' },
                                  { id: '3', name: '新节点的pid设置为空字符串(line 378, 385)' },
                                  { id: '4', name: 'addFileAndFolderCb进入根节点插入分支(line 168)' },
                                ],
                                notes: [
                                  { id: '1', name: '跨项目粘贴到根节点,pid为空字符串' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个websocketNode节点,在非folder节点鼠标右键不会出现粘贴操作',
                                precondition: [
                                  { id: '1', name: '已登录系统并打开项目工作台' },
                                  { id: '2', name: '项目中包含至少两个websocketNode节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '右键复制websocketNode节点A' },
                                  { id: '2', name: '右键点击websocketNode节点B' },
                                  { id: '3', name: '观察右键菜单内容' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '右键菜单中不显示"粘贴"选项' },
                                  { id: '2', name: '右键菜单显示"生成副本"选项(Ctrl+V)' },
                                ],
                                checkpoints: [
                                  { id: '1', name: '粘贴选项的v-show条件为false(line 238)' },
                                  { id: '2', name: '生成副本选项的v-show条件为true(line 236)' },
                                ],
                                notes: [
                                  { id: '1', name: '粘贴操作只允许在folder节点或banner空白区域执行' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个websocketNode节点,focus非folder节点ctrl+v不生效',
                                precondition: [
                                  { id: '1', name: '已登录系统并打开项目工作台' },
                                  { id: '2', name: '项目中包含至少两个websocketNode节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '右键复制websocketNode节点A' },
                                  { id: '2', name: '单击选中websocketNode节点B' },
                                  { id: '3', name: '按下Ctrl+V' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '未触发粘贴操作' },
                                  { id: '2', name: '触发生成副本操作,创建节点B的副本' },
                                  { id: '3', name: '副本节点名称为"节点B名称_副本"' },
                                ],
                                checkpoints: [
                                  { id: '1', name: '按下Ctrl+V触发handleForkNode(line 546)' },
                                  { id: '2', name: 'forkNode生成节点B的副本(line 436)' },
                                  { id: '3', name: 'handlePasteNode未被调用' },
                                ],
                                notes: [
                                  { id: '1', name: 'Ctrl+V在非folder节点上触发生成副本,不触发粘贴' },
                                ],
                              },
                              {
                                purpose: `A websocketNode节点切换到B websocketNode节点,按ctrl+c复制节点,可以粘贴(验证各种粘贴模式,不同节点(如:复制到根节点下,复制到folder节点下等)和不同粘贴模式(快捷键和鼠标右键)组合,)`,
                                precondition: [
                                  { id: '1', name: '已登录系统并打开项目工作台' },
                                  { id: '2', name: '项目中包含websocketNode节点A,B和folder节点F' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '点击切换到websocketNode节点B' },
                                  { id: '2', name: '按ctrl+c复制节点B' },
                                  { id: '3', name: '场景1:在banner空白区域右键粘贴' },
                                  { id: '4', name: '场景2:在banner空白区域ctrl+v粘贴' },
                                  { id: '5', name: '场景3:在folder节点F上右键粘贴' },
                                  { id: '6', name: '场景4:在folder节点F上ctrl+v粘贴' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '场景1:粘贴成功,根节点下新增节点B副本' },
                                  { id: '2', name: '场景2:粘贴成功,根节点下新增节点B副本' },
                                  { id: '3', name: '场景3:粘贴成功,folder F下新增节点B副本' },
                                  { id: '4', name: '场景4:粘贴成功,folder F下新增节点B副本' },
                                  { id: '5', name: '所有副本节点拥有全新的_id' },
                                  { id: '6', name: '剪贴板数据可重复粘贴' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCopyNode写入节点B数据到剪贴板' },
                                  { id: '2', name: 'pasteNodes被调用4次,每次读取剪贴板数据' },
                                  { id: '3', name: '每次粘贴生成新的nanoid' },
                                  { id: '4', name: 'apiNodesCache.addNodes被调用4次' },
                                ],
                                notes: [
                                  { id: '1', name: '节点切换不影响复制粘贴功能' },
                                  { id: '2', name: '验证了两种粘贴方式和两种粘贴位置的组合' },
                                ],
                              },
                            ],
                          },
                          {
                            modelName: '复制多个websocketNode节点',
                            description: '复制多个websocketNode节点',
                            atomicFunc: [
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个websocketNode节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [
                                  { id: '1', name: '已登录系统并打开项目工作台' },
                                  { id: '2', name: '项目中包含至少3个websocketNode节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '按住Ctrl键,依次点击3个websocketNode节点,完成多选' },
                                  { id: '2', name: '右键点击"批量复制"(或ctrl+c)' },
                                  { id: '3', name: '在banner空白区域右键粘贴(或ctrl+v)' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '批量复制成功,剪贴板包含3个节点数据' },
                                  { id: '2', name: '粘贴成功,根节点下新增3个websocketNode节点' },
                                  { id: '3', name: '3个新节点添加到banner根节点末尾,保持原有顺序' },
                                  { id: '4', name: '3个新节点都拥有全新的_id' },
                                  { id: '5', name: '3个新节点的pid都为空字符串' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'selectNodes数组包含3个websocketNode节点' },
                                  { id: '2', name: 'handleCopyNode写入3个节点到剪贴板(line 542)' },
                                  { id: '3', name: 'pasteNodes处理3个节点的粘贴(line 285)' },
                                  { id: '4', name: 'apiNodesCache.addNodes批量保存3个节点(line 366)' },
                                ],
                                notes: [
                                  { id: '1', name: '批量粘贴时节点的相对顺序保持不变' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个websocketNode节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [
                                  { id: '1', name: '已登录系统并打开项目工作台' },
                                  { id: '2', name: '项目中包含至少3个websocketNode节点和1个folder节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '按住Ctrl键,多选3个websocketNode节点' },
                                  { id: '2', name: '右键"批量复制"' },
                                  { id: '3', name: '在folder节点上右键粘贴' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,folder下新增3个websocketNode节点' },
                                  { id: '2', name: '3个新节点的pid都为folder的_id' },
                                  { id: '3', name: 'folder节点自动展开显示新节点' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'pasteNodes处理3个节点(line 285)' },
                                  { id: '2', name: 'addFileAndFolderCb被调用3次,插入到folder子节点(line 162)' },
                                  { id: '3', name: 'bannerStore.changeExpandItems展开folder(line 576)' },
                                ],
                                notes: [
                                  { id: '1', name: '批量粘贴到folder时,所有节点都成为folder的直接子节点' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个websocketNode节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [
                                  { id: '1', name: '已登录系统并创建了项目A和项目B' },
                                  { id: '2', name: '项目A中包含至少3个websocketNode节点' },
                                  { id: '3', name: '项目B中包含至少1个folder节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在项目A中,多选3个websocketNode节点并批量复制' },
                                  { id: '2', name: '切换到项目B' },
                                  { id: '3', name: '在folder节点上右键粘贴' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,项目B的folder下新增3个websocketNode节点' },
                                  { id: '2', name: '3个新节点的projectId都为项目B的ID' },
                                  { id: '3', name: '3个新节点的pid都为folder的_id' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'pasteNodes检测到跨项目粘贴(line 292)' },
                                  { id: '2', name: 'apiNodesCache.getNodesByProjectId获取项目A的完整doc数据(line 305)' },
                                  { id: '3', name: '3个新节点的projectId更新为项目B的ID' },
                                ],
                                notes: [
                                  { id: '1', name: '跨项目批量粘贴需要从源项目获取完整文档数据' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个websocketNode节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [
                                  { id: '1', name: '已登录系统并创建了项目A和项目B' },
                                  { id: '2', name: '项目A中包含至少3个websocketNode节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在项目A中,多选3个websocketNode节点并批量复制' },
                                  { id: '2', name: '切换到项目B' },
                                  { id: '3', name: '在banner空白区域右键粘贴' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,项目B的根节点下新增3个websocketNode节点' },
                                  { id: '2', name: '3个新节点的projectId都为项目B的ID' },
                                  { id: '3', name: '3个新节点的pid都为空字符串' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'pasteNodes检测到跨项目粘贴(line 292)' },
                                  { id: '2', name: 'currentOperationalNode为null(banner空白区域)' },
                                  { id: '3', name: 'addFileAndFolderCb进入根节点插入分支(line 168)' },
                                ],
                                notes: [
                                  { id: '1', name: '跨项目批量粘贴到根节点时,所有节点的pid为空字符串' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个websocketNode节点,在非folder节点鼠标右键不会出现粘贴操作',
                                precondition: [
                                  { id: '1', name: '已登录系统并打开项目工作台' },
                                  { id: '2', name: '项目中包含至少4个websocketNode节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '多选3个websocketNode节点并批量复制' },
                                  { id: '2', name: '右键点击另一个websocketNode节点' },
                                  { id: '3', name: '观察右键菜单' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '右键菜单中不显示"粘贴"选项' },
                                  { id: '2', name: '显示单个节点操作选项(重命名,删除,生成副本等)' },
                                ],
                                checkpoints: [
                                  { id: '1', name: '点击节点后,selectNodes数组重置为单选模式(line 411)' },
                                  { id: '2', name: '粘贴选项的v-show条件为false(line 238)' },
                                ],
                                notes: [
                                  { id: '1', name: '在非folder节点上右键会退出多选模式,进入单选模式' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个websocketNode节点,focus 非folder节点ctrl+v不生效',
                                precondition: [
                                  { id: '1', name: '已登录系统并打开项目工作台' },
                                  { id: '2', name: '项目中包含至少4个websocketNode节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '多选3个websocketNode节点并批量复制' },
                                  { id: '2', name: '单击选中另一个websocketNode节点' },
                                  { id: '3', name: '按下Ctrl+V' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '未触发粘贴操作' },
                                  { id: '2', name: '触发生成副本操作,创建当前节点的副本' },
                                ],
                                checkpoints: [
                                  { id: '1', name: '按下Ctrl+V触发handleForkNode(line 546)' },
                                  { id: '2', name: 'handlePasteNode未被调用' },
                                ],
                                notes: [
                                  { id: '1', name: 'Ctrl+V在非folder节点上触发生成副本,不触发粘贴' },
                                ],
                              },
                            ],
                          },
                        ],
                      },
                      //复制httpMockNode节点
                      {
                        modelName: '复制httpMockNode节点',
                        description: '复制httpMockNode节点',
                        children: [
                          {
                            modelName: '复制单个httpMockNode节点',
                            description: '复制单个httpMockNode节点',
                            atomicFunc: [
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个httpMockNode节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [{ id: '1', name: '已登录系统并打开项目工作台' }, { id: '2', name: '项目中包含至少一个httpMockNode节点' }],
                                operationSteps: [{ id: '1', name: '右键复制httpMockNode节点' }, { id: '2', name: '在banner空白区域右键粘贴' }],
                                expectedResults: [{ id: '1', name: '粘贴成功,根节点下新增一个httpMockNode节点' }, { id: '2', name: '新节点拥有全新的_id' }, { id: '3', name: '新节点的pid为空字符串' }, { id: '4', name: '新节点的type为"httpMock"' }],
                                checkpoints: [{ id: '1', name: 'handleCopyNode写入httpMockNode数据到剪贴板(line 535-544)' }, { id: '2', name: 'pasteNodes函数处理粘贴(line 285)' }, { id: '3', name: 'apiNodesCache.addNodes保存到IndexedDB(line 366)' }],
                                notes: [{ id: '1', name: 'httpMockNode的复制粘贴逻辑与其他节点类型完全相同' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个httpMockNode节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [{ id: '1', name: '已登录系统并打开项目工作台' }, { id: '2', name: '项目中包含httpMockNode节点和folder节点' }],
                                operationSteps: [{ id: '1', name: '右键复制httpMockNode节点' }, { id: '2', name: '在folder节点上右键粘贴' }],
                                expectedResults: [{ id: '1', name: '粘贴成功,folder下新增httpMockNode节点' }, { id: '2', name: '新节点的pid为folder的_id' }],
                                checkpoints: [{ id: '1', name: 'pasteNodes处理粘贴(line 285)' }, { id: '2', name: 'addFileAndFolderCb插入到folder子节点(line 162)' }],
                                notes: [{ id: '1', name: 'folder会自动展开显示新节点' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个httpMockNode节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [{ id: '1', name: '已创建项目A和项目B' }, { id: '2', name: '项目A中包含httpMockNode节点' }, { id: '3', name: '项目B中包含folder节点' }],
                                operationSteps: [{ id: '1', name: '在项目A中复制httpMockNode节点' }, { id: '2', name: '切换到项目B' }, { id: '3', name: '在folder节点上粘贴' }],
                                expectedResults: [{ id: '1', name: '粘贴成功,项目B的folder下新增httpMockNode节点' }, { id: '2', name: '新节点的projectId为项目B的ID' }],
                                checkpoints: [{ id: '1', name: 'pasteNodes检测到跨项目粘贴(line 292)' }, { id: '2', name: 'apiNodesCache.getNodesByProjectId获取项目A的完整doc数据(line 305)' }],
                                notes: [{ id: '1', name: '跨项目粘贴需要获取源项目完整文档数据' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个httpMockNode节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [{ id: '1', name: '已创建项目A和项目B' }, { id: '2', name: '项目A中包含httpMockNode节点' }],
                                operationSteps: [{ id: '1', name: '在项目A中复制httpMockNode节点' }, { id: '2', name: '切换到项目B' }, { id: '3', name: '在banner空白区域粘贴' }],
                                expectedResults: [{ id: '1', name: '粘贴成功,项目B的根节点下新增httpMockNode节点' }, { id: '2', name: '新节点的projectId为项目B的ID' }, { id: '3', name: '新节点的pid为空字符串' }],
                                checkpoints: [{ id: '1', name: 'pasteNodes检测到跨项目粘贴(line 292)' }, { id: '2', name: 'addFileAndFolderCb进入根节点插入分支(line 168)' }],
                                notes: [{ id: '1', name: '跨项目粘贴到根节点,pid为空字符串' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个httpMockNode节点,在非folder节点鼠标右键不会出现粘贴操作',
                                precondition: [{ id: '1', name: '已登录系统并打开项目工作台' }, { id: '2', name: '项目中包含至少两个httpMockNode节点' }],
                                operationSteps: [{ id: '1', name: '右键复制httpMockNode节点A' }, { id: '2', name: '右键点击httpMockNode节点B' }],
                                expectedResults: [{ id: '1', name: '右键菜单中不显示"粘贴"选项' }, { id: '2', name: '显示"生成副本"选项' }],
                                checkpoints: [{ id: '1', name: '粘贴选项的v-show条件为false(line 238)' }],
                                notes: [{ id: '1', name: '粘贴操作只允许在folder节点或banner空白区域执行' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个httpMockNode节点,focus非folder节点ctrl+v不生效',
                                precondition: [{ id: '1', name: '已登录系统并打开项目工作台' }, { id: '2', name: '项目中包含至少两个httpMockNode节点' }],
                                operationSteps: [{ id: '1', name: '右键复制httpMockNode节点A' }, { id: '2', name: '单击选中httpMockNode节点B' }, { id: '3', name: '按下Ctrl+V' }],
                                expectedResults: [{ id: '1', name: '未触发粘贴操作' }, { id: '2', name: '触发生成副本操作,创建节点B的副本' }],
                                checkpoints: [{ id: '1', name: '按下Ctrl+V触发handleForkNode(line 546)' }, { id: '2', name: 'handlePasteNode未被调用' }],
                                notes: [{ id: '1', name: 'Ctrl+V在非folder节点上触发生成副本,不触发粘贴' }],
                              },
                              {
                                purpose: `A httpMockNode节点切换到B httpMockNode节点,按ctrl+c复制节点,可以粘贴(验证各种粘贴模式,不同节点(如:复制到根节点下,复制到folder节点下等)和不同粘贴模式(快捷键和鼠标右键)组合,)`,
                                precondition: [{ id: '1', name: '已登录系统并打开项目工作台' }, { id: '2', name: '项目中包含httpMockNode节点A,B和folder节点F' }],
                                operationSteps: [{ id: '1', name: '点击切换到httpMockNode节点B' }, { id: '2', name: '按ctrl+c复制节点B' }, { id: '3', name: '分别在根节点和folder节点上粘贴4次(右键+ctrl+v组合)' }],
                                expectedResults: [{ id: '1', name: '所有粘贴操作都成功' }, { id: '2', name: '所有副本节点拥有全新的_id' }, { id: '3', name: '剪贴板数据可重复粘贴' }],
                                checkpoints: [{ id: '1', name: 'pasteNodes被调用4次' }, { id: '2', name: '每次粘贴生成新的nanoid' }],
                                notes: [{ id: '1', name: '节点切换不影响复制粘贴功能' }],
                              },
                            ],
                          },
                          {
                            modelName: '复制多个httpMockNode节点',
                            description: '复制多个httpMockNode节点',
                            atomicFunc: [
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个httpMockNode节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [{ id: '1', name: '项目中包含至少3个httpMockNode节点' }],
                                operationSteps: [{ id: '1', name: '多选3个httpMockNode节点并批量复制' }, { id: '2', name: '在banner空白区域粘贴' }],
                                expectedResults: [{ id: '1', name: '粘贴成功,根节点下新增3个httpMockNode节点' }],
                                checkpoints: [{ id: '1', name: 'pasteNodes处理3个节点的粘贴(line 285)' }],
                                notes: [{ id: '1', name: '批量粘贴时节点的相对顺序保持不变' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个httpMockNode节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [{ id: '1', name: '项目中包含3个httpMockNode节点和1个folder节点' }],
                                operationSteps: [{ id: '1', name: '多选3个httpMockNode节点并批量复制' }, { id: '2', name: '在folder节点上粘贴' }],
                                expectedResults: [{ id: '1', name: '粘贴成功,folder下新增3个httpMockNode节点' }],
                                checkpoints: [{ id: '1', name: 'addFileAndFolderCb被调用3次(line 162)' }],
                                notes: [{ id: '1', name: '所有节点成为folder的直接子节点' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个httpMockNode节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [{ id: '1', name: '项目A中包含3个httpMockNode节点' }, { id: '2', name: '项目B中包含folder节点' }],
                                operationSteps: [{ id: '1', name: '在项目A中批量复制3个节点' }, { id: '2', name: '切换到项目B并在folder上粘贴' }],
                                expectedResults: [{ id: '1', name: '粘贴成功,项目B的folder下新增3个httpMockNode节点' }],
                                checkpoints: [{ id: '1', name: 'pasteNodes检测到跨项目粘贴(line 292)' }],
                                notes: [{ id: '1', name: '跨项目批量粘贴需要获取源项目完整文档数据' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个httpMockNode节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [{ id: '1', name: '项目A中包含3个httpMockNode节点' }],
                                operationSteps: [{ id: '1', name: '在项目A中批量复制3个节点' }, { id: '2', name: '切换到项目B并在空白区域粘贴' }],
                                expectedResults: [{ id: '1', name: '粘贴成功,项目B的根节点下新增3个httpMockNode节点' }],
                                checkpoints: [{ id: '1', name: 'addFileAndFolderCb进入根节点插入分支(line 168)' }],
                                notes: [{ id: '1', name: '所有节点的pid为空字符串' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个httpMockNode节点,在非folder节点鼠标右键不会出现粘贴操作',
                                precondition: [{ id: '1', name: '项目中包含至少4个httpMockNode节点' }],
                                operationSteps: [{ id: '1', name: '多选3个节点并批量复制' }, { id: '2', name: '右键点击另一个httpMockNode节点' }],
                                expectedResults: [{ id: '1', name: '右键菜单中不显示"粘贴"选项' }],
                                checkpoints: [{ id: '1', name: 'selectNodes数组重置为单选模式(line 411)' }],
                                notes: [{ id: '1', name: '在非folder节点上右键会退出多选模式' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个httpMockNode节点,focus 非folder节点ctrl+v不生效',
                                precondition: [{ id: '1', name: '项目中包含至少4个httpMockNode节点' }],
                                operationSteps: [{ id: '1', name: '多选3个节点并批量复制' }, { id: '2', name: '单击选中另一个httpMockNode节点' }, { id: '3', name: '按下Ctrl+V' }],
                                expectedResults: [{ id: '1', name: '未触发粘贴操作,触发生成副本操作' }],
                                checkpoints: [{ id: '1', name: '按下Ctrl+V触发handleForkNode(line 546)' }],
                                notes: [{ id: '1', name: 'Ctrl+V在非folder节点上触发生成副本' }],
                              },
                            ],
                          },
                        ],
                      },
                      //复制websocketMockNode节点
                      {
                        modelName: '复制websocketMockNode节点',
                        description: '复制websocketMockNode节点',
                        children: [
                          {
                            modelName: '复制单个websocketMockNode节点',
                            description: '复制单个websocketMockNode节点',
                            atomicFunc: [
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个websocketMockNode节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [{ id: '1', name: '已登录系统并打开项目工作台' }, { id: '2', name: '项目中包含至少一个websocketMockNode节点' }],
                                operationSteps: [{ id: '1', name: '右键复制websocketMockNode节点' }, { id: '2', name: '在banner空白区域右键粘贴' }],
                                expectedResults: [{ id: '1', name: '粘贴成功,根节点下新增一个websocketMockNode节点' }, { id: '2', name: '新节点拥有全新的_id' }, { id: '3', name: '新节点的type为"websocketMock"' }],
                                checkpoints: [{ id: '1', name: 'pasteNodes函数处理粘贴(line 285)' }, { id: '2', name: 'apiNodesCache.addNodes保存到IndexedDB(line 366)' }],
                                notes: [{ id: '1', name: 'websocketMockNode的复制粘贴逻辑与其他节点类型完全相同' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个websocketMockNode节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [{ id: '1', name: '项目中包含websocketMockNode节点和folder节点' }],
                                operationSteps: [{ id: '1', name: '右键复制websocketMockNode节点' }, { id: '2', name: '在folder节点上右键粘贴' }],
                                expectedResults: [{ id: '1', name: '粘贴成功,folder下新增websocketMockNode节点' }],
                                checkpoints: [{ id: '1', name: 'addFileAndFolderCb插入到folder子节点(line 162)' }],
                                notes: [{ id: '1', name: 'folder会自动展开显示新节点' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个websocketMockNode节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [{ id: '1', name: '项目A中包含websocketMockNode节点' }, { id: '2', name: '项目B中包含folder节点' }],
                                operationSteps: [{ id: '1', name: '在项目A中复制websocketMockNode节点' }, { id: '2', name: '切换到项目B并在folder上粘贴' }],
                                expectedResults: [{ id: '1', name: '粘贴成功,项目B的folder下新增websocketMockNode节点' }],
                                checkpoints: [{ id: '1', name: 'pasteNodes检测到跨项目粘贴(line 292)' }],
                                notes: [{ id: '1', name: '跨项目粘贴需要获取源项目完整文档数据' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个websocketMockNode节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [{ id: '1', name: '项目A中包含websocketMockNode节点' }],
                                operationSteps: [{ id: '1', name: '在项目A中复制websocketMockNode节点' }, { id: '2', name: '切换到项目B并在空白区域粘贴' }],
                                expectedResults: [{ id: '1', name: '粘贴成功,项目B的根节点下新增websocketMockNode节点' }],
                                checkpoints: [{ id: '1', name: 'addFileAndFolderCb进入根节点插入分支(line 168)' }],
                                notes: [{ id: '1', name: '跨项目粘贴到根节点,pid为空字符串' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个websocketMockNode节点,在非folder节点鼠标右键不会出现粘贴操作',
                                precondition: [{ id: '1', name: '项目中包含至少两个websocketMockNode节点' }],
                                operationSteps: [{ id: '1', name: '右键复制websocketMockNode节点A' }, { id: '2', name: '右键点击websocketMockNode节点B' }],
                                expectedResults: [{ id: '1', name: '右键菜单中不显示"粘贴"选项' }],
                                checkpoints: [{ id: '1', name: '粘贴选项的v-show条件为false(line 238)' }],
                                notes: [{ id: '1', name: '粘贴操作只允许在folder节点或banner空白区域执行' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个websocketMockNode节点,focus非folder节点ctrl+v不生效',
                                precondition: [{ id: '1', name: '项目中包含至少两个websocketMockNode节点' }],
                                operationSteps: [{ id: '1', name: '右键复制websocketMockNode节点A' }, { id: '2', name: '单击选中websocketMockNode节点B' }, { id: '3', name: '按下Ctrl+V' }],
                                expectedResults: [{ id: '1', name: '未触发粘贴操作,触发生成副本操作' }],
                                checkpoints: [{ id: '1', name: '按下Ctrl+V触发handleForkNode(line 546)' }],
                                notes: [{ id: '1', name: 'Ctrl+V在非folder节点上触发生成副本' }],
                              },
                              {
                                purpose: `A websocketMockNode节点切换到B websocketMockNode节点,按ctrl+c复制节点,可以粘贴(验证各种粘贴模式,不同节点(如:复制到根节点下,复制到folder节点下等)和不同粘贴模式(快捷键和鼠标右键)组合,)`,
                                precondition: [{ id: '1', name: '项目中包含websocketMockNode节点A,B和folder节点F' }],
                                operationSteps: [{ id: '1', name: '点击切换到websocketMockNode节点B' }, { id: '2', name: '按ctrl+c复制节点B' }, { id: '3', name: '分别在根节点和folder节点上粘贴4次' }],
                                expectedResults: [{ id: '1', name: '所有粘贴操作都成功' }, { id: '2', name: '所有副本节点拥有全新的_id' }],
                                checkpoints: [{ id: '1', name: 'pasteNodes被调用4次' }],
                                notes: [{ id: '1', name: '节点切换不影响复制粘贴功能' }],
                              },
                            ],
                          },
                          {
                            modelName: '复制多个websocketMockNode节点',
                            description: '复制多个websocketMockNode节点',
                            atomicFunc: [
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个websocketMockNode节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [{ id: '1', name: '项目中包含至少3个websocketMockNode节点' }],
                                operationSteps: [{ id: '1', name: '多选3个websocketMockNode节点并批量复制' }, { id: '2', name: '在banner空白区域粘贴' }],
                                expectedResults: [{ id: '1', name: '粘贴成功,根节点下新增3个websocketMockNode节点' }],
                                checkpoints: [{ id: '1', name: 'pasteNodes处理3个节点的粘贴(line 285)' }],
                                notes: [{ id: '1', name: '批量粘贴时节点的相对顺序保持不变' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个websocketMockNode节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [{ id: '1', name: '项目中包含3个websocketMockNode节点和1个folder节点' }],
                                operationSteps: [{ id: '1', name: '多选3个websocketMockNode节点并批量复制' }, { id: '2', name: '在folder节点上粘贴' }],
                                expectedResults: [{ id: '1', name: '粘贴成功,folder下新增3个websocketMockNode节点' }],
                                checkpoints: [{ id: '1', name: 'addFileAndFolderCb被调用3次(line 162)' }],
                                notes: [{ id: '1', name: '所有节点成为folder的直接子节点' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个websocketMockNode节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [{ id: '1', name: '项目A中包含3个websocketMockNode节点' }, { id: '2', name: '项目B中包含folder节点' }],
                                operationSteps: [{ id: '1', name: '在项目A中批量复制3个节点' }, { id: '2', name: '切换到项目B并在folder上粘贴' }],
                                expectedResults: [{ id: '1', name: '粘贴成功,项目B的folder下新增3个websocketMockNode节点' }],
                                checkpoints: [{ id: '1', name: 'pasteNodes检测到跨项目粘贴(line 292)' }],
                                notes: [{ id: '1', name: '跨项目批量粘贴需要获取源项目完整文档数据' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个websocketMockNode节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [{ id: '1', name: '项目A中包含3个websocketMockNode节点' }],
                                operationSteps: [{ id: '1', name: '在项目A中批量复制3个节点' }, { id: '2', name: '切换到项目B并在空白区域粘贴' }],
                                expectedResults: [{ id: '1', name: '粘贴成功,项目B的根节点下新增3个websocketMockNode节点' }],
                                checkpoints: [{ id: '1', name: 'addFileAndFolderCb进入根节点插入分支(line 168)' }],
                                notes: [{ id: '1', name: '所有节点的pid为空字符串' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个websocketMockNode节点,在非folder节点鼠标右键不会出现粘贴操作',
                                precondition: [{ id: '1', name: '项目中包含至少4个websocketMockNode节点' }],
                                operationSteps: [{ id: '1', name: '多选3个节点并批量复制' }, { id: '2', name: '右键点击另一个websocketMockNode节点' }],
                                expectedResults: [{ id: '1', name: '右键菜单中不显示"粘贴"选项' }],
                                checkpoints: [{ id: '1', name: 'selectNodes数组重置为单选模式(line 411)' }],
                                notes: [{ id: '1', name: '在非folder节点上右键会退出多选模式' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个websocketMockNode节点,focus 非folder节点ctrl+v不生效',
                                precondition: [{ id: '1', name: '项目中包含至少4个websocketMockNode节点' }],
                                operationSteps: [{ id: '1', name: '多选3个节点并批量复制' }, { id: '2', name: '单击选中另一个websocketMockNode节点' }, { id: '3', name: '按下Ctrl+V' }],
                                expectedResults: [{ id: '1', name: '未触发粘贴操作,触发生成副本操作' }],
                                checkpoints: [{ id: '1', name: '按下Ctrl+V触发handleForkNode(line 546)' }],
                                notes: [{ id: '1', name: 'Ctrl+V在非folder节点上触发生成副本' }],
                              },
                            ],
                          },
                        ],
                      },
                      //复制folder节点
                      {
                        modelName: '复制folder节点',
                        description: '复制folder节点',
                        children: [
                          {
                            modelName: '复制单个folder节点',
                            description: '复制单个folder节点',
                            atomicFunc: [
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个folder节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [
                                  { id: '1', name: '项目中包含至少1个folder节点(可包含子节点)' },
                                  { id: '2', name: 'folder节点可包含嵌套的子节点(http/websocket/httpMock/websocketMock/folder)' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '右键点击folder节点,选择"复制"操作或按Ctrl+C' },
                                  { id: '2', name: '在banner树形区域的空白区域右键,选择"粘贴"操作或按Ctrl+V' },
                                  { id: '3', name: '观察folder节点及其所有子节点是否成功粘贴到根节点下' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,根节点下新增1个folder节点' },
                                  { id: '2', name: '新folder节点生成唯一的新ID(通过nanoid),与原folder节点ID不同' },
                                  { id: '3', name: '如果原folder包含子节点,所有子节点也被递归复制,子节点也生成新ID' },
                                  { id: '4', name: '新folder节点插入到所有folder之后,非folder节点之前的位置(curd-node.ts:169-183)' },
                                  { id: '5', name: '新folder节点的父子关系正确维护:子节点的pid指向新folder的新ID' },
                                  { id: '6', name: '复制完成后,原folder节点保持不变(仍存在于原位置)' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCopyNode方法将selectNodes写入剪贴板,格式为{type:"apiflow-apidoc-node",data:[nodes]}(Banner.vue:535-544)' },
                                  { id: '2', name: 'handlePasteNode方法读取剪贴板并调用pasteNodes(Banner.vue:559-579)' },
                                  { id: '3', name: 'pasteNodes通过flatTree函数递归获取folder及所有子节点(curd-node.ts:296-298, helper/index.ts:586-601)' },
                                  { id: '4', name: 'pasteNodes为所有节点生成新ID并建立idMapping映射(curd-node.ts:334-347)' },
                                  { id: '5', name: 'pasteNodes更新所有子节点的pid为新的父节点ID(curd-node.ts:351-362)' },
                                  { id: '6', name: 'addFileAndFolderCb判断粘贴位置为根节点且节点类型为folder,插入到lastFolderIndex位置(curd-node.ts:169-183)' },
                                  { id: '7', name: 'bannerStore.splice方法将新folder插入到banner数组指定位置' },
                                  { id: '8', name: 'apiNodesCache.addNodes批量保存所有新节点到IndexedDB(curd-node.ts:366)' },
                                ],
                                notes: [
                                  { id: '1', name: 'folder节点复制会递归复制所有子节点,通过flatTree扁平化后统一处理ID映射' },
                                  { id: '2', name: '插入位置规则:folder始终排在前面,确保树形结构的folder优先显示' },
                                  { id: '3', name: 'ID映射维护了完整的父子关系,确保嵌套结构不被破坏' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个folder节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [
                                  { id: '1', name: '项目中包含至少2个folder节点(一个作为复制源,一个作为粘贴目标)' },
                                  { id: '2', name: '目标folder节点可以是空folder或包含子节点的folder' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '右键点击源folder节点,选择"复制"操作或按Ctrl+C' },
                                  { id: '2', name: '右键点击目标folder节点,选择"粘贴"操作或按Ctrl+V' },
                                  { id: '3', name: '观察源folder节点及其所有子节点是否成功粘贴到目标folder内部' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,目标folder节点内新增1个folder子节点' },
                                  { id: '2', name: '新folder子节点的pid指向目标folder的_id' },
                                  { id: '3', name: '新folder子节点及其所有子节点都生成新ID' },
                                  { id: '4', name: '新folder子节点插入到目标folder的children数组末尾(curd-node.ts:162-166)' },
                                  { id: '5', name: '目标folder在树形视图中自动展开,显示新粘贴的子folder' },
                                  { id: '6', name: '原源folder节点保持不变' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCopyNode将源folder写入剪贴板(Banner.vue:535-544)' },
                                  { id: '2', name: 'handlePasteNode读取剪贴板并调用pasteNodes,传入currentOperationalNode为目标folder(Banner.vue:559-579)' },
                                  { id: '3', name: 'pasteNodes通过flatTree递归获取源folder及所有子节点(curd-node.ts:296-298)' },
                                  { id: '4', name: 'pasteNodes生成新ID映射,子节点的pid更新为新的父节点ID(curd-node.ts:351-362)' },
                                  { id: '5', name: 'addFileAndFolderCb判断currentOperationalNode不为null,将新folder插入到目标folder的children末尾(curd-node.ts:162-166)' },
                                  { id: '6', name: 'bannerStore.changeExpandItems展开目标folder(Banner.vue:576)' },
                                  { id: '7', name: 'apiNodesCache.addNodes保存所有新节点到IndexedDB' },
                                ],
                                notes: [
                                  { id: '1', name: 'folder可以嵌套复制到另一个folder内,形成多级嵌套结构' },
                                  { id: '2', name: '粘贴后目标folder自动展开,方便用户查看新粘贴的内容' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个folder节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [
                                  { id: '1', name: '至少打开2个项目(项目A和项目B)' },
                                  { id: '2', name: '项目A中包含至少1个folder节点(作为复制源)' },
                                  { id: '3', name: '项目B中包含至少1个folder节点(作为粘贴目标)' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在项目A中右键点击源folder节点,选择"复制"操作或按Ctrl+C' },
                                  { id: '2', name: '切换到项目B' },
                                  { id: '3', name: '在项目B中右键点击目标folder节点,选择"粘贴"操作或按Ctrl+V' },
                                  { id: '4', name: '观察源folder节点是否成功跨项目粘贴到项目B的目标folder内' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,项目B的目标folder节点内新增1个folder子节点' },
                                  { id: '2', name: '新folder子节点的projectId更新为项目B的projectId(curd-node.ts:342)' },
                                  { id: '3', name: '新folder子节点及其所有子节点的projectId都更新为项目B的projectId' },
                                  { id: '4', name: '新folder子节点及其所有子节点都生成新ID' },
                                  { id: '5', name: '新folder子节点的pid指向项目B目标folder的_id' },
                                  { id: '6', name: '项目A中的原folder节点保持不变' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCopyNode将源folder写入剪贴板,剪贴板数据包含projectId字段' },
                                  { id: '2', name: 'pasteNodes检测到fromProjectId !== currentProjectId,触发跨项目粘贴逻辑(curd-node.ts:303)' },
                                  { id: '3', name: 'apiNodesCache.getNodesByProjectId(fromProjectId)从项目A获取完整文档数据(curd-node.ts:305)' },
                                  { id: '4', name: 'pasteNodes为所有节点更新projectId为currentProjectId(项目B)(curd-node.ts:342)' },
                                  { id: '5', name: 'pasteNodes生成新ID映射并更新父子关系(curd-node.ts:351-362)' },
                                  { id: '6', name: 'apiNodesCache.addNodes将新节点保存到项目B的IndexedDB' },
                                ],
                                notes: [
                                  { id: '1', name: '跨项目粘贴时,系统会从源项目IndexedDB获取完整文档数据,确保数据完整性' },
                                  { id: '2', name: '所有节点的projectId统一更新为目标项目ID,确保数据隔离' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个folder节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [
                                  { id: '1', name: '至少打开2个项目(项目A和项目B)' },
                                  { id: '2', name: '项目A中包含至少1个folder节点(作为复制源)' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在项目A中右键点击源folder节点,选择"复制"操作或按Ctrl+C' },
                                  { id: '2', name: '切换到项目B' },
                                  { id: '3', name: '在项目B的banner树形区域空白处右键,选择"粘贴"操作或按Ctrl+V' },
                                  { id: '4', name: '观察源folder节点是否成功跨项目粘贴到项目B的根节点下' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,项目B根节点下新增1个folder节点' },
                                  { id: '2', name: '新folder节点的projectId更新为项目B的projectId' },
                                  { id: '3', name: '新folder节点及其所有子节点的projectId都更新为项目B的projectId' },
                                  { id: '4', name: '新folder节点及其所有子节点都生成新ID' },
                                  { id: '5', name: '新folder节点插入到项目B所有folder之后,非folder节点之前的位置' },
                                  { id: '6', name: '项目A中的原folder节点保持不变' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCopyNode将源folder写入剪贴板,剪贴板数据包含projectId字段' },
                                  { id: '2', name: 'pasteNodes检测到fromProjectId !== currentProjectId,触发跨项目粘贴逻辑(curd-node.ts:303)' },
                                  { id: '3', name: 'apiNodesCache.getNodesByProjectId(fromProjectId)从项目A获取完整文档数据(curd-node.ts:305)' },
                                  { id: '4', name: 'pasteNodes为所有节点更新projectId为项目B的projectId(curd-node.ts:342)' },
                                  { id: '5', name: 'addFileAndFolderCb判断粘贴位置为根节点且节点类型为folder,插入到lastFolderIndex位置(curd-node.ts:169-183)' },
                                  { id: '6', name: 'apiNodesCache.addNodes将新节点保存到项目B的IndexedDB' },
                                ],
                                notes: [
                                  { id: '1', name: '跨项目粘贴到根节点时,folder的插入位置规则与同项目粘贴相同' },
                                  { id: '2', name: '所有节点的projectId统一更新,确保跨项目数据隔离' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个folder节点,在非folder节点鼠标右键不会出现粘贴操作',
                                precondition: [
                                  { id: '1', name: '项目中包含至少1个folder节点和1个非folder节点(httpNode/websocketNode/httpMockNode/websocketMockNode)' },
                                  { id: '2', name: '剪贴板中已复制folder节点数据' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '右键点击folder节点,选择"复制"操作或按Ctrl+C' },
                                  { id: '2', name: '右键点击非folder节点(如httpNode)' },
                                  { id: '3', name: '观察右键菜单中是否显示"粘贴"选项' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '右键菜单中不显示"粘贴"选项' },
                                  { id: '2', name: '右键菜单中显示其他操作(如"复制","删除","分叉"等),但没有"粘贴"' },
                                  { id: '3', name: '非folder节点不支持作为粘贴目标' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'Banner.vue中SContextmenuItem的v-show指令判断currentOperationalNode?.type === \'folder\'(Banner.vue:238)' },
                                  { id: '2', name: 'currentOperationalNode为非folder节点时,v-show条件为false,粘贴菜单项隐藏' },
                                  { id: '3', name: '粘贴操作只允许在folder节点或banner空白区域(根节点)执行' },
                                ],
                                notes: [
                                  { id: '1', name: '非folder节点(http/websocket/httpMock/websocketMock)不能作为粘贴目标,因为它们不能包含子节点' },
                                  { id: '2', name: '该限制通过v-show指令在UI层面实现,防止用户尝试无效操作' },
                                ],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)单个folder节点,focus非folder节点ctrl+v不生效',
                                precondition: [
                                  { id: '1', name: '项目中包含至少1个folder节点和1个非folder节点' },
                                  { id: '2', name: '剪贴板中已复制folder节点数据' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '右键点击folder节点,选择"复制"操作或按Ctrl+C' },
                                  { id: '2', name: '单击选中非folder节点(使其获得焦点)' },
                                  { id: '3', name: '按下Ctrl+V快捷键' },
                                  { id: '4', name: '观察是否触发粘贴操作' },
                                ],
                                expectedResults: [
                                  { id: '1', name: 'Ctrl+V快捷键不生效,不会触发粘贴操作' },
                                  { id: '2', name: '非folder节点保持选中状态,没有新增子节点' },
                                  { id: '3', name: '系统不显示任何粘贴相关的提示或错误信息' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handlePasteNode方法中首行判断:if (currentOperationalNode.value && currentOperationalNode.value.type !== \'folder\') return(Banner.vue:560)' },
                                  { id: '2', name: 'currentOperationalNode为非folder节点时,方法直接返回,不执行后续粘贴逻辑' },
                                  { id: '3', name: 'Ctrl+V快捷键绑定到handlePasteNode方法,但在方法内部被拦截' },
                                ],
                                notes: [
                                  { id: '1', name: '快捷键层面的限制:即使用户按下Ctrl+V,方法也会在开头判断节点类型并提前返回' },
                                  { id: '2', name: '该限制与右键菜单限制双重保护,确保非folder节点不会接收粘贴操作' },
                                ],
                              },
                            ],
                          },
                          {
                            modelName: '复制多个folder节点',
                            description: '复制多个folder节点',
                            atomicFunc: [
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个folder节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [{ id: '1', name: '项目中包含至少3个folder节点' }],
                                operationSteps: [
                                  { id: '1', name: '多选3个folder节点(Ctrl+点击)' },
                                  { id: '2', name: '批量复制(右键或Ctrl+C)' },
                                  { id: '3', name: '在banner空白区域粘贴' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,根节点下新增3个folder节点' },
                                  { id: '2', name: '所有folder节点及其子节点都生成新ID' },
                                  { id: '3', name: '所有新folder插入到lastFolderIndex位置' },
                                  { id: '4', name: '批量粘贴时节点的相对顺序保持不变' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCopyNode将selectNodes数组(包含3个folder)写入剪贴板(Banner.vue:535-544)' },
                                  { id: '2', name: 'pasteNodes遍历处理3个folder节点,每个folder递归复制子节点(curd-node.ts:296-298)' },
                                  { id: '3', name: 'addFileAndFolderCb多次调用,依次插入3个新folder到根节点' },
                                ],
                                notes: [{ id: '1', name: '批量复制folder时,每个folder独立生成新ID映射,维护各自的子节点关系' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个folder节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [{ id: '1', name: '项目中包含至少4个folder节点(3个作为复制源,1个作为粘贴目标)' }],
                                operationSteps: [
                                  { id: '1', name: '多选3个folder节点并批量复制' },
                                  { id: '2', name: '在目标folder右键粘贴' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,目标folder内新增3个folder子节点' },
                                  { id: '2', name: '所有新folder子节点的pid指向目标folder的_id' },
                                ],
                                checkpoints: [{ id: '1', name: 'pasteNodes处理3个folder,更新它们的pid为目标folder的_id(curd-node.ts:357-361)' }],
                                notes: [{ id: '1', name: '批量粘贴到folder内时,所有节点按顺序插入到children数组末尾' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个folder节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [
                                  { id: '1', name: '项目A中包含至少3个folder节点' },
                                  { id: '2', name: '项目B中包含至少1个folder节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在项目A多选3个folder节点并批量复制' },
                                  { id: '2', name: '切换到项目B,在目标folder粘贴' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,项目B目标folder内新增3个folder子节点' },
                                  { id: '2', name: '所有新folder及其子节点的projectId更新为项目B的projectId' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'pasteNodes检测跨项目,从项目A获取3个folder的完整数据(curd-node.ts:305)' },
                                  { id: '2', name: 'pasteNodes批量更新所有节点的projectId(curd-node.ts:342)' },
                                ],
                                notes: [{ id: '1', name: '跨项目批量粘贴folder时,系统批量获取源项目数据并统一更新projectId' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个folder节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [
                                  { id: '1', name: '项目A中包含至少3个folder节点' },
                                  { id: '2', name: '项目B为目标项目' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在项目A多选3个folder节点并批量复制' },
                                  { id: '2', name: '切换到项目B,在banner空白区域粘贴' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,项目B根节点下新增3个folder节点' },
                                  { id: '2', name: '所有folder及其子节点的projectId更新为项目B的projectId' },
                                ],
                                checkpoints: [{ id: '1', name: 'pasteNodes检测跨项目并批量处理3个folder的projectId更新' }],
                                notes: [{ id: '1', name: '跨项目批量粘贴到根节点时,folder的插入位置规则与单个folder相同' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个folder节点,在非folder节点鼠标右键不会出现粘贴操作',
                                precondition: [{ id: '1', name: '项目中包含至少3个folder节点和1个非folder节点' }],
                                operationSteps: [
                                  { id: '1', name: '多选3个folder节点并批量复制' },
                                  { id: '2', name: '在非folder节点右键' },
                                ],
                                expectedResults: [{ id: '1', name: '右键菜单中不显示"粘贴"选项' }],
                                checkpoints: [{ id: '1', name: 'Banner.vue的v-show指令判断currentOperationalNode?.type !== \'folder\',隐藏粘贴菜单项' }],
                                notes: [{ id: '1', name: '批量复制folder时,粘贴限制与单个folder相同' }],
                              },
                              {
                                purpose: '鼠标右键复制(ctrl+c复制)多个folder节点,focus 非folder节点ctrl+v不生效',
                                precondition: [{ id: '1', name: '项目中包含至少3个folder节点和1个非folder节点' }],
                                operationSteps: [
                                  { id: '1', name: '多选3个folder节点并批量复制' },
                                  { id: '2', name: '选中非folder节点后按Ctrl+V' },
                                ],
                                expectedResults: [{ id: '1', name: 'Ctrl+V不生效,不会触发粘贴操作' }],
                                checkpoints: [{ id: '1', name: 'handlePasteNode首行判断拦截非folder节点的粘贴操作(Banner.vue:560)' }],
                                notes: [{ id: '1', name: '批量复制folder时,快捷键限制与单个folder相同' }],
                              },
                            ],
                          },
                        ],
                      },
                      //复制混合节点
                      {
                        modelName: '复制混合节点',
                        description: '复制混合节点',
                        children: [
                          {
                            modelName: '复制httpNode,websocketNode,httpMockNode,websocketNode和folderNode混合节点',
                            description: '复制httpNode,websocketNode,httpMockNode,websocketNode和folderNode混合节点',
                            atomicFunc: [
                              {
                                purpose: '批量选择所有类型节点各一个,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [{ id: '1', name: '项目中包含httpNode,websocketNode,httpMockNode,websocketMockNode,folder各至少1个节点' }],
                                operationSteps: [
                                  { id: '1', name: '多选5种类型节点各一个(Ctrl+点击)' },
                                  { id: '2', name: '批量复制(右键或Ctrl+C)' },
                                  { id: '3', name: '在banner空白区域粘贴' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,根节点下新增5个节点(包含所有类型)' },
                                  { id: '2', name: '所有节点都生成新ID,folder节点的子节点也递归生成新ID' },
                                  { id: '3', name: 'folder节点插入到lastFolderIndex位置,非folder节点插入到末尾' },
                                  { id: '4', name: '混合节点按类型分组插入:folder在前,非folder在后' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCopyNode将selectNodes数组(包含5种类型)写入剪贴板(Banner.vue:535-544)' },
                                  { id: '2', name: 'pasteNodes遍历处理5个节点,folder节点通过flatTree递归复制子节点(curd-node.ts:296-298)' },
                                  { id: '3', name: 'addFileAndFolderCb根据节点类型判断插入位置:folder插入到lastFolderIndex,非folder插入到末尾(curd-node.ts:169-190)' },
                                ],
                                notes: [{ id: '1', name: '混合节点批量粘贴时,系统自动按类型分组插入,维护folder在前的顺序规则' }],
                              },
                              {
                                purpose: '批量选择所有类型节点各一个,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [{ id: '1', name: '项目中包含5种类型节点各至少1个,且至少1个空folder作为粘贴目标' }],
                                operationSteps: [
                                  { id: '1', name: '多选5种类型节点各一个并批量复制' },
                                  { id: '2', name: '在目标folder右键粘贴' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,目标folder内新增5个子节点(包含所有类型)' },
                                  { id: '2', name: '所有新子节点的pid指向目标folder的_id' },
                                ],
                                checkpoints: [{ id: '1', name: 'pasteNodes处理5个节点,更新它们的pid为目标folder的_id(curd-node.ts:357-361)' }],
                                notes: [{ id: '1', name: '混合节点粘贴到folder内时,按顺序插入到children数组,不区分类型' }],
                              },
                              {
                                purpose: '批量选择所有类型节点各一个,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [
                                  { id: '1', name: '项目A中包含5种类型节点各至少1个' },
                                  { id: '2', name: '项目B中包含至少1个folder作为粘贴目标' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在项目A多选5种类型节点各一个并批量复制' },
                                  { id: '2', name: '切换到项目B,在目标folder粘贴' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,项目B目标folder内新增5个子节点' },
                                  { id: '2', name: '所有新子节点的projectId更新为项目B的projectId' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'pasteNodes检测跨项目,从项目A获取5个节点的完整数据(curd-node.ts:305)' },
                                  { id: '2', name: 'pasteNodes批量更新所有节点的projectId(curd-node.ts:342)' },
                                ],
                                notes: [{ id: '1', name: '跨项目批量粘贴混合节点时,系统统一处理projectId更新和ID映射' }],
                              },
                              {
                                purpose: '批量选择所有类型节点各一个,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [
                                  { id: '1', name: '项目A中包含5种类型节点各至少1个' },
                                  { id: '2', name: '项目B为目标项目' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在项目A多选5种类型节点各一个并批量复制' },
                                  { id: '2', name: '切换到项目B,在banner空白区域粘贴' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,项目B根节点下新增5个节点' },
                                  { id: '2', name: '所有节点的projectId更新为项目B的projectId' },
                                  { id: '3', name: 'folder节点插入到lastFolderIndex位置,非folder节点插入到末尾' },
                                ],
                                checkpoints: [{ id: '1', name: 'pasteNodes检测跨项目并批量处理5个节点的projectId更新和插入位置判断' }],
                                notes: [{ id: '1', name: '跨项目混合节点粘贴到根节点时,插入位置规则与同项目相同' }],
                              },
                              {
                                purpose: '批量选择所有类型节点各一个,在非folder节点鼠标右键不会出现粘贴操作',
                                precondition: [{ id: '1', name: '项目中包含5种类型节点各至少1个' }],
                                operationSteps: [
                                  { id: '1', name: '多选5种类型节点各一个并批量复制' },
                                  { id: '2', name: '在非folder节点(如httpNode)右键' },
                                ],
                                expectedResults: [{ id: '1', name: '右键菜单中不显示"粘贴"选项' }],
                                checkpoints: [{ id: '1', name: 'Banner.vue的v-show指令判断currentOperationalNode?.type !== \'folder\',隐藏粘贴菜单项' }],
                                notes: [{ id: '1', name: '混合节点批量复制时,粘贴限制与单一类型节点相同' }],
                              },
                            ],
                          },
                        ],
                      },
                    ],
                  },
                  //剪切节点
                  {
                    modelName: '剪切节点',
                    description: '剪切节点',
                    children: [
                      //剪切httpNode节点
                      {
                        modelName: '剪切httpNode节点',
                        description: '剪切httpNode节点',
                        children: [
                          {
                            modelName: '剪切单个httpNode节点',
                            description: '剪切单个httpNode节点',
                            atomicFunc: [
                              {
                                purpose: '鼠标右键剪切(ctrl+x剪切)单个httpNode节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [{ id: '1', name: '项目中包含至少1个httpNode节点' }],
                                operationSteps: [
                                  { id: '1', name: '右键点击httpNode节点,选择"剪切"操作或按Ctrl+X' },
                                  { id: '2', name: '观察被剪切节点的视觉状态变化' },
                                  { id: '3', name: '在banner空白区域右键粘贴或按Ctrl+V' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '剪切后,原httpNode节点添加"cut-node"类名,显示视觉标识' },
                                  { id: '2', name: '粘贴成功,根节点下新增1个httpNode节点(生成新ID)' },
                                  { id: '3', name: '粘贴完成后,原httpNode节点从原位置自动删除' },
                                  { id: '4', name: 'cutNodes数组被清空' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCutNode将selectNodes存入cutNodes.value数组(Banner.vue:550)' },
                                  { id: '2', name: 'handleCutNode将selectNodes写入剪贴板(Banner.vue:553-556)' },
                                  { id: '3', name: '节点模板根据cutNodes判断添加"cut-node"类名(Banner.vue:28)' },
                                  { id: '4', name: 'handlePasteNode完成粘贴后调用deleteNode删除cutNodes中的节点(Banner.vue:571)' },
                                  { id: '5', name: 'cutNodes数组被清空(Banner.vue:572)' },
                                ],
                                notes: [{ id: '1', name: '剪切与复制的核心区别:粘贴后原节点被删除,通过cutNodes数组跟踪' }],
                              },
                              {
                                purpose: '鼠标右键剪切(ctrl+x剪切)单个httpNode节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [{ id: '1', name: '项目中包含至少1个httpNode节点和1个folder节点' }],
                                operationSteps: [
                                  { id: '1', name: '剪切httpNode节点' },
                                  { id: '2', name: '在folder节点粘贴' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,folder内新增1个httpNode子节点' },
                                  { id: '2', name: '原httpNode节点从原位置被删除' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'pasteNodes完成粘贴后,deleteNode删除原节点(Banner.vue:571)' },
                                ],
                                notes: [{ id: '1', name: '剪切到folder时,新节点的pid更新为folder的_id,原节点被删除' }],
                              },
                              {
                                purpose: '鼠标右键剪切(ctrl+x剪切)单个httpNode节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [
                                  { id: '1', name: '项目A中包含至少1个httpNode节点' },
                                  { id: '2', name: '项目B中包含至少1个folder节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在项目A剪切httpNode节点' },
                                  { id: '2', name: '切换到项目B,在folder粘贴' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,项目B的folder内新增1个httpNode子节点' },
                                  { id: '2', name: '新节点的projectId更新为项目B的projectId' },
                                  { id: '3', name: '项目A中的原httpNode节点被删除' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'pasteNodes检测跨项目并更新projectId(curd-node.ts:342)' },
                                  { id: '2', name: 'deleteNode删除项目A中的原节点(Banner.vue:571)' },
                                ],
                                notes: [{ id: '1', name: '跨项目剪切时,原节点从源项目删除,新节点添加到目标项目' }],
                              },
                              {
                                purpose: '鼠标右键剪切(ctrl+x剪切)单个httpNode节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [
                                  { id: '1', name: '项目A中包含至少1个httpNode节点' },
                                  { id: '2', name: '项目B为目标项目' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在项目A剪切httpNode节点' },
                                  { id: '2', name: '切换到项目B,在banner空白区域粘贴' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,项目B根节点下新增1个httpNode节点' },
                                  { id: '2', name: '新节点的projectId更新为项目B的projectId' },
                                  { id: '3', name: '项目A中的原httpNode节点被删除' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'pasteNodes处理跨项目粘贴并更新projectId' },
                                  { id: '2', name: 'deleteNode删除项目A中的原节点' },
                                ],
                                notes: [{ id: '1', name: '跨项目剪切相当于移动节点到另一个项目' }],
                              },
                              {
                                purpose: '鼠标右键剪切(ctrl+x剪切)单个httpNode节点,在非folder节点鼠标右键不会出现粘贴操作',
                                precondition: [{ id: '1', name: '项目中包含至少1个httpNode节点和1个非folder节点' }],
                                operationSteps: [
                                  { id: '1', name: '剪切httpNode节点' },
                                  { id: '2', name: '在非folder节点右键' },
                                ],
                                expectedResults: [{ id: '1', name: '右键菜单中不显示"粘贴"选项' }],
                                checkpoints: [{ id: '1', name: 'Banner.vue的v-show指令隐藏粘贴菜单项(Banner.vue:238)' }],
                                notes: [{ id: '1', name: '剪切的粘贴限制与复制相同' }],
                              },
                              {
                                purpose: '鼠标右键剪切(ctrl+x剪切)单个httpNode节点,focus非folder节点ctrl+v不生效',
                                precondition: [{ id: '1', name: '项目中包含至少1个httpNode节点和1个非folder节点' }],
                                operationSteps: [
                                  { id: '1', name: '剪切httpNode节点' },
                                  { id: '2', name: '选中非folder节点后按Ctrl+V' },
                                ],
                                expectedResults: [{ id: '1', name: 'Ctrl+V不生效,不会触发粘贴操作' }],
                                checkpoints: [{ id: '1', name: 'handlePasteNode首行判断拦截非folder节点(Banner.vue:560)' }],
                                notes: [{ id: '1', name: '剪切的快捷键限制与复制相同' }],
                              },
                            ],
                          },
                          {
                            modelName: '剪切多个httpNode节点',
                            description: '剪切多个httpNode节点',
                            atomicFunc: [
                              {
                                purpose: '鼠标右键剪切(ctrl+x剪切)多个httpNode节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [{ id: '1', name: '项目中包含至少3个httpNode节点' }],
                                operationSteps: [{ id: '1', name: '多选3个httpNode节点并批量剪切' }, { id: '2', name: '在banner空白区域粘贴' }],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,根节点下新增3个httpNode节点' },
                                  { id: '2', name: '原3个httpNode节点从原位置全部被删除' },
                                ],
                                checkpoints: [{ id: '1', name: 'handleCutNode将3个节点存入cutNodes数组' }, { id: '2', name: 'deleteNode批量删除cutNodes中的3个节点(Banner.vue:571)' }],
                                notes: [{ id: '1', name: '批量剪切时,所有原节点统一在粘贴后被删除' }],
                              },
                              {
                                purpose: '鼠标右键剪切(ctrl+x剪切)多个httpNode节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [{ id: '1', name: '项目中包含至少3个httpNode节点和1个folder节点' }],
                                operationSteps: [{ id: '1', name: '多选3个httpNode节点并批量剪切' }, { id: '2', name: '在folder粘贴' }],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,folder内新增3个httpNode子节点' },
                                  { id: '2', name: '原3个httpNode节点被删除' },
                                ],
                                checkpoints: [{ id: '1', name: 'deleteNode批量删除原节点' }],
                                notes: [{ id: '1', name: '批量剪切到folder时,原节点被删除,新节点的pid更新为folder的_id' }],
                              },
                              {
                                purpose: '鼠标右键剪切(ctrl+x剪切)多个httpNode节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下',
                                precondition: [{ id: '1', name: '项目A中包含至少3个httpNode节点' }, { id: '2', name: '项目B中包含至少1个folder节点' }],
                                operationSteps: [{ id: '1', name: '在项目A多选3个httpNode节点并批量剪切' }, { id: '2', name: '切换到项目B,在folder粘贴' }],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,项目B的folder内新增3个httpNode子节点' },
                                  { id: '2', name: '项目A中的原3个httpNode节点被删除' },
                                ],
                                checkpoints: [{ id: '1', name: 'pasteNodes处理跨项目粘贴' }, { id: '2', name: 'deleteNode删除项目A中的原节点' }],
                                notes: [{ id: '1', name: '跨项目批量剪切时,原节点从源项目删除' }],
                              },
                              {
                                purpose: '鼠标右键剪切(ctrl+x剪切)多个httpNode节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下',
                                precondition: [{ id: '1', name: '项目A中包含至少3个httpNode节点' }],
                                operationSteps: [{ id: '1', name: '在项目A多选3个httpNode节点并批量剪切' }, { id: '2', name: '切换到项目B,在banner空白区域粘贴' }],
                                expectedResults: [
                                  { id: '1', name: '粘贴成功,项目B根节点下新增3个httpNode节点' },
                                  { id: '2', name: '项目A中的原3个httpNode节点被删除' },
                                ],
                                checkpoints: [{ id: '1', name: 'deleteNode删除项目A中的原节点' }],
                                notes: [{ id: '1', name: '跨项目批量剪切相当于批量移动节点' }],
                              },
                              {
                                purpose: '鼠标右键剪切(ctrl+x剪切)多个httpNode节点,在非folder节点鼠标右键不会出现粘贴操作',
                                precondition: [{ id: '1', name: '项目中包含至少3个httpNode节点和1个非folder节点' }],
                                operationSteps: [{ id: '1', name: '多选3个httpNode节点并批量剪切' }, { id: '2', name: '在非folder节点右键' }],
                                expectedResults: [{ id: '1', name: '右键菜单中不显示"粘贴"选项' }],
                                checkpoints: [{ id: '1', name: 'Banner.vue的v-show指令隐藏粘贴菜单项' }],
                                notes: [{ id: '1', name: '批量剪切的粘贴限制与单个剪切相同' }],
                              },
                              {
                                purpose: '鼠标右键剪切(ctrl+x剪切)多个httpNode节点,focus 非folder节点ctrl+v不生效',
                                precondition: [{ id: '1', name: '项目中包含至少3个httpNode节点和1个非folder节点' }],
                                operationSteps: [{ id: '1', name: '多选3个httpNode节点并批量剪切' }, { id: '2', name: '选中非folder节点后按Ctrl+V' }],
                                expectedResults: [{ id: '1', name: 'Ctrl+V不生效' }],
                                checkpoints: [{ id: '1', name: 'handlePasteNode首行判断拦截非folder节点' }],
                                notes: [{ id: '1', name: '批量剪切的快捷键限制与单个剪切相同' }],
                              },
                            ],
                          },
                        ],
                      },
                      //剪切websocketNode节点
                      {
                        modelName: '剪切websocketNode节点',
                        description: '剪切websocketNode节点',
                        children: [
                          {
                            modelName: '剪切单个websocketNode节点',
                            description: '剪切单个websocketNode节点',
                            atomicFunc: [
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个websocketNode节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目中包含至少1个websocketNode节点' }], operationSteps: [{ id: '1', name: '剪切websocketNode并在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,根节点下新增websocketNode,原节点被删除' }], checkpoints: [{ id: '1', name: 'handleCutNode存入cutNodes,deleteNode删除原节点(Banner.vue:571)' }], notes: [{ id: '1', name: '剪切逻辑与httpNode相同' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个websocketNode节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目中包含至少1个websocketNode节点和1个folder节点' }], operationSteps: [{ id: '1', name: '剪切websocketNode并在folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,folder内新增websocketNode,原节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除原节点' }], notes: [{ id: '1', name: '剪切到folder时原节点被删除' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个websocketNode节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目A中包含至少1个websocketNode节点,项目B中包含至少1个folder节点' }], operationSteps: [{ id: '1', name: '在项目A剪切websocketNode,切换到项目B在folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B的folder内新增websocketNode,项目A中的原节点被删除' }], checkpoints: [{ id: '1', name: 'pasteNodes处理跨项目粘贴,deleteNode删除项目A中的原节点' }], notes: [{ id: '1', name: '跨项目剪切时原节点从源项目删除' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个websocketNode节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目A中包含至少1个websocketNode节点' }], operationSteps: [{ id: '1', name: '在项目A剪切websocketNode,切换到项目B在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B根节点下新增websocketNode,项目A中的原节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除项目A中的原节点' }], notes: [{ id: '1', name: '跨项目剪切相当于移动节点' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个websocketNode节点,在非folder节点鼠标右键不会出现粘贴操作', precondition: [{ id: '1', name: '项目中包含至少1个websocketNode节点和1个非folder节点' }], operationSteps: [{ id: '1', name: '剪切websocketNode后在非folder节点右键' }], expectedResults: [{ id: '1', name: '右键菜单中不显示"粘贴"选项' }], checkpoints: [{ id: '1', name: 'v-show指令隐藏粘贴菜单项' }], notes: [{ id: '1', name: '剪切的粘贴限制与复制相同' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个websocketNode节点,focus非folder节点ctrl+v不生效', precondition: [{ id: '1', name: '项目中包含至少1个websocketNode节点和1个非folder节点' }], operationSteps: [{ id: '1', name: '剪切websocketNode后选中非folder节点按Ctrl+V' }], expectedResults: [{ id: '1', name: 'Ctrl+V不生效' }], checkpoints: [{ id: '1', name: 'handlePasteNode首行判断拦截' }], notes: [{ id: '1', name: '快捷键限制与复制相同' }] },
                            ],
                          },
                          {
                            modelName: '剪切多个websocketNode节点',
                            description: '剪切多个websocketNode节点',
                            atomicFunc: [
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个websocketNode节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目中包含至少3个websocketNode节点' }], operationSteps: [{ id: '1', name: '多选3个websocketNode节点并批量剪切,在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,根节点下新增3个websocketNode节点,原3个节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode批量删除cutNodes中的3个节点' }], notes: [{ id: '1', name: '批量剪切时所有原节点统一删除' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个websocketNode节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目中包含至少3个websocketNode节点和1个folder节点' }], operationSteps: [{ id: '1', name: '多选3个websocketNode节点并批量剪切,在folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,folder内新增3个websocketNode子节点,原3个节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode批量删除原节点' }], notes: [{ id: '1', name: '批量剪切到folder时原节点被删除' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个websocketNode节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目A中包含至少3个websocketNode节点,项目B中包含至少1个folder节点' }], operationSteps: [{ id: '1', name: '在项目A多选3个websocketNode节点并批量剪切,切换到项目B在folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B的folder内新增3个websocketNode子节点,项目A中的原3个节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除项目A中的原节点' }], notes: [{ id: '1', name: '跨项目批量剪切时原节点从源项目删除' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个websocketNode节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目A中包含至少3个websocketNode节点' }], operationSteps: [{ id: '1', name: '在项目A多选3个websocketNode节点并批量剪切,切换到项目B在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B根节点下新增3个websocketNode节点,项目A中的原3个节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除项目A中的原节点' }], notes: [{ id: '1', name: '跨项目批量剪切相当于批量移动节点' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个websocketNode节点,在非folder节点鼠标右键不会出现粘贴操作', precondition: [{ id: '1', name: '项目中包含至少3个websocketNode节点和1个非folder节点' }], operationSteps: [{ id: '1', name: '多选3个websocketNode节点并批量剪切,在非folder节点右键' }], expectedResults: [{ id: '1', name: '右键菜单中不显示"粘贴"选项' }], checkpoints: [{ id: '1', name: 'v-show指令隐藏粘贴菜单项' }], notes: [{ id: '1', name: '批量剪切的粘贴限制与单个剪切相同' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个websocketNode节点,focus 非folder节点ctrl+v不生效', precondition: [{ id: '1', name: '项目中包含至少3个websocketNode节点和1个非folder节点' }], operationSteps: [{ id: '1', name: '多选3个websocketNode节点并批量剪切,选中非folder节点后按Ctrl+V' }], expectedResults: [{ id: '1', name: 'Ctrl+V不生效' }], checkpoints: [{ id: '1', name: 'handlePasteNode首行判断拦截' }], notes: [{ id: '1', name: '批量剪切的快捷键限制与单个剪切相同' }] },
                            ],
                          },
                        ],
                      },
                      //剪切httpMockNode节点
                      {
                        modelName: '剪切httpMockNode节点',
                        description: '剪切httpMockNode节点',
                        children: [
                          {
                            modelName: '剪切单个httpMockNode节点',
                            description: '剪切单个httpMockNode节点',
                            atomicFunc: [
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个httpMockNode节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目中包含至少1个httpMockNode节点' }], operationSteps: [{ id: '1', name: '剪切httpMockNode并在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,根节点下新增httpMockNode,原节点被删除' }], checkpoints: [{ id: '1', name: 'handleCutNode存入cutNodes,deleteNode删除原节点' }], notes: [{ id: '1', name: '剪切逻辑与httpNode相同' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个httpMockNode节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目中包含至少1个httpMockNode节点和1个folder节点' }], operationSteps: [{ id: '1', name: '剪切httpMockNode并在folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,folder内新增httpMockNode,原节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除原节点' }], notes: [{ id: '1', name: '剪切到folder时原节点被删除' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个httpMockNode节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目A中包含至少1个httpMockNode节点,项目B中包含至少1个folder节点' }], operationSteps: [{ id: '1', name: '在项目A剪切httpMockNode,切换到项目B在folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B的folder内新增httpMockNode,项目A中的原节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除项目A中的原节点' }], notes: [{ id: '1', name: '跨项目剪切时原节点从源项目删除' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个httpMockNode节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目A中包含至少1个httpMockNode节点' }], operationSteps: [{ id: '1', name: '在项目A剪切httpMockNode,切换到项目B在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B根节点下新增httpMockNode,项目A中的原节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除项目A中的原节点' }], notes: [{ id: '1', name: '跨项目剪切相当于移动节点' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个httpMockNode节点,在非folder节点鼠标右键不会出现粘贴操作', precondition: [{ id: '1', name: '项目中包含至少1个httpMockNode节点和1个非folder节点' }], operationSteps: [{ id: '1', name: '剪切httpMockNode后在非folder节点右键' }], expectedResults: [{ id: '1', name: '右键菜单中不显示"粘贴"选项' }], checkpoints: [{ id: '1', name: 'v-show指令隐藏粘贴菜单项' }], notes: [{ id: '1', name: '剪切的粘贴限制与复制相同' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个httpMockNode节点,focus非folder节点ctrl+v不生效', precondition: [{ id: '1', name: '项目中包含至少1个httpMockNode节点和1个非folder节点' }], operationSteps: [{ id: '1', name: '剪切httpMockNode后选中非folder节点按Ctrl+V' }], expectedResults: [{ id: '1', name: 'Ctrl+V不生效' }], checkpoints: [{ id: '1', name: 'handlePasteNode首行判断拦截' }], notes: [{ id: '1', name: '快捷键限制与复制相同' }] },
                            ],
                          },
                          {
                            modelName: '剪切多个httpMockNode节点',
                            description: '剪切多个httpMockNode节点',
                            atomicFunc: [
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个httpMockNode节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目中包含至少3个httpMockNode节点' }], operationSteps: [{ id: '1', name: '多选3个httpMockNode节点并批量剪切,在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,根节点下新增3个httpMockNode节点,原3个节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode批量删除cutNodes中的3个节点' }], notes: [{ id: '1', name: '批量剪切时所有原节点统一删除' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个httpMockNode节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目中包含至少3个httpMockNode节点和1个folder节点' }], operationSteps: [{ id: '1', name: '多选3个httpMockNode节点并批量剪切,在folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,folder内新增3个httpMockNode子节点,原3个节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode批量删除原节点' }], notes: [{ id: '1', name: '批量剪切到folder时原节点被删除' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个httpMockNode节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目A中包含至少3个httpMockNode节点,项目B中包含至少1个folder节点' }], operationSteps: [{ id: '1', name: '在项目A多选3个httpMockNode节点并批量剪切,切换到项目B在folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B的folder内新增3个httpMockNode子节点,项目A中的原3个节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除项目A中的原节点' }], notes: [{ id: '1', name: '跨项目批量剪切时原节点从源项目删除' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个httpMockNode节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目A中包含至少3个httpMockNode节点' }], operationSteps: [{ id: '1', name: '在项目A多选3个httpMockNode节点并批量剪切,切换到项目B在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B根节点下新增3个httpMockNode节点,项目A中的原3个节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除项目A中的原节点' }], notes: [{ id: '1', name: '跨项目批量剪切相当于批量移动节点' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个httpMockNode节点,在非folder节点鼠标右键不会出现粘贴操作', precondition: [{ id: '1', name: '项目中包含至少3个httpMockNode节点和1个非folder节点' }], operationSteps: [{ id: '1', name: '多选3个httpMockNode节点并批量剪切,在非folder节点右键' }], expectedResults: [{ id: '1', name: '右键菜单中不显示"粘贴"选项' }], checkpoints: [{ id: '1', name: 'v-show指令隐藏粘贴菜单项' }], notes: [{ id: '1', name: '批量剪切的粘贴限制与单个剪切相同' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个httpMockNode节点,focus 非folder节点ctrl+v不生效', precondition: [{ id: '1', name: '项目中包含至少3个httpMockNode节点和1个非folder节点' }], operationSteps: [{ id: '1', name: '多选3个httpMockNode节点并批量剪切,选中非folder节点后按Ctrl+V' }], expectedResults: [{ id: '1', name: 'Ctrl+V不生效' }], checkpoints: [{ id: '1', name: 'handlePasteNode首行判断拦截' }], notes: [{ id: '1', name: '批量剪切的快捷键限制与单个剪切相同' }] },
                            ],
                          },
                        ],
                      },
                      //剪切websocketMockNode节点
                      {
                        modelName: '剪切websocketMockNode节点',
                        description: '剪切websocketMockNode节点',
                        children: [
                          {
                            modelName: '剪切单个websocketMockNode节点',
                            description: '剪切单个websocketMockNode节点',
                            atomicFunc: [
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个websocketMockNode节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目中包含至少1个websocketMockNode节点' }], operationSteps: [{ id: '1', name: '剪切websocketMockNode并在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,根节点下新增websocketMockNode,原节点被删除' }], checkpoints: [{ id: '1', name: 'handleCutNode存入cutNodes,deleteNode删除原节点' }], notes: [{ id: '1', name: '剪切逻辑与httpNode相同' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个websocketMockNode节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目中包含至少1个websocketMockNode节点和1个folder节点' }], operationSteps: [{ id: '1', name: '剪切websocketMockNode并在folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,folder内新增websocketMockNode,原节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除原节点' }], notes: [{ id: '1', name: '剪切到folder时原节点被删除' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个websocketMockNode节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目A中包含至少1个websocketMockNode节点,项目B中包含至少1个folder节点' }], operationSteps: [{ id: '1', name: '在项目A剪切websocketMockNode,切换到项目B在folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B的folder内新增websocketMockNode,项目A中的原节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除项目A中的原节点' }], notes: [{ id: '1', name: '跨项目剪切时原节点从源项目删除' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个websocketMockNode节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目A中包含至少1个websocketMockNode节点' }], operationSteps: [{ id: '1', name: '在项目A剪切websocketMockNode,切换到项目B在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B根节点下新增websocketMockNode,项目A中的原节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除项目A中的原节点' }], notes: [{ id: '1', name: '跨项目剪切相当于移动节点' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个websocketMockNode节点,在非folder节点鼠标右键不会出现粘贴操作', precondition: [{ id: '1', name: '项目中包含至少1个websocketMockNode节点和1个非folder节点' }], operationSteps: [{ id: '1', name: '剪切websocketMockNode后在非folder节点右键' }], expectedResults: [{ id: '1', name: '右键菜单中不显示"粘贴"选项' }], checkpoints: [{ id: '1', name: 'v-show指令隐藏粘贴菜单项' }], notes: [{ id: '1', name: '剪切的粘贴限制与复制相同' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个websocketMockNode节点,focus非folder节点ctrl+v不生效', precondition: [{ id: '1', name: '项目中包含至少1个websocketMockNode节点和1个非folder节点' }], operationSteps: [{ id: '1', name: '剪切websocketMockNode后选中非folder节点按Ctrl+V' }], expectedResults: [{ id: '1', name: 'Ctrl+V不生效' }], checkpoints: [{ id: '1', name: 'handlePasteNode首行判断拦截' }], notes: [{ id: '1', name: '快捷键限制与复制相同' }] },
                            ],
                          },
                          {
                            modelName: '剪切多个websocketMockNode节点',
                            description: '剪切多个websocketMockNode节点',
                            atomicFunc: [
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个websocketMockNode节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目中包含至少3个websocketMockNode节点' }], operationSteps: [{ id: '1', name: '多选3个websocketMockNode节点并批量剪切,在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,根节点下新增3个websocketMockNode节点,原3个节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode批量删除cutNodes中的3个节点' }], notes: [{ id: '1', name: '批量剪切时所有原节点统一删除' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个websocketMockNode节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目中包含至少3个websocketMockNode节点和1个folder节点' }], operationSteps: [{ id: '1', name: '多选3个websocketMockNode节点并批量剪切,在folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,folder内新增3个websocketMockNode子节点,原3个节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode批量删除原节点' }], notes: [{ id: '1', name: '批量剪切到folder时原节点被删除' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个websocketMockNode节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目A中包含至少3个websocketMockNode节点,项目B中包含至少1个folder节点' }], operationSteps: [{ id: '1', name: '在项目A多选3个websocketMockNode节点并批量剪切,切换到项目B在folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B的folder内新增3个websocketMockNode子节点,项目A中的原3个节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除项目A中的原节点' }], notes: [{ id: '1', name: '跨项目批量剪切时原节点从源项目删除' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个websocketMockNode节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目A中包含至少3个websocketMockNode节点' }], operationSteps: [{ id: '1', name: '在项目A多选3个websocketMockNode节点并批量剪切,切换到项目B在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B根节点下新增3个websocketMockNode节点,项目A中的原3个节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除项目A中的原节点' }], notes: [{ id: '1', name: '跨项目批量剪切相当于批量移动节点' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个websocketMockNode节点,在非folder节点鼠标右键不会出现粘贴操作', precondition: [{ id: '1', name: '项目中包含至少3个websocketMockNode节点和1个非folder节点' }], operationSteps: [{ id: '1', name: '多选3个websocketMockNode节点并批量剪切,在非folder节点右键' }], expectedResults: [{ id: '1', name: '右键菜单中不显示"粘贴"选项' }], checkpoints: [{ id: '1', name: 'v-show指令隐藏粘贴菜单项' }], notes: [{ id: '1', name: '批量剪切的粘贴限制与单个剪切相同' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个websocketMockNode节点,focus 非folder节点ctrl+v不生效', precondition: [{ id: '1', name: '项目中包含至少3个websocketMockNode节点和1个非folder节点' }], operationSteps: [{ id: '1', name: '多选3个websocketMockNode节点并批量剪切,选中非folder节点后按Ctrl+V' }], expectedResults: [{ id: '1', name: 'Ctrl+V不生效' }], checkpoints: [{ id: '1', name: 'handlePasteNode首行判断拦截' }], notes: [{ id: '1', name: '批量剪切的快捷键限制与单个剪切相同' }] },
                            ],
                          },
                        ],
                      },
                      //剪切folder节点
                      {
                        modelName: '剪切folder节点',
                        description: '剪切folder节点',
                        children: [
                          {
                            modelName: '剪切单个folder节点',
                            description: '剪切单个folder节点',
                            atomicFunc: [
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个folder节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目中包含至少1个folder节点' }], operationSteps: [{ id: '1', name: '剪切folder并在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,根节点下新增folder,原folder被删除,子节点随folder一起移动' }], checkpoints: [{ id: '1', name: 'handleCutNode存入cutNodes,deleteNode递归删除原folder及所有子节点' }], notes: [{ id: '1', name: '剪切folder时,所有子节点一起被移动,通过flatTree递归处理' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个folder节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目中包含至少2个folder节点' }], operationSteps: [{ id: '1', name: '剪切源folder并在目标folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,目标folder内新增子folder,原folder被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除原folder及其子节点' }], notes: [{ id: '1', name: '剪切folder到另一个folder时,形成嵌套结构' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个folder节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目A中包含至少1个folder节点,项目B中包含至少1个folder节点' }], operationSteps: [{ id: '1', name: '在项目A剪切folder,切换到项目B在目标folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B的folder内新增子folder,项目A中的原folder被删除' }], checkpoints: [{ id: '1', name: 'pasteNodes处理跨项目粘贴并更新projectId,deleteNode删除项目A中的原folder' }], notes: [{ id: '1', name: '跨项目剪切folder时,所有子节点的projectId统一更新' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个folder节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目A中包含至少1个folder节点' }], operationSteps: [{ id: '1', name: '在项目A剪切folder,切换到项目B在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B根节点下新增folder,项目A中的原folder被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除项目A中的原folder' }], notes: [{ id: '1', name: '跨项目剪切folder相当于移动整个folder树到另一个项目' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个folder节点,在非folder节点鼠标右键不会出现粘贴操作', precondition: [{ id: '1', name: '项目中包含至少1个folder节点和1个非folder节点' }], operationSteps: [{ id: '1', name: '剪切folder后在非folder节点右键' }], expectedResults: [{ id: '1', name: '右键菜单中不显示"粘贴"选项' }], checkpoints: [{ id: '1', name: 'v-show指令隐藏粘贴菜单项' }], notes: [{ id: '1', name: '剪切folder的粘贴限制与复制相同' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)单个folder节点,focus非folder节点ctrl+v不生效', precondition: [{ id: '1', name: '项目中包含至少1个folder节点和1个非folder节点' }], operationSteps: [{ id: '1', name: '剪切folder后选中非folder节点按Ctrl+V' }], expectedResults: [{ id: '1', name: 'Ctrl+V不生效' }], checkpoints: [{ id: '1', name: 'handlePasteNode首行判断拦截' }], notes: [{ id: '1', name: '快捷键限制与复制相同' }] },
                              { purpose: '剪切包含子节点的folder,粘贴后层级结构保持不变', precondition: [{ id: '1', name: '项目中包含1个folder节点,该folder内包含多个嵌套子节点(httpNode/websocketNode/子folder等)' }], operationSteps: [{ id: '1', name: '剪切包含复杂层级结构的folder' }, { id: '2', name: '在banner空白区域或另一个folder粘贴' }, { id: '3', name: '展开新粘贴的folder,观察子节点层级结构' }], expectedResults: [{ id: '1', name: '粘贴成功,folder内所有子节点的层级结构完全保持不变' }, { id: '2', name: '所有子节点的pid关系正确维护,父子关系不被破坏' }], checkpoints: [{ id: '1', name: 'pasteNodes通过flatTree递归获取所有子节点(curd-node.ts:296-298)' }, { id: '2', name: 'pasteNodes为所有节点生成新ID并建立idMapping,更新子节点的pid(curd-node.ts:351-362)' }], notes: [{ id: '1', name: '剪切folder时,系统通过ID映射机制维护完整的父子关系' }] },
                            ],
                          },
                          {
                            modelName: '剪切多个folder节点',
                            description: '剪切多个folder节点',
                            atomicFunc: [
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个folder节点,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目中包含至少3个folder节点' }], operationSteps: [{ id: '1', name: '多选3个folder节点并批量剪切,在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,根节点下新增3个folder节点,原3个folder被删除' }], checkpoints: [{ id: '1', name: 'deleteNode批量删除cutNodes中的3个folder及其所有子节点' }], notes: [{ id: '1', name: '批量剪切folder时,每个folder的子节点都随之移动' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个folder节点,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目中包含至少4个folder节点' }], operationSteps: [{ id: '1', name: '多选3个folder节点并批量剪切,在目标folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,目标folder内新增3个子folder,原3个folder被删除' }], checkpoints: [{ id: '1', name: 'deleteNode批量删除原folder' }], notes: [{ id: '1', name: '批量剪切folder到另一个folder时,形成多个嵌套子folder' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个folder节点,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目A中包含至少3个folder节点,项目B中包含至少1个folder节点' }], operationSteps: [{ id: '1', name: '在项目A多选3个folder节点并批量剪切,切换到项目B在目标folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B的folder内新增3个子folder,项目A中的原3个folder被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除项目A中的原folder' }], notes: [{ id: '1', name: '跨项目批量剪切folder时,所有folder及其子节点的projectId统一更新' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个folder节点,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目A中包含至少3个folder节点' }], operationSteps: [{ id: '1', name: '在项目A多选3个folder节点并批量剪切,切换到项目B在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B根节点下新增3个folder节点,项目A中的原3个folder被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除项目A中的原folder' }], notes: [{ id: '1', name: '跨项目批量剪切folder相当于批量移动folder树' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个folder节点,在非folder节点鼠标右键不会出现粘贴操作', precondition: [{ id: '1', name: '项目中包含至少3个folder节点和1个非folder节点' }], operationSteps: [{ id: '1', name: '多选3个folder节点并批量剪切,在非folder节点右键' }], expectedResults: [{ id: '1', name: '右键菜单中不显示"粘贴"选项' }], checkpoints: [{ id: '1', name: 'v-show指令隐藏粘贴菜单项' }], notes: [{ id: '1', name: '批量剪切folder的粘贴限制与单个剪切相同' }] },
                              { purpose: '鼠标右键剪切(ctrl+x剪切)多个folder节点,focus 非folder节点ctrl+v不生效', precondition: [{ id: '1', name: '项目中包含至少3个folder节点和1个非folder节点' }], operationSteps: [{ id: '1', name: '多选3个folder节点并批量剪切,选中非folder节点后按Ctrl+V' }], expectedResults: [{ id: '1', name: 'Ctrl+V不生效' }], checkpoints: [{ id: '1', name: 'handlePasteNode首行判断拦截' }], notes: [{ id: '1', name: '批量剪切的快捷键限制与单个剪切相同' }] },
                              { purpose: '剪切多个folder节点后,原节点从原位置删除,撤销操作(ctrl+z)可恢复', precondition: [{ id: '1', name: '项目中包含至少3个folder节点' }], operationSteps: [{ id: '1', name: '多选3个folder节点并批量剪切,在banner空白区域粘贴' }, { id: '2', name: '粘贴完成后按Ctrl+Z撤销操作' }], expectedResults: [{ id: '1', name: '撤销成功,新粘贴的3个folder被删除,原3个folder恢复到原位置' }], checkpoints: [{ id: '1', name: '撤销操作通过redoUndo store管理,记录操作历史' }], notes: [{ id: '1', name: '剪切粘贴操作支持撤销,但具体撤销逻辑依赖于项目的undo/redo实现' }] },
                            ],
                          },
                        ],
                      },
                      //剪切混合节点
                      {
                        modelName: '剪切混合节点',
                        description: '剪切混合节点',
                        children: [
                          {
                            modelName: '剪切httpNode,websocketNode,httpMockNode,websocketMockNode和folderNode混合节点',
                            description: '剪切httpNode,websocketNode,httpMockNode,websocketMockNode和folderNode混合节点',
                            atomicFunc: [
                              { purpose: '批量选择所有类型节点各一个,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目中包含httpNode,websocketNode,httpMockNode,websocketMockNode,folder各至少1个节点' }], operationSteps: [{ id: '1', name: '多选5种类型节点各一个并批量剪切,在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,根节点下新增5个节点,原5个节点被删除,folder节点插入到lastFolderIndex位置,非folder节点插入到末尾' }], checkpoints: [{ id: '1', name: 'deleteNode批量删除cutNodes中的5个节点' }], notes: [{ id: '1', name: '混合节点批量剪切时,按类型分组插入,所有原节点统一删除' }] },
                              { purpose: '批量选择所有类型节点各一个,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目中包含5种类型节点各至少1个,且至少1个空folder作为粘贴目标' }], operationSteps: [{ id: '1', name: '多选5种类型节点各一个并批量剪切,在目标folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,目标folder内新增5个子节点,原5个节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode批量删除原节点' }], notes: [{ id: '1', name: '混合节点剪切到folder时,所有节点按顺序插入到children数组' }] },
                              { purpose: '批量选择所有类型节点各一个,跨项目,在folder右键粘贴(ctrl+v粘贴)到folder节点下', precondition: [{ id: '1', name: '项目A中包含5种类型节点各至少1个,项目B中包含至少1个folder作为粘贴目标' }], operationSteps: [{ id: '1', name: '在项目A多选5种类型节点各一个并批量剪切,切换到项目B在目标folder粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B目标folder内新增5个子节点,项目A中的原5个节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除项目A中的原节点' }], notes: [{ id: '1', name: '跨项目批量剪切混合节点时,所有节点的projectId统一更新' }] },
                              { purpose: '批量选择所有类型节点各一个,跨项目,在banner空白区域右键粘贴(ctrl+v粘贴)到根节点下', precondition: [{ id: '1', name: '项目A中包含5种类型节点各至少1个' }], operationSteps: [{ id: '1', name: '在项目A多选5种类型节点各一个并批量剪切,切换到项目B在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,项目B根节点下新增5个节点,项目A中的原5个节点被删除' }], checkpoints: [{ id: '1', name: 'deleteNode删除项目A中的原节点' }], notes: [{ id: '1', name: '跨项目混合节点剪切相当于批量移动到另一个项目' }] },
                              { purpose: '批量选择所有类型节点各一个,在非folder节点鼠标右键不会出现粘贴操作', precondition: [{ id: '1', name: '项目中包含5种类型节点各至少1个' }], operationSteps: [{ id: '1', name: '多选5种类型节点各一个并批量剪切,在非folder节点(如httpNode)右键' }], expectedResults: [{ id: '1', name: '右键菜单中不显示"粘贴"选项' }], checkpoints: [{ id: '1', name: 'v-show指令隐藏粘贴菜单项' }], notes: [{ id: '1', name: '混合节点批量剪切的粘贴限制与单一类型节点相同' }] },
                            ],
                          },
                        ],
                      },
                      //剪切操作特殊场景
                      {
                        modelName: '剪切操作特殊场景',
                        description: '剪切操作特殊场景',
                        children: [
                          {
                            modelName: '剪切后未粘贴操作',
                            description: '剪切后未粘贴操作',
                            atomicFunc: [
                              { purpose: '剪切节点后,在其它位置进行复制操作,原剪切内容被覆盖,无法粘贴之前剪切的内容', precondition: [{ id: '1', name: '项目中包含至少2个httpNode节点' }], operationSteps: [{ id: '1', name: '剪切第一个httpNode节点(添加cut-node类名)' }, { id: '2', name: '复制第二个httpNode节点' }, { id: '3', name: '尝试粘贴剪贴板内容' }], expectedResults: [{ id: '1', name: '粘贴的是第二个httpNode(复制的内容),不是第一个httpNode(剪切的内容)' }, { id: '2', name: 'cutNodes数组被清空(Banner.vue:537)' }, { id: '3', name: '第一个httpNode的cut-node类名消失' }], checkpoints: [{ id: '1', name: 'handleCopyNode方法清空cutNodes.value数组(Banner.vue:537)' }, { id: '2', name: '剪贴板内容被复制操作覆盖,type仍为"apiflow-apidoc-node"但data更新为复制的节点' }], notes: [{ id: '1', name: '复制操作会清空cutNodes数组,使剪切状态失效' }] },
                              { purpose: '剪切节点后,关闭项目再打开,剪切板内容保留,可以正常粘贴', precondition: [{ id: '1', name: '项目中包含至少1个httpNode节点' }], operationSteps: [{ id: '1', name: '剪切httpNode节点' }, { id: '2', name: '关闭项目(不刷新浏览器)' }, { id: '3', name: '重新打开项目' }, { id: '4', name: '在banner空白区域粘贴' }], expectedResults: [{ id: '1', name: '粘贴成功,剪贴板内容(clipboard API)保留' }, { id: '2', name: '但cutNodes数组为空,粘贴后原节点不会被删除(因为cutNodes被重置)' }], checkpoints: [{ id: '1', name: 'navigator.clipboard内容跨会话保留' }, { id: '2', name: 'cutNodes为ref数据,组件重新加载后重置为空数组' }], notes: [{ id: '1', name: '剪贴板内容由浏览器Clipboard API管理,跨会话保留,但cutNodes状态会丢失' }] },
                              { purpose: '剪切folder节点到其自身子节点下,操作被阻止并给出错误提示', precondition: [{ id: '1', name: '项目中包含1个folder节点,该folder内包含至少1个子folder' }], operationSteps: [{ id: '1', name: '剪切父folder节点' }, { id: '2', name: '展开该folder,右键点击其子folder,尝试粘贴' }], expectedResults: [{ id: '1', name: '粘贴操作被阻止,不会执行' }, { id: '2', name: '系统显示错误提示:"不能将folder移动到其自身子节点下"或类似提示' }], checkpoints: [{ id: '1', name: 'pasteNodes方法中应包含循环依赖检测逻辑' }], notes: [{ id: '1', name: '该功能需要在pasteNodes方法中添加父子关系检测,防止循环嵌套' }] },
                            ],
                          },
                        ],
                      },
                    ],
                  },
                  //移动节点
                  {
                    modelName: '移动节点',
                    description: '移动节点',
                    children: [
                      //移动httpNode节点
                      {
                        modelName: '移动httpNode节点',
                        description: '移动httpNode节点',
                        children: [
                          {
                            modelName: '移动单个httpNode节点',
                            description: '移动单个httpNode节点',
                            atomicFunc: [
                              {
                                purpose: '拖拽单个httpNode节点到banner空白区域,移动到根节点下',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '项目中存在至少一个httpNode节点,且该节点位于某个folder内(非根节点)' },
                                  { id: '3', name: 'el-tree组件的draggable属性为true(enableDrag.value为true)' },
                                  { id: '4', name: '节点未处于重命名编辑状态(editNode.value为null)' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域的文档树中找到目标httpNode节点(显示GET/POST等方法图标)' },
                                  { id: '2', name: '鼠标左键按住该httpNode节点' },
                                  { id: '3', name: '拖动节点到banner区域的空白位置(树的根级别区域)' },
                                  { id: '4', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '拖拽过程中显示拖拽占位符指示器' },
                                  { id: '2', name: '释放后节点从原父节点下移除' },
                                  { id: '3', name: '节点出现在根节点列表中(所有folder之后)' },
                                  { id: '4', name: '节点的pid字段更新为空字符串' },
                                  { id: '5', name: '节点的sort字段更新为新的排序值' },
                                  { id: '6', name: '离线模式下IndexedDB中该节点数据被更新' },
                                  { id: '7', name: '在线模式下服务器API被调用更新节点位置' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'el-tree组件配置:draggable="enableDrag"(Banner.vue:18)' },
                                  { id: '2', name: 'handleCheckNodeCouldDrop函数判断拖拽是否允许(Banner.vue:581-599)' },
                                  { id: '3', name: '释放时触发@node-drop事件调用handleNodeDropSuccess(Banner.vue:22)' },
                                  { id: '4', name: 'handleNodeDropSuccess调用dragNode函数(Banner.vue:601-605)' },
                                  { id: '5', name: 'dragNode函数中type为"before"或"after"时,计算新的pid和sort(curd-node.ts:580-650)' },
                                  { id: '6', name: '离线模式调用apiNodesCache.replaceNode更新IndexedDB(curd-node.ts:615)' },
                                  { id: '7', name: '在线模式调用request.put("/api/project/change_doc_pos")更新服务器(curd-node.ts:648)' },
                                ],
                                notes: [
                                  { id: '1', name: '拖拽到根节点的httpNode节点会排列在所有folder之后' },
                                  { id: '2', name: 'sort值通过(previousSiblingSort + nextSiblingSort) / 2计算' },
                                  { id: '3', name: '拖拽期间editNode必须为null,否则输入框会干扰拖拽操作' },
                                ],
                              },
                              {
                                purpose: '拖拽单个httpNode节点到folder节点上,移动到folder节点下',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '项目中存在至少一个httpNode节点和一个folder节点' },
                                  { id: '3', name: 'httpNode节点当前不在目标folder内' },
                                  { id: '4', name: 'enableDrag.value为true' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到目标httpNode节点' },
                                  { id: '2', name: '鼠标左键按住该httpNode节点' },
                                  { id: '3', name: '拖动节点到目标folder节点上方(触发inner模式)' },
                                  { id: '4', name: '等待folder节点高亮显示可放置状态' },
                                  { id: '5', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: 'folder节点高亮显示表示可以接受放置' },
                                  { id: '2', name: '释放后httpNode节点移动到folder内部' },
                                  { id: '3', name: 'folder自动展开显示新加入的httpNode节点' },
                                  { id: '4', name: '节点的pid字段更新为目标folder的_id' },
                                  { id: '5', name: '节点的sort字段更新为Date.now()(追加到末尾)' },
                                  { id: '6', name: 'bannerStore.changeExpandItems被调用展开folder' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCheckNodeCouldDrop判断type==="inner"且dropData.type==="folder"返回true(Banner.vue:596-598)' },
                                  { id: '2', name: 'handleNodeDropSuccess中type为"inner"时调用bannerStore.changeExpandItems(Banner.vue:603-605)' },
                                  { id: '3', name: 'dragNode函数中type==="inner"时设置params.sort = Date.now()(curd-node.ts:592)' },
                                  { id: '4', name: 'dragData.pid被设置为dropData._id(curd-node.ts:593)' },
                                ],
                                notes: [
                                  { id: '1', name: '只有folder类型节点才能接受inner放置' },
                                  { id: '2', name: '拖入folder后自动展开该folder以显示新节点' },
                                  { id: '3', name: '新节点排序值使用Date.now()确保排在folder内最后' },
                                ],
                              },
                              {
                                purpose: '拖拽单个httpNode节点调整在同一层级的顺序',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '同一层级(根目录或同一folder内)存在至少2个httpNode节点' },
                                  { id: '3', name: 'enableDrag.value为true' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到需要移动的httpNode节点A' },
                                  { id: '2', name: '找到目标位置的httpNode节点B' },
                                  { id: '3', name: '鼠标左键按住节点A' },
                                  { id: '4', name: '拖动到节点B的上方或下方(触发before/after模式)' },
                                  { id: '5', name: '观察拖拽指示线出现在目标位置' },
                                  { id: '6', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '拖拽过程中显示横线指示器表示放置位置' },
                                  { id: '2', name: '节点A移动到节点B的指定位置(before或after)' },
                                  { id: '3', name: '节点A的pid字段保持不变(同层级移动)' },
                                  { id: '4', name: '节点A的sort字段更新为相邻节点sort值的中间值' },
                                  { id: '5', name: '文档树实时刷新显示新的节点顺序' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCheckNodeCouldDrop判断type==="prev"或"next"时,非folder节点返回true(Banner.vue:596)' },
                                  { id: '2', name: 'dragNode函数计算newSort = (previousSiblingSort + nextSiblingSort) / 2(curd-node.ts:605-607)' },
                                  { id: '3', name: 'findSiblingById函数查找前后兄弟节点获取sort值(curd-node.ts:601-604)' },
                                  { id: '4', name: 'dragData.sort被更新为计算后的中间值(curd-node.ts:608)' },
                                ],
                                notes: [
                                  { id: '1', name: 'sort值采用中间值算法避免频繁重排整个列表' },
                                  { id: '2', name: '如果前一个节点不存在,previousSiblingSort默认为0' },
                                  { id: '3', name: '如果后一个节点不存在,nextSiblingSort默认为Date.now()' },
                                  { id: '4', name: '同层级移动不改变pid,只改变sort' },
                                ],
                              },
                              {
                                purpose: '拖拽httpNode节点到非folder节点(如httpNode,mockNode等)中,操作被阻止',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '项目中存在至少2个httpNode节点或1个httpNode和1个mockNode' },
                                  { id: '3', name: 'enableDrag.value为true' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到源httpNode节点A' },
                                  { id: '2', name: '鼠标左键按住节点A' },
                                  { id: '3', name: '拖动到另一个httpNode节点B上方并尝试放入其内部(inner模式)' },
                                  { id: '4', name: '观察放置指示器状态' },
                                  { id: '5', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '拖拽到非folder节点上时,不显示inner放置指示器' },
                                  { id: '2', name: '只显示before/after放置指示器(横线)' },
                                  { id: '3', name: '尝试inner放置时,handleCheckNodeCouldDrop返回false' },
                                  { id: '4', name: '节点A不会成为节点B的子节点' },
                                  { id: '5', name: '如果释放位置无效,节点A保持原位置不变' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCheckNodeCouldDrop函数检查dropData.type !== "folder"(Banner.vue:596-598)' },
                                  { id: '2', name: '当dropData.type !== "folder"且type === "inner"时返回false(Banner.vue:598)' },
                                  { id: '3', name: 'el-tree组件根据allow-drop返回值控制放置指示器显示' },
                                ],
                                notes: [
                                  { id: '1', name: '只有folder类型节点才能包含子节点' },
                                  { id: '2', name: 'http,websocket,httpMock,websocketMock类型节点都不能作为容器' },
                                  { id: '3', name: 'handleCheckNodeCouldDrop返回false时el-tree禁止该放置操作' },
                                ],
                              },
                            ],
                          },
                        ],
                      },
                      //移动websocketNode节点
                      {
                        modelName: '移动websocketNode节点',
                        description: '移动websocketNode节点',
                        children: [
                          {
                            modelName: '移动单个websocketNode节点',
                            description: '移动单个websocketNode节点',
                            atomicFunc: [
                              {
                                purpose: '拖拽单个websocketNode节点到banner空白区域,移动到根节点下',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '项目中存在至少一个websocketNode节点,且该节点位于某个folder内' },
                                  { id: '3', name: 'el-tree组件的draggable属性为true' },
                                  { id: '4', name: '节点未处于重命名编辑状态' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到目标websocketNode节点(显示WS/WSS图标)' },
                                  { id: '2', name: '鼠标左键按住该websocketNode节点' },
                                  { id: '3', name: '拖动节点到banner区域的空白位置(根级别区域)' },
                                  { id: '4', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '拖拽过程中显示拖拽占位符指示器' },
                                  { id: '2', name: '释放后节点从原父节点下移除' },
                                  { id: '3', name: '节点出现在根节点列表中(所有folder之后)' },
                                  { id: '4', name: '节点的pid字段更新为空字符串' },
                                  { id: '5', name: '节点的sort字段更新为新的排序值' },
                                  { id: '6', name: '离线模式下IndexedDB数据同步更新' },
                                  { id: '7', name: '在线模式下调用/api/project/change_doc_pos接口' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'websocketNode节点拖拽逻辑与httpNode完全相同(Banner.vue:18-22)' },
                                  { id: '2', name: 'handleCheckNodeCouldDrop对websocketNode节点应用相同规则(Banner.vue:581-599)' },
                                  { id: '3', name: 'dragNode函数统一处理所有节点类型的拖拽(curd-node.ts:580-650)' },
                                  { id: '4', name: 'websocketNode的type字段为"websocket",不影响拖拽逻辑' },
                                ],
                                notes: [
                                  { id: '1', name: 'websocketNode节点显示protocol.toUpperCase()图标(WS或WSS)' },
                                  { id: '2', name: '拖拽逻辑对所有非folder类型节点一视同仁' },
                                  { id: '3', name: 'websocketNode同样不能拖拽到folder前面' },
                                ],
                              },
                              {
                                purpose: '拖拽单个websocketNode节点到folder节点上,移动到folder节点下',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '项目中存在至少一个websocketNode节点和一个folder节点' },
                                  { id: '3', name: 'websocketNode节点当前不在目标folder内' },
                                  { id: '4', name: 'enableDrag.value为true' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到目标websocketNode节点(显示WS/WSS图标)' },
                                  { id: '2', name: '鼠标左键按住该websocketNode节点' },
                                  { id: '3', name: '拖动节点到目标folder节点上方(触发inner模式)' },
                                  { id: '4', name: '等待folder节点高亮显示可放置状态' },
                                  { id: '5', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: 'folder节点高亮显示表示可以接受放置' },
                                  { id: '2', name: '释放后websocketNode节点移动到folder内部' },
                                  { id: '3', name: 'folder自动展开显示新加入的websocketNode节点' },
                                  { id: '4', name: '节点的pid字段更新为目标folder的_id' },
                                  { id: '5', name: '节点的sort字段更新为Date.now()' },
                                  { id: '6', name: 'bannerStore.changeExpandItems被调用展开folder' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCheckNodeCouldDrop判断type==="inner"且dropData.type==="folder"返回true(Banner.vue:596-598)' },
                                  { id: '2', name: 'handleNodeDropSuccess中type为"inner"时调用bannerStore.changeExpandItems(Banner.vue:603-605)' },
                                  { id: '3', name: 'dragNode函数中type==="inner"时设置newSort = Date.now()(curd-node.ts:592)' },
                                  { id: '4', name: 'dragData.pid被设置为dropData._id(curd-node.ts:593)' },
                                ],
                                notes: [
                                  { id: '1', name: 'websocketNode拖入folder的逻辑与httpNode完全相同' },
                                  { id: '2', name: '拖入folder后节点排在该folder内所有现有节点之后' },
                                  { id: '3', name: 'folder会自动展开以显示新加入的节点' },
                                ],
                              },
                              {
                                purpose: '拖拽单个websocketNode节点调整在同一层级的顺序',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '同一层级存在至少2个websocketNode节点或1个websocketNode和其他类型节点' },
                                  { id: '3', name: 'enableDrag.value为true' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到需要移动的websocketNode节点A' },
                                  { id: '2', name: '找到目标位置的节点B' },
                                  { id: '3', name: '鼠标左键按住节点A' },
                                  { id: '4', name: '拖动到节点B的上方或下方(触发before/after模式)' },
                                  { id: '5', name: '观察拖拽指示线出现在目标位置' },
                                  { id: '6', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '拖拽过程中显示横线指示器表示放置位置' },
                                  { id: '2', name: '节点A移动到节点B的指定位置' },
                                  { id: '3', name: '节点A的pid字段保持不变' },
                                  { id: '4', name: '节点A的sort字段更新为相邻节点sort值的中间值' },
                                  { id: '5', name: '文档树实时刷新显示新的节点顺序' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCheckNodeCouldDrop对非folder节点的before/after放置返回true(Banner.vue:596)' },
                                  { id: '2', name: 'dragNode计算sort = (previousSiblingSort + nextSiblingSort) / 2(curd-node.ts:605-607)' },
                                  { id: '3', name: 'findSiblingById获取前后兄弟节点的sort值(curd-node.ts:601-604)' },
                                ],
                                notes: [
                                  { id: '1', name: 'websocketNode同层级排序逻辑与所有节点类型相同' },
                                  { id: '2', name: 'sort中间值算法确保不需要重排所有节点' },
                                  { id: '3', name: '非folder节点不能排在folder节点前面' },
                                ],
                              },
                              {
                                purpose: '拖拽websocketNode节点到非folder节点,操作被阻止',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '项目中存在websocketNode节点和其他非folder节点' },
                                  { id: '3', name: 'enableDrag.value为true' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到源websocketNode节点' },
                                  { id: '2', name: '鼠标左键按住该节点' },
                                  { id: '3', name: '拖动到httpNode或mockNode节点上方并尝试放入其内部' },
                                  { id: '4', name: '观察放置指示器状态' },
                                  { id: '5', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '拖拽到非folder节点上时,不显示inner放置指示器' },
                                  { id: '2', name: '只显示before/after放置指示器' },
                                  { id: '3', name: 'handleCheckNodeCouldDrop对inner模式返回false' },
                                  { id: '4', name: '节点不会成为目标节点的子节点' },
                                  { id: '5', name: '无效释放位置节点保持原位置' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCheckNodeCouldDrop检查dropData.type !== "folder"时inner模式返回false(Banner.vue:596-598)' },
                                  { id: '2', name: 'el-tree组件根据allow-drop返回值禁止inner放置' },
                                ],
                                notes: [
                                  { id: '1', name: '所有非folder节点都不能作为容器接受子节点' },
                                  { id: '2', name: 'websocketNode的拖拽限制与httpNode完全一致' },
                                ],
                              },
                            ],
                          },
                        ],
                      },
                      //移动httpMockNode节点
                      {
                        modelName: '移动httpMockNode节点',
                        description: '移动httpMockNode节点',
                        children: [
                          {
                            modelName: '移动单个httpMockNode节点',
                            description: '移动单个httpMockNode节点',
                            atomicFunc: [
                              {
                                purpose: '拖拽单个httpMockNode节点到banner空白区域,移动到根节点下',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '项目中存在至少一个httpMockNode节点,且位于某个folder内' },
                                  { id: '3', name: 'el-tree组件的draggable属性为true' },
                                  { id: '4', name: '节点未处于重命名编辑状态' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到目标httpMockNode节点(显示mock图标)' },
                                  { id: '2', name: '鼠标左键按住该httpMockNode节点' },
                                  { id: '3', name: '拖动节点到banner区域的空白位置(根级别区域)' },
                                  { id: '4', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '拖拽过程中显示拖拽占位符指示器' },
                                  { id: '2', name: '释放后节点从原父节点下移除' },
                                  { id: '3', name: '节点出现在根节点列表中(所有folder之后)' },
                                  { id: '4', name: '节点的pid字段更新为空字符串' },
                                  { id: '5', name: '节点的sort字段更新为新的排序值' },
                                  { id: '6', name: '离线模式下IndexedDB数据同步更新' },
                                  { id: '7', name: '在线模式下调用/api/project/change_doc_pos接口' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'httpMockNode节点type为"httpMock"(Banner.vue:63-110)' },
                                  { id: '2', name: 'handleCheckNodeCouldDrop对httpMockNode应用相同拖拽规则(Banner.vue:581-599)' },
                                  { id: '3', name: 'dragNode函数统一处理所有节点类型(curd-node.ts:580-650)' },
                                  { id: '4', name: '离线模式调用apiNodesCache.replaceNode更新数据(curd-node.ts:615)' },
                                ],
                                notes: [
                                  { id: '1', name: 'httpMockNode显示"mock"文字图标区分于普通http节点' },
                                  { id: '2', name: 'httpMockNode可能有state状态指示器(running/starting/stopping/error)' },
                                  { id: '3', name: '拖拽逻辑不受Mock运行状态影响' },
                                ],
                              },
                              {
                                purpose: '拖拽单个httpMockNode节点到folder节点上,移动到folder节点下',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '项目中存在至少一个httpMockNode节点和一个folder节点' },
                                  { id: '3', name: 'httpMockNode节点当前不在目标folder内' },
                                  { id: '4', name: 'enableDrag.value为true' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到目标httpMockNode节点(显示mock图标)' },
                                  { id: '2', name: '鼠标左键按住该httpMockNode节点' },
                                  { id: '3', name: '拖动节点到目标folder节点上方(触发inner模式)' },
                                  { id: '4', name: '等待folder节点高亮显示可放置状态' },
                                  { id: '5', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: 'folder节点高亮显示表示可以接受放置' },
                                  { id: '2', name: '释放后httpMockNode节点移动到folder内部' },
                                  { id: '3', name: 'folder自动展开显示新加入的httpMockNode节点' },
                                  { id: '4', name: '节点的pid字段更新为目标folder的_id' },
                                  { id: '5', name: '节点的sort字段更新为Date.now()' },
                                  { id: '6', name: 'Mock状态指示器(如果有)随节点一起移动' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCheckNodeCouldDrop对httpMockNode的inner放置返回true(Banner.vue:596-598)' },
                                  { id: '2', name: 'dragNode设置newPid = dropData._id, newSort = Date.now()(curd-node.ts:590-593)' },
                                  { id: '3', name: 'bannerStore.changeExpandItems展开目标folder(Banner.vue:603-605)' },
                                ],
                                notes: [
                                  { id: '1', name: 'httpMockNode拖入folder不影响其Mock服务运行状态' },
                                  { id: '2', name: 'folder内可包含不同类型节点(http,websocket,mock等)' },
                                  { id: '3', name: '包含运行中Mock的folder会显示folder-mock-indicator指示器' },
                                ],
                              },
                              {
                                purpose: '拖拽单个httpMockNode节点调整在同一层级的顺序',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '同一层级存在多个httpMockNode节点' },
                                  { id: '3', name: 'enableDrag.value为true' },
                                  { id: '4', name: '节点未处于重命名编辑状态' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到需要调整顺序的httpMockNode节点' },
                                  { id: '2', name: '鼠标左键按住该httpMockNode节点' },
                                  { id: '3', name: '拖动节点到同层级其他节点的before或after位置' },
                                  { id: '4', name: '观察放置指示线显示在目标位置' },
                                  { id: '5', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '拖拽过程中显示before/after放置指示线' },
                                  { id: '2', name: '释放后节点调整到新的顺序位置' },
                                  { id: '3', name: '节点的sort字段更新为相邻节点sort值的中间值' },
                                  { id: '4', name: '节点的pid保持不变(同一层级)' },
                                  { id: '5', name: '离线模式下调用apiNodesCache.replaceNode更新数据' },
                                  { id: '6', name: '在线模式下调用/api/project/change_doc_pos接口' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'dragNode函数对before/after类型计算newSort = (nextSiblingSort + previousSiblingSort) / 2(curd-node.ts:602-606)' },
                                  { id: '2', name: 'findSiblingById获取前后兄弟节点的sort值(curd-node.ts:600-604)' },
                                  { id: '3', name: 'type !== "inner"时newPid来自父节点(curd-node.ts:599-601)' },
                                ],
                                notes: [
                                  { id: '1', name: 'sort值使用中间值策略避免频繁重排所有节点' },
                                  { id: '2', name: 'httpMockNode顺序调整不影响Mock服务运行状态' },
                                  { id: '3', name: 'folder节点始终排在非folder节点之前' },
                                ],
                              },
                              {
                                purpose: '拖拽httpMockNode节点到非folder节点,操作被阻止',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '项目中存在至少一个httpMockNode节点和一个非folder节点' },
                                  { id: '3', name: 'el-tree组件的draggable属性为true' },
                                  { id: '4', name: '目标节点为httpNode,websocketNode或其他Mock节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到httpMockNode节点' },
                                  { id: '2', name: '鼠标左键按住该httpMockNode节点' },
                                  { id: '3', name: '拖动节点到非folder节点上方(尝试触发inner模式)' },
                                  { id: '4', name: '观察放置指示器状态' },
                                  { id: '5', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '拖拽到非folder节点上时,不显示inner放置指示器' },
                                  { id: '2', name: '只显示before/after放置指示器' },
                                  { id: '3', name: 'handleCheckNodeCouldDrop对inner模式返回false' },
                                  { id: '4', name: '节点不会成为目标节点的子节点' },
                                  { id: '5', name: '无效释放位置节点保持原位置' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCheckNodeCouldDrop检查dropData.type !== "folder"时inner模式返回false(Banner.vue:596-598)' },
                                  { id: '2', name: 'el-tree组件根据allow-drop返回值禁止inner放置' },
                                ],
                                notes: [
                                  { id: '1', name: '所有非folder节点都不能作为容器接受子节点' },
                                  { id: '2', name: 'httpMockNode的拖拽限制与httpNode完全一致' },
                                ],
                              },
                            ],
                          },
                        ],
                      },
                      //移动websocketMockNode节点
                      {
                        modelName: '移动websocketMockNode节点',
                        description: '移动websocketMockNode节点',
                        children: [
                          {
                            modelName: '移动单个websocketMockNode节点',
                            description: '移动单个websocketMockNode节点',
                            atomicFunc: [
                              {
                                purpose: '拖拽单个websocketMockNode节点到banner空白区域,移动到根节点下',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '项目中存在至少一个websocketMockNode节点,且位于某个folder内' },
                                  { id: '3', name: 'el-tree组件的draggable属性为true' },
                                  { id: '4', name: '节点未处于重命名编辑状态' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到目标websocketMockNode节点(显示ws mock图标)' },
                                  { id: '2', name: '鼠标左键按住该websocketMockNode节点' },
                                  { id: '3', name: '拖动节点到banner区域的空白位置(根级别区域)' },
                                  { id: '4', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '拖拽过程中显示拖拽占位符指示器' },
                                  { id: '2', name: '释放后节点从原父节点下移除' },
                                  { id: '3', name: '节点出现在根节点列表中(所有folder之后)' },
                                  { id: '4', name: '节点的pid字段更新为空字符串' },
                                  { id: '5', name: '节点的sort字段更新为新的排序值' },
                                  { id: '6', name: '离线模式下IndexedDB数据同步更新' },
                                  { id: '7', name: '在线模式下调用/api/project/change_doc_pos接口' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'websocketMockNode节点type为"websocketMock"' },
                                  { id: '2', name: 'handleCheckNodeCouldDrop对websocketMockNode应用相同拖拽规则(Banner.vue:581-599)' },
                                  { id: '3', name: 'dragNode函数统一处理所有节点类型(curd-node.ts:580-650)' },
                                  { id: '4', name: '离线模式调用apiNodesCache.replaceNode更新数据(curd-node.ts:615)' },
                                ],
                                notes: [
                                  { id: '1', name: 'websocketMockNode显示特定图标区分于普通websocket节点' },
                                  { id: '2', name: 'websocketMockNode可能有state状态指示器(running/starting/stopping/error)' },
                                  { id: '3', name: '拖拽逻辑不受Mock运行状态影响' },
                                ],
                              },
                              {
                                purpose: '拖拽单个websocketMockNode节点到folder节点上,移动到folder节点下',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '项目中存在至少一个websocketMockNode节点和一个folder节点' },
                                  { id: '3', name: 'websocketMockNode节点当前不在目标folder内' },
                                  { id: '4', name: 'enableDrag.value为true' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到目标websocketMockNode节点' },
                                  { id: '2', name: '鼠标左键按住该websocketMockNode节点' },
                                  { id: '3', name: '拖动节点到目标folder节点上方(触发inner模式)' },
                                  { id: '4', name: '等待folder节点高亮显示可放置状态' },
                                  { id: '5', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: 'folder节点高亮显示表示可以接受放置' },
                                  { id: '2', name: '释放后websocketMockNode节点移动到folder内部' },
                                  { id: '3', name: 'folder自动展开显示新加入的websocketMockNode节点' },
                                  { id: '4', name: '节点的pid字段更新为目标folder的_id' },
                                  { id: '5', name: '节点的sort字段更新为Date.now()' },
                                  { id: '6', name: 'Mock状态指示器(如果有)随节点一起移动' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCheckNodeCouldDrop对websocketMockNode的inner放置返回true(Banner.vue:596-598)' },
                                  { id: '2', name: 'dragNode设置newPid = dropData._id, newSort = Date.now()(curd-node.ts:596-597)' },
                                  { id: '3', name: 'bannerStore.changeExpandItems展开目标folder(Banner.vue:603-605)' },
                                ],
                                notes: [
                                  { id: '1', name: 'websocketMockNode拖入folder不影响其Mock服务运行状态' },
                                  { id: '2', name: 'folder内可包含不同类型节点(http,websocket,mock等)' },
                                ],
                              },
                              {
                                purpose: '拖拽单个websocketMockNode节点调整在同一层级的顺序',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '同一层级存在多个websocketMockNode节点' },
                                  { id: '3', name: 'enableDrag.value为true' },
                                  { id: '4', name: '节点未处于重命名编辑状态' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到需要调整顺序的websocketMockNode节点' },
                                  { id: '2', name: '鼠标左键按住该websocketMockNode节点' },
                                  { id: '3', name: '拖动节点到同层级其他节点的before或after位置' },
                                  { id: '4', name: '观察放置指示线显示在目标位置' },
                                  { id: '5', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '拖拽过程中显示before/after放置指示线' },
                                  { id: '2', name: '释放后节点调整到新的顺序位置' },
                                  { id: '3', name: '节点的sort字段更新为相邻节点sort值的中间值' },
                                  { id: '4', name: '节点的pid保持不变(同一层级)' },
                                  { id: '5', name: '离线模式下调用apiNodesCache.replaceNode更新数据' },
                                  { id: '6', name: '在线模式下调用/api/project/change_doc_pos接口' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'dragNode函数对before/after类型计算newSort = (nextSiblingSort + previousSiblingSort) / 2(curd-node.ts:602-606)' },
                                  { id: '2', name: 'findSiblingById获取前后兄弟节点的sort值(curd-node.ts:600-604)' },
                                ],
                                notes: [
                                  { id: '1', name: 'sort值使用中间值策略避免频繁重排所有节点' },
                                  { id: '2', name: 'websocketMockNode顺序调整不影响Mock服务运行状态' },
                                ],
                              },
                              {
                                purpose: '跨项目拖拽单个websocketMockNode节点到目标项目根节点下',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '当前工作区同时打开了多个项目' },
                                  { id: '3', name: '源项目中存在websocketMockNode节点' },
                                  { id: '4', name: 'enableDrag.value为true' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在源项目的banner区域找到websocketMockNode节点' },
                                  { id: '2', name: '鼠标左键按住该websocketMockNode节点' },
                                  { id: '3', name: '拖动节点到目标项目的banner区域' },
                                  { id: '4', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '跨项目拖拽被系统禁止' },
                                  { id: '2', name: '节点保持在原项目中不变' },
                                  { id: '3', name: '不触发任何数据更新操作' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'el-tree组件不支持跨树实例拖拽' },
                                  { id: '2', name: '每个项目有独立的el-tree实例' },
                                ],
                                notes: [
                                  { id: '1', name: '跨项目移动节点应使用复制/剪切/粘贴功能' },
                                  { id: '2', name: 'Mock节点跨项目复制可能需要重新配置端口等信息' },
                                ],
                              },
                              {
                                purpose: '拖拽websocketMockNode节点到非folder节点,操作被阻止',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '项目中存在至少一个websocketMockNode节点和一个非folder节点' },
                                  { id: '3', name: 'el-tree组件的draggable属性为true' },
                                  { id: '4', name: '目标节点为httpNode,websocketNode或其他Mock节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到websocketMockNode节点' },
                                  { id: '2', name: '鼠标左键按住该websocketMockNode节点' },
                                  { id: '3', name: '拖动节点到非folder节点上方(尝试触发inner模式)' },
                                  { id: '4', name: '观察放置指示器状态' },
                                  { id: '5', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '拖拽到非folder节点上时,不显示inner放置指示器' },
                                  { id: '2', name: '只显示before/after放置指示器' },
                                  { id: '3', name: 'handleCheckNodeCouldDrop对inner模式返回false' },
                                  { id: '4', name: '节点不会成为目标节点的子节点' },
                                  { id: '5', name: '无效释放位置节点保持原位置' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCheckNodeCouldDrop检查dropData.type !== "folder"时inner模式返回false(Banner.vue:596-598)' },
                                  { id: '2', name: 'el-tree组件根据allow-drop返回值禁止inner放置' },
                                ],
                                notes: [
                                  { id: '1', name: '所有非folder节点都不能作为容器接受子节点' },
                                  { id: '2', name: 'websocketMockNode的拖拽限制与其他非folder节点完全一致' },
                                ],
                              },
                            ],
                          },
                        ],
                      },
                      //移动folder节点
                      {
                        modelName: '移动folder节点',
                        description: '移动folder节点',
                        children: [
                          {
                            modelName: '移动单个folder节点',
                            description: '移动单个folder节点',
                            atomicFunc: [
                              {
                                purpose: '拖拽单个folder节点到banner空白区域,移动到根节点下',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '项目中存在至少一个folder节点,且位于某个父folder内' },
                                  { id: '3', name: 'el-tree组件的draggable属性为true' },
                                  { id: '4', name: '节点未处于重命名编辑状态' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到目标folder节点(显示文件夹图标)' },
                                  { id: '2', name: '鼠标左键按住该folder节点' },
                                  { id: '3', name: '拖动节点到banner区域的空白位置(根级别区域)' },
                                  { id: '4', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '拖拽过程中显示拖拽占位符指示器' },
                                  { id: '2', name: '释放后folder节点从原父节点下移除' },
                                  { id: '3', name: 'folder节点出现在根节点列表中(与其他folder同级)' },
                                  { id: '4', name: 'folder内的所有子节点随之移动' },
                                  { id: '5', name: '节点的pid字段更新为空字符串' },
                                  { id: '6', name: '节点的sort字段更新为新的排序值' },
                                  { id: '7', name: '离线模式下IndexedDB数据同步更新' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'folder节点type为"folder"' },
                                  { id: '2', name: 'handleCheckNodeCouldDrop对folder节点允许拖拽(Banner.vue:581-599)' },
                                  { id: '3', name: 'dragNode函数统一处理所有节点类型(curd-node.ts:580-650)' },
                                ],
                                notes: [
                                  { id: '1', name: 'folder拖拽时其所有子节点保持层级关系' },
                                  { id: '2', name: 'folder只能放在其他folder之间,不能放在非folder节点之前' },
                                ],
                              },
                              {
                                purpose: '拖拽单个folder节点到folder节点上,移动到folder节点下作为子节点',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '项目中存在至少两个folder节点' },
                                  { id: '3', name: '被拖拽folder不是目标folder的父级或自身' },
                                  { id: '4', name: 'enableDrag.value为true' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到需要移动的folder节点' },
                                  { id: '2', name: '鼠标左键按住该folder节点' },
                                  { id: '3', name: '拖动节点到目标folder节点上方(触发inner模式)' },
                                  { id: '4', name: '等待目标folder节点高亮显示可放置状态' },
                                  { id: '5', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '目标folder节点高亮显示表示可以接受放置' },
                                  { id: '2', name: '释放后folder节点移动到目标folder内部' },
                                  { id: '3', name: '目标folder自动展开显示新加入的folder节点' },
                                  { id: '4', name: '节点的pid字段更新为目标folder的_id' },
                                  { id: '5', name: '被移动folder内的所有子节点保持层级关系' },
                                  { id: '6', name: '节点的sort字段更新为Date.now()' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'handleCheckNodeCouldDrop对folder的inner放置返回true(Banner.vue:596-598)' },
                                  { id: '2', name: 'dragNode设置newPid = dropData._id(curd-node.ts:596)' },
                                  { id: '3', name: 'bannerStore.changeExpandItems展开目标folder(Banner.vue:603-605)' },
                                ],
                                notes: [
                                  { id: '1', name: 'folder支持多层嵌套结构' },
                                  { id: '2', name: '嵌套层级无限制,但建议控制在3-5层以内' },
                                ],
                              },
                              {
                                purpose: '拖拽folder节点调整在同一层级的顺序',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '同一层级存在多个folder节点' },
                                  { id: '3', name: 'enableDrag.value为true' },
                                  { id: '4', name: '节点未处于重命名编辑状态' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到需要调整顺序的folder节点' },
                                  { id: '2', name: '鼠标左键按住该folder节点' },
                                  { id: '3', name: '拖动节点到同层级其他folder节点的before或after位置' },
                                  { id: '4', name: '观察放置指示线显示在目标位置' },
                                  { id: '5', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '拖拽过程中显示before/after放置指示线' },
                                  { id: '2', name: '释放后folder节点调整到新的顺序位置' },
                                  { id: '3', name: '节点的sort字段更新为相邻节点sort值的中间值' },
                                  { id: '4', name: '节点的pid保持不变(同一层级)' },
                                  { id: '5', name: 'folder内的子节点顺序不变' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'dragNode函数对before/after类型计算newSort = (nextSiblingSort + previousSiblingSort) / 2(curd-node.ts:602-606)' },
                                  { id: '2', name: 'folder只能在folder之间移动,不能移动到非folder节点之后(Banner.vue:591-593)' },
                                ],
                                notes: [
                                  { id: '1', name: 'folder节点始终排在非folder节点之前' },
                                  { id: '2', name: 'sort值使用中间值策略避免频繁重排' },
                                ],
                              },
                              {
                                purpose: '拖拽folder节点调整在同一层级的顺序',
                                precondition: [{ id: '1', name: '同一层级存在至少2个folder节点' }],
                                operationSteps: [{ id: '1', name: '拖拽folderA到folderB的上方或下方' }],
                                expectedResults: [{ id: '1', name: 'folderA移动到指定位置,sort值更新,pid保持不变' }],
                                checkpoints: [{ id: '1', name: 'dragNode计算新sort值(curd-node.ts:605-608)' }],
                                notes: [{ id: '1', name: 'folder同层级移动逻辑与httpNode相同' }],
                              },
                              {
                                purpose: '跨项目拖拽单个folder节点到目标项目folder节点下',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '当前工作区同时打开了多个项目' },
                                  { id: '3', name: '源项目中存在folder节点' },
                                  { id: '4', name: 'enableDrag.value为true' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在源项目的banner区域找到folder节点' },
                                  { id: '2', name: '鼠标左键按住该folder节点' },
                                  { id: '3', name: '拖动节点到目标项目的folder节点上' },
                                  { id: '4', name: '释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '跨项目拖拽被系统禁止' },
                                  { id: '2', name: 'folder节点保持在原项目中不变' },
                                  { id: '3', name: '不触发任何数据更新操作' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'el-tree组件不支持跨树实例拖拽' },
                                  { id: '2', name: '每个项目有独立的el-tree实例' },
                                ],
                                notes: [
                                  { id: '1', name: '跨项目移动folder应使用复制/剪切/粘贴功能' },
                                  { id: '2', name: '复制/粘贴会保持folder内部的层级结构' },
                                ],
                              },
                              {
                                purpose: '拖拽folder节点到其自身子节点下,操作被阻止并提示错误',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '项目中存在至少一个包含子节点的folder节点' },
                                  { id: '3', name: 'el-tree组件的draggable属性为true' },
                                  { id: '4', name: 'folder节点已展开显示子节点' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到包含子节点的folder节点' },
                                  { id: '2', name: '鼠标左键按住该folder节点' },
                                  { id: '3', name: '拖动节点到其子节点(或子folder)上方' },
                                  { id: '4', name: '尝试释放鼠标左键' },
                                ],
                                expectedResults: [
                                  { id: '1', name: 'el-tree内置逻辑阻止将父节点拖入子节点' },
                                  { id: '2', name: '不显示有效的放置指示器' },
                                  { id: '3', name: '释放后folder节点保持原位置' },
                                  { id: '4', name: '防止循环引用的数据结构' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'el-tree组件内置父子关系检查逻辑' },
                                  { id: '2', name: 'handleCheckNodeCouldDrop不会被调用到这种情况' },
                                ],
                                notes: [
                                  { id: '1', name: 'el-tree组件自动处理循环引用检查' },
                                  { id: '2', name: '无需在handleCheckNodeCouldDrop中额外处理' },
                                ],
                              },
                              {
                                purpose: '移动包含多层嵌套的folder节点,层级结构保持不变',
                                precondition: [
                                  { id: '1', name: '已登录并打开任意项目工作区' },
                                  { id: '2', name: '存在包含多层嵌套子节点的folder节点' },
                                  { id: '3', name: 'enableDrag.value为true' },
                                  { id: '4', name: '嵌套folder内包含各类型节点(http,websocket,mock等)' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到包含多层嵌套的folder节点' },
                                  { id: '2', name: '鼠标左键按住该folder节点' },
                                  { id: '3', name: '拖动节点到目标位置(根级别或其他folder内)' },
                                  { id: '4', name: '释放鼠标左键' },
                                  { id: '5', name: '展开移动后的folder验证层级结构' },
                                ],
                                expectedResults: [
                                  { id: '1', name: 'folder节点成功移动到目标位置' },
                                  { id: '2', name: '所有子节点随父folder一起移动' },
                                  { id: '3', name: '嵌套层级结构完全保持不变' },
                                  { id: '4', name: '子节点的pid关系保持正确' },
                                  { id: '5', name: '只更新被拖拽folder的pid和sort' },
                                  { id: '6', name: '子节点数据无需单独更新' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'dragNode只更新被拖拽节点本身的pid和sort(curd-node.ts:593-608)' },
                                  { id: '2', name: 'el-tree组件自动维护children数组关系' },
                                  { id: '3', name: '子节点通过pid引用父节点,父节点移动不影响子节点pid' },
                                ],
                                notes: [
                                  { id: '1', name: '树形结构通过pid实现父子关系,拖拽时保持引用完整' },
                                  { id: '2', name: '性能优化:只需更新一条记录即可完成整棵子树移动' },
                                ],
                              },
                            ],
                          },
                        ],
                      },
                      //移动操作特殊场景
                      {
                        modelName: '移动操作特殊场景',
                        description: '移动操作特殊场景',
                        children: [
                          {
                            modelName: '移动性能与体验',
                            description: '移动性能与体验',
                            atomicFunc: [
                              {
                                purpose: '大量节点场景下的拖拽性能测试',
                                precondition: [
                                  { id: '1', name: '已登录并打开包含大量节点(100+)的项目工作区' },
                                  { id: '2', name: 'el-tree组件的draggable属性为true' },
                                  { id: '3', name: '节点分布在多个层级的folder中' },
                                ],
                                operationSteps: [
                                  { id: '1', name: '在banner区域找到任意节点' },
                                  { id: '2', name: '鼠标左键按住该节点开始拖拽' },
                                  { id: '3', name: '快速移动鼠标在不同层级节点间滑动' },
                                  { id: '4', name: '观察拖拽过程中的UI响应' },
                                  { id: '5', name: '释放鼠标完成拖拽' },
                                ],
                                expectedResults: [
                                  { id: '1', name: '拖拽过程中UI保持流畅,无明显卡顿' },
                                  { id: '2', name: '放置指示器实时响应鼠标位置' },
                                  { id: '3', name: '拖拽释放后数据更新及时' },
                                  { id: '4', name: 'el-tree渲染性能满足交互需求' },
                                ],
                                checkpoints: [
                                  { id: '1', name: 'el-tree使用虚拟滚动优化大量数据渲染' },
                                  { id: '2', name: 'handleCheckNodeCouldDrop函数执行效率高' },
                                ],
                                notes: [
                                  { id: '1', name: '建议项目节点数量控制在合理范围内' },
                                  { id: '2', name: '过多节点可考虑分拆为多个项目' },
                                ],
                              },
                            ],
                          },
                        ],
                      },
                    ],
                  },
                  //右键菜单
                  {
                    modelName: '鼠标右键',
                    description: '鼠标右键',
                    children: [
                      {
                        modelName: '鼠标右键空白区域',
                        description: '鼠标右键空白区域',
                        atomicFunc: [
                          {
                            purpose: '鼠标右键空白区域,出现新建接口,新建文件夹,设置公共请求头,粘贴节点(可能置灰)等功能',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: 'banner区域已加载完成' },
                              { id: '3', name: 'showContextmenu初始值为false' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域的空白位置点击鼠标右键' },
                              { id: '2', name: '观察弹出的右键菜单内容' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'showContextmenu变为true' },
                              { id: '2', name: '显示SContextmenu组件' },
                              { id: '3', name: '菜单中显示"新建接口"选项' },
                              { id: '4', name: '菜单中显示"新建文件夹"选项' },
                              { id: '5', name: '菜单中显示"设置公共请求头"选项' },
                              { id: '6', name: '菜单中显示"粘贴"选项(若无剪贴板数据则置灰)' },
                              { id: '7', name: '不显示剪切,复制,重命名,删除等选项' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleWrapContextmenu处理空白区域右键事件(Banner.vue:10)' },
                              { id: '2', name: 'currentOperationalNode为null时显示新建相关菜单项(Banner.vue:223-228)' },
                              { id: '3', name: 'pasteValue判断粘贴按钮是否可用(Banner.vue:238-239)' },
                            ],
                            notes: [
                              { id: '1', name: '空白区域右键不选中任何节点' },
                              { id: '2', name: '菜单位置跟随鼠标点击位置' },
                            ],
                          },
                          {
                            purpose: '鼠标右键空白区域,点击新建接口(httpNode,websocketNode,httpMockNode,websocketMockNode),成功后在根节点末尾生成节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '已在空白区域右键打开菜单' },
                              { id: '3', name: '菜单中显示"新建接口"选项' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击右键菜单中的"新建接口"选项' },
                              { id: '2', name: '在弹出的对话框中选择节点类型(HTTP/WebSocket/HTTPMock/WebSocketMock)' },
                              { id: '3', name: '输入接口名称' },
                              { id: '4', name: '点击确定按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'addFileDialogVisible变为true,弹出SAddFileDialog对话框' },
                              { id: '2', name: '对话框pid参数为undefined(空白区域)' },
                              { id: '3', name: '确认后新节点出现在根节点列表末尾' },
                              { id: '4', name: '新节点的pid为空字符串' },
                              { id: '5', name: '新节点的sort值为Date.now()确保排在末尾' },
                              { id: '6', name: '离线模式下调用apiNodesCache.addNode保存数据' },
                              { id: '7', name: '在线模式下调用/api/project/doc接口创建节点' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleOpenAddFileDialog打开新建对话框(Banner.vue:224)' },
                              { id: '2', name: 'SAddFileDialog组件接收pid参数(Banner.vue:256-257)' },
                              { id: '3', name: 'handleAddFileAndFolderCb回调处理新节点添加' },
                            ],
                            notes: [
                              { id: '1', name: '新建的节点类型由对话框内选择决定' },
                              { id: '2', name: '节点名称支持自定义输入' },
                            ],
                          },
                          {
                            purpose: '鼠标右键空白区域,点击新建文件夹,成功后在根节点最后一个目录节点下面生成目录节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '已在空白区域右键打开菜单' },
                              { id: '3', name: '菜单中显示"新建文件夹"选项' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击右键菜单中的"新建文件夹"选项' },
                              { id: '2', name: '在弹出的对话框中输入文件夹名称' },
                              { id: '3', name: '点击确定按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'addFolderDialogVisible变为true,弹出SAddFolderDialog对话框' },
                              { id: '2', name: '确认后新folder出现在根级别' },
                              { id: '3', name: '新folder排在已有folder之后,非folder节点之前' },
                              { id: '4', name: '新folder的type为"folder"' },
                              { id: '5', name: '新folder的pid为空字符串' },
                              { id: '6', name: '离线模式下调用apiNodesCache.addNode保存数据' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleOpenAddFolderDialog打开新建文件夹对话框(Banner.vue:226)' },
                              { id: '2', name: 'SAddFolderDialog组件接收pid参数(Banner.vue:258-259)' },
                              { id: '3', name: 'folder节点的sort值需要保证排在非folder节点之前' },
                            ],
                            notes: [
                              { id: '1', name: 'folder始终排在非folder节点之前' },
                              { id: '2', name: '新建folder默认处于展开状态' },
                            ],
                          },
                          {
                            purpose: '鼠标右键空白区域,点击设置公共请求头,导航区域增加公共请求头标签,内容区域出现公共请求头设置内容',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '已在空白区域右键打开菜单' },
                              { id: '3', name: '菜单中显示"设置公共请求头"选项' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击右键菜单中的"设置公共请求头"选项' },
                              { id: '2', name: '观察导航区域和内容区域的变化' },
                            ],
                            expectedResults: [
                              { id: '1', name: '右键菜单关闭' },
                              { id: '2', name: '导航区域新增"公共请求头"标签页' },
                              { id: '3', name: '标签页自动切换到"公共请求头"' },
                              { id: '4', name: '内容区域显示公共请求头配置界面' },
                              { id: '5', name: '公共请求头标签显示正确的名称和图标' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleJumpToCommonHeader处理跳转逻辑(Banner.vue:228)' },
                              { id: '2', name: 'projectNavStore添加公共请求头nav项' },
                              { id: '3', name: '内容区域根据nav类型渲染对应组件' },
                            ],
                            notes: [
                              { id: '1', name: '公共请求头会应用到项目下所有HTTP请求' },
                              { id: '2', name: '每个项目可以独立配置公共请求头' },
                            ],
                          },
                          {
                            purpose: '鼠标右键空白区域,点击粘贴,可以粘贴节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '已执行过复制或剪切操作,pasteValue有数据' },
                              { id: '3', name: '已在空白区域右键打开菜单' },
                              { id: '4', name: '"粘贴"选项未置灰' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击右键菜单中的"粘贴"选项' },
                              { id: '2', name: '观察banner区域的节点变化' },
                            ],
                            expectedResults: [
                              { id: '1', name: '调用pasteNodes函数执行粘贴操作' },
                              { id: '2', name: '粘贴的节点出现在根节点列表中' },
                              { id: '3', name: '粘贴的节点生成新的_id' },
                              { id: '4', name: '粘贴节点的pid设置为空字符串' },
                              { id: '5', name: '离线模式下调用apiNodesCache.addNode保存数据' },
                              { id: '6', name: '在线模式下调用/api/project/paste_docs接口' },
                              { id: '7', name: '如果是剪切操作,原节点被删除' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handlePasteNode调用pasteNodes函数(Banner.vue:239)' },
                              { id: '2', name: 'pasteNodes函数处理节点复制和ID映射(curd-node.ts:285-422)' },
                              { id: '3', name: 'currentOperationalNode为null时粘贴到根级别' },
                            ],
                            notes: [
                              { id: '1', name: '粘贴操作支持同项目和跨项目' },
                              { id: '2', name: '跨项目粘贴会复制完整的节点数据' },
                            ],
                          },
                        ],
                      },
                      {
                        modelName: '鼠标右键folder节点',
                        description: '鼠标右键folder节点',
                        atomicFunc: [
                          {
                            purpose: '鼠标右键folder节点,出现新建接口,新建文件夹,设置公共请求头,剪切,复制,粘贴(可能置灰),重命名,删除等功能',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中存在至少一个folder节点' },
                              { id: '3', name: 'showContextmenu初始值为false' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域找到目标folder节点' },
                              { id: '2', name: '在该folder节点上点击鼠标右键' },
                              { id: '3', name: '观察弹出的右键菜单内容' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'showContextmenu变为true' },
                              { id: '2', name: 'currentOperationalNode设置为当前folder节点' },
                              { id: '3', name: '菜单中显示"新建接口"选项' },
                              { id: '4', name: '菜单中显示"新建文件夹"选项' },
                              { id: '5', name: '菜单中显示"设置公共请求头"选项' },
                              { id: '6', name: '菜单中显示"剪切"选项(快捷键Ctrl+X)' },
                              { id: '7', name: '菜单中显示"复制"选项(快捷键Ctrl+C)' },
                              { id: '8', name: '菜单中显示"粘贴"选项(若无剪贴板数据则置灰)' },
                              { id: '9', name: '菜单中显示"重命名"选项(快捷键F2)' },
                              { id: '10', name: '菜单中显示"删除"选项(快捷键Delete)' },
                              { id: '11', name: '不显示"生成副本"选项(仅非folder节点显示)' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleShowContextmenu处理节点右键事件(Banner.vue:23)' },
                              { id: '2', name: 'currentOperationalNode.type === "folder"时显示完整菜单(Banner.vue:223-244)' },
                              { id: '3', name: 'v-show控制菜单项的显示隐藏' },
                            ],
                            notes: [
                              { id: '1', name: 'folder节点支持所有节点操作加新建操作' },
                              { id: '2', name: '菜单项之间有分隔线区分功能组' },
                            ],
                          },
                          {
                            purpose: '鼠标右键folder节点,点击新建接口(httpNode,websocketNode,httpMockNode,websocketMockNode),成功后在当前folder内生成节点,并且生成的节点排在末尾',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '已在folder节点上右键打开菜单' },
                              { id: '3', name: 'currentOperationalNode为当前folder节点' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击右键菜单中的"新建接口"选项' },
                              { id: '2', name: '在弹出的对话框中选择节点类型' },
                              { id: '3', name: '输入接口名称' },
                              { id: '4', name: '点击确定按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'addFileDialogVisible变为true' },
                              { id: '2', name: 'SAddFileDialog的pid参数为当前folder的_id' },
                              { id: '3', name: '确认后新节点出现在当前folder内部' },
                              { id: '4', name: '新节点排在folder内所有节点末尾' },
                              { id: '5', name: '新节点的pid为当前folder的_id' },
                              { id: '6', name: 'folder自动展开显示新节点' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'SAddFileDialog接收pid为currentOperationalNode._id(Banner.vue:256-257)' },
                              { id: '2', name: 'handleAddFileAndFolderCb处理新节点添加到folder' },
                              { id: '3', name: 'bannerStore.changeExpandItems展开folder' },
                            ],
                            notes: [
                              { id: '1', name: '在folder上新建接口会自动设置正确的pid' },
                              { id: '2', name: '新节点排在folder内非folder节点的最后' },
                            ],
                          },
                          {
                            purpose: '鼠标右键folder节点,点击新建文件夹,成功后在当前folder内生成节点,生成的节点在当前节点最后一个folder节点下面',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '已在folder节点上右键打开菜单' },
                              { id: '3', name: 'currentOperationalNode为当前folder节点' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击右键菜单中的"新建文件夹"选项' },
                              { id: '2', name: '在弹出的对话框中输入文件夹名称' },
                              { id: '3', name: '点击确定按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'addFolderDialogVisible变为true' },
                              { id: '2', name: 'SAddFolderDialog的pid参数为当前folder的_id' },
                              { id: '3', name: '确认后新folder出现在当前folder内部' },
                              { id: '4', name: '新folder排在已有folder之后,非folder节点之前' },
                              { id: '5', name: '新folder的pid为当前folder的_id' },
                              { id: '6', name: '父folder自动展开显示新folder' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'SAddFolderDialog接收pid为currentOperationalNode._id(Banner.vue:258-259)' },
                              { id: '2', name: 'folder节点排序在非folder节点之前' },
                            ],
                            notes: [
                              { id: '1', name: '支持folder嵌套folder' },
                              { id: '2', name: '嵌套层级无限制' },
                            ],
                          },
                          {
                            purpose: '鼠标右键folder节点,点击设置公共请求头,导航区域增加公共请求头标签,标签文案正确,内容区域出现公共请求头设置内容',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '已在folder节点上右键打开菜单' },
                              { id: '3', name: 'currentOperationalNode为当前folder节点' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击右键菜单中的"设置公共请求头"选项' },
                              { id: '2', name: '观察导航区域和内容区域的变化' },
                            ],
                            expectedResults: [
                              { id: '1', name: '右键菜单关闭' },
                              { id: '2', name: '导航区域新增公共请求头标签页' },
                              { id: '3', name: '标签页显示当前folder名称相关的公共请求头' },
                              { id: '4', name: '内容区域显示该folder的公共请求头配置' },
                              { id: '5', name: '该配置仅对folder内的HTTP请求生效' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleJumpToCommonHeader处理跳转(Banner.vue:228)' },
                              { id: '2', name: 'folder级别的公共请求头与项目级别独立' },
                            ],
                            notes: [
                              { id: '1', name: 'folder级别公共请求头可覆盖项目级别设置' },
                              { id: '2', name: '支持层级继承的公共请求头机制' },
                            ],
                          },
                          {
                            purpose: '鼠标右键folder节点,点击剪切,被剪切节点样式发生改变,点击粘贴(空白区域,folder节点上),可以粘贴节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中存在至少一个folder节点' },
                              { id: '3', name: '已在folder节点上右键打开菜单' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击右键菜单中的"剪切"选项' },
                              { id: '2', name: '观察被剪切folder节点的样式变化' },
                              { id: '3', name: '在目标位置(空白区域或其他folder)右键点击"粘贴"' },
                              { id: '4', name: '观察粘贴后的结果' },
                            ],
                            expectedResults: [
                              { id: '1', name: '剪切后folder节点显示剪切样式(如半透明或虚线边框)' },
                              { id: '2', name: 'pasteValue设置为当前folder节点数据' },
                              { id: '3', name: 'cutNodes记录被剪切的节点' },
                              { id: '4', name: '粘贴后folder移动到目标位置' },
                              { id: '5', name: '原位置的folder节点被删除' },
                              { id: '6', name: 'folder内的所有子节点随之移动' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleCutNode设置剪切状态(Banner.vue:232)' },
                              { id: '2', name: 'cutNodes.value记录被剪切节点' },
                              { id: '3', name: '粘贴时调用deleteNode删除原节点(curd-node.ts:33-119)' },
                            ],
                            notes: [
                              { id: '1', name: '剪切操作是移动操作,原节点会被删除' },
                              { id: '2', name: 'folder剪切时包含所有子节点' },
                            ],
                          },
                          {
                            purpose: '鼠标右键folder节点,点击复制,点击粘贴(空白区域,folder节点上),可以粘贴节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中存在至少一个folder节点' },
                              { id: '3', name: '已在folder节点上右键打开菜单' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击右键菜单中的"复制"选项' },
                              { id: '2', name: '在目标位置(空白区域或其他folder)右键打开菜单' },
                              { id: '3', name: '点击"粘贴"选项' },
                              { id: '4', name: '观察粘贴后的结果' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'pasteValue设置为当前folder节点数据' },
                              { id: '2', name: '原folder节点保持不变(复制非剪切)' },
                              { id: '3', name: '粘贴后在目标位置生成folder副本' },
                              { id: '4', name: '副本folder拥有新的_id' },
                              { id: '5', name: '副本folder内所有子节点也生成新_id' },
                              { id: '6', name: '副本folder的pid设置为目标位置' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleCopyNode设置pasteValue(Banner.vue:234)' },
                              { id: '2', name: 'pasteNodes为所有节点生成新ID(curd-node.ts:330-340)' },
                              { id: '3', name: 'idMapping维护新旧ID映射关系' },
                            ],
                            notes: [
                              { id: '1', name: '复制操作不影响原节点' },
                              { id: '2', name: '可多次粘贴同一个复制的folder' },
                            ],
                          },
                          {
                            purpose: '鼠标右键folder节点,点击粘贴,可以按照逻辑(情况一:单个httpNode,websocketNode,httpMockNode,websocketMockNode.情况二:单个folder.情况三:多个非folder节点.情况四:多个纯folder节点.情况五:混合类型节点)粘贴节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '已执行过复制或剪切操作' },
                              { id: '3', name: '已在folder节点上右键打开菜单' },
                              { id: '4', name: '"粘贴"选项未置灰' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击右键菜单中的"粘贴"选项' },
                              { id: '2', name: '观察粘贴后folder内的节点变化' },
                            ],
                            expectedResults: [
                              { id: '1', name: '单个非folder节点:粘贴到folder末尾' },
                              { id: '2', name: '单个folder节点:粘贴到folder内folder区域末尾' },
                              { id: '3', name: '多个非folder节点:按原顺序粘贴到folder末尾' },
                              { id: '4', name: '多个folder节点:按原顺序粘贴到folder内folder区域' },
                              { id: '5', name: '混合类型节点:folder排前,非folder排后' },
                              { id: '6', name: '所有粘贴节点的pid设置为目标folder的_id' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'pasteNodes处理各种节点类型组合(curd-node.ts:285-422)' },
                              { id: '2', name: 'addFileAndFolderCb处理节点添加到正确位置' },
                              { id: '3', name: 'folder内节点排序规则:folder在前,非folder在后' },
                            ],
                            notes: [
                              { id: '1', name: '粘贴保持原有的层级结构' },
                              { id: '2', name: '混合粘贴时自动调整排序' },
                            ],
                          },
                          {
                            purpose: '鼠标右键folder节点,点击重命名(或f2),可以正常重命名',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中存在至少一个folder节点' },
                              { id: '3', name: 'folder节点非只读(readonly !== true)' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在folder节点上右键打开菜单' },
                              { id: '2', name: '点击"重命名"选项(或直接按F2快捷键)' },
                              { id: '3', name: '在输入框中修改folder名称' },
                              { id: '4', name: '按Enter键或点击其他区域确认' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'editNode设置为当前folder节点' },
                              { id: '2', name: 'folder节点进入编辑状态,显示输入框' },
                              { id: '3', name: 'enableDrag设置为false禁止拖拽' },
                              { id: '4', name: '输入框自动获取焦点' },
                              { id: '5', name: '确认后folder名称更新' },
                              { id: '6', name: '离线模式调用apiNodesCache.updateNodeName' },
                              { id: '7', name: '在线模式调用相应API更新名称' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleRenameNode触发重命名(Banner.vue:241-242)' },
                              { id: '2', name: 'renameNode函数处理重命名逻辑(curd-node.ts:655-738)' },
                              { id: '3', name: 'handleChangeNodeName处理确认事件(Banner.vue:613-617)' },
                            ],
                            notes: [
                              { id: '1', name: '空名称不允许保存' },
                              { id: '2', name: '重命名期间禁止拖拽操作' },
                            ],
                          },
                          {
                            purpose: '鼠标右键folder节点,点击删除(或delete),可以正常删除目录',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中存在至少一个folder节点' },
                              { id: '3', name: '已在folder节点上右键打开菜单' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击右键菜单中的"删除"选项(或直接按Delete快捷键)' },
                              { id: '2', name: '在弹出的确认对话框中点击"确定"' },
                              { id: '3', name: '观察folder节点的删除结果' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'ElMessageBox弹出删除确认对话框' },
                              { id: '2', name: '对话框显示删除提示信息' },
                              { id: '3', name: '确认后folder节点从banner中移除' },
                              { id: '4', name: 'folder内所有子节点同时被删除' },
                              { id: '5', name: '相关的nav标签页被关闭' },
                              { id: '6', name: '离线模式调用apiNodesCache.deleteNodes' },
                              { id: '7', name: '在线模式调用/api/project/doc DELETE接口' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleDeleteNodes调用deleteNode(Banner.vue:243)' },
                              { id: '2', name: 'deleteNode收集所有子节点ID(curd-node.ts:40-48)' },
                              { id: '3', name: 'projectNavStore.deleteNavByIds关闭相关标签(curd-node.ts:101-106)' },
                            ],
                            notes: [
                              { id: '1', name: '删除folder会级联删除所有子节点' },
                              { id: '2', name: '删除操作不可撤销' },
                            ],
                          },
                        ],
                      },
                      {
                        modelName: '鼠标右键非folder节点',
                        description: '鼠标右键非folder节点',
                        atomicFunc: [
                          {
                            purpose: '鼠标右键非folder节点,出现剪切,复制,生成副本,重命名,删除等功能',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中存在至少一个非folder节点(http/websocket/mock等)' },
                              { id: '3', name: 'showContextmenu初始值为false' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在banner区域找到目标非folder节点' },
                              { id: '2', name: '在该节点上点击鼠标右键' },
                              { id: '3', name: '观察弹出的右键菜单内容' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'showContextmenu变为true' },
                              { id: '2', name: 'currentOperationalNode设置为当前节点' },
                              { id: '3', name: '菜单中显示"剪切"选项(快捷键Ctrl+X)' },
                              { id: '4', name: '菜单中显示"复制"选项(快捷键Ctrl+C)' },
                              { id: '5', name: '菜单中显示"生成副本"选项' },
                              { id: '6', name: '菜单中显示"重命名"选项(快捷键F2)' },
                              { id: '7', name: '菜单中显示"删除"选项(快捷键Delete)' },
                              { id: '8', name: '不显示"新建接口","新建文件夹","粘贴"等选项' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleShowContextmenu处理节点右键事件' },
                              { id: '2', name: 'currentOperationalNode.type !== "folder"时隐藏新建菜单项(Banner.vue:223-228)' },
                              { id: '3', name: '"生成副本"仅对非folder节点显示(Banner.vue:236-237)' },
                            ],
                            notes: [
                              { id: '1', name: '非folder节点不能包含子节点' },
                              { id: '2', name: '非folder节点有"生成副本"特有功能' },
                            ],
                          },
                          {
                            purpose: '鼠标右键非folder节点,点击剪切,被剪切节点样式发生改变,点击粘贴(空白区域,folder节点上),可以粘贴节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中存在至少一个非folder节点' },
                              { id: '3', name: '已在非folder节点上右键打开菜单' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击右键菜单中的"剪切"选项' },
                              { id: '2', name: '观察被剪切节点的样式变化' },
                              { id: '3', name: '在目标位置(空白区域或folder)右键点击"粘贴"' },
                              { id: '4', name: '观察粘贴后的结果' },
                            ],
                            expectedResults: [
                              { id: '1', name: '剪切后节点显示剪切样式(如半透明)' },
                              { id: '2', name: 'pasteValue设置为当前节点数据' },
                              { id: '3', name: 'cutNodes记录被剪切的节点' },
                              { id: '4', name: '粘贴后节点移动到目标位置' },
                              { id: '5', name: '原位置的节点被删除' },
                              { id: '6', name: '节点的pid更新为目标位置' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleCutNode设置剪切状态' },
                              { id: '2', name: '剪切样式通过CSS类控制' },
                              { id: '3', name: '粘贴后调用deleteNode删除原节点' },
                            ],
                            notes: [
                              { id: '1', name: '剪切是移动操作' },
                              { id: '2', name: '剪切后再次复制/剪切会覆盖之前的剪贴板' },
                            ],
                          },
                          {
                            purpose: '鼠标右键非folder节点,点击复制,点击粘贴(空白区域,folder节点上),可以粘贴节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中存在至少一个非folder节点' },
                              { id: '3', name: '已在非folder节点上右键打开菜单' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击右键菜单中的"复制"选项' },
                              { id: '2', name: '在目标位置(空白区域或folder)右键打开菜单' },
                              { id: '3', name: '点击"粘贴"选项' },
                              { id: '4', name: '观察粘贴后的结果' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'pasteValue设置为当前节点数据' },
                              { id: '2', name: '原节点保持不变' },
                              { id: '3', name: '粘贴后在目标位置生成节点副本' },
                              { id: '4', name: '副本拥有新的_id' },
                              { id: '5', name: '副本的pid设置为目标位置' },
                              { id: '6', name: '副本包含原节点的所有配置数据' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleCopyNode设置pasteValue' },
                              { id: '2', name: 'pasteNodes为节点生成新ID' },
                              { id: '3', name: '复制包含完整的节点数据(请求配置,响应等)' },
                            ],
                            notes: [
                              { id: '1', name: '复制不影响原节点' },
                              { id: '2', name: '可多次粘贴同一复制内容' },
                            ],
                          },
                          {
                            purpose: '鼠标右键非folder节点,点击生成副本,可以在当前节点后面生成副本节点',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中存在至少一个非folder节点' },
                              { id: '3', name: '已在非folder节点上右键打开菜单' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击右键菜单中的"生成副本"选项' },
                              { id: '2', name: '观察banner区域的节点变化' },
                            ],
                            expectedResults: [
                              { id: '1', name: '调用forkNode函数生成副本' },
                              { id: '2', name: '副本节点出现在原节点后面' },
                              { id: '3', name: '副本拥有新的_id' },
                              { id: '4', name: '副本的pid与原节点相同' },
                              { id: '5', name: '副本的sort值在原节点和下一节点之间' },
                              { id: '6', name: '副本包含原节点的所有配置数据' },
                              { id: '7', name: '离线模式调用apiNodesCache.addNode保存' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleForkNode调用forkNode(Banner.vue:237)' },
                              { id: '2', name: 'forkNode计算newSort = (currentSort + nextSiblingSort) / 2(curd-node.ts:449-450)' },
                              { id: '3', name: 'bannerStore.splice在正确位置插入副本(curd-node.ts:465-475)' },
                            ],
                            notes: [
                              { id: '1', name: '生成副本是快速复制的便捷方式' },
                              { id: '2', name: '副本直接出现在原节点后面无需选择位置' },
                            ],
                          },
                          {
                            purpose: '鼠标右键非folder节点,点击重命名(或f2),可以正常重命名',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中存在至少一个非folder节点' },
                              { id: '3', name: '节点非只读(readonly !== true)' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在非folder节点上右键打开菜单' },
                              { id: '2', name: '点击"重命名"选项(或直接按F2快捷键)' },
                              { id: '3', name: '在输入框中修改节点名称' },
                              { id: '4', name: '按Enter键或点击其他区域确认' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'editNode设置为当前节点' },
                              { id: '2', name: '节点进入编辑状态,显示输入框' },
                              { id: '3', name: 'enableDrag设置为false禁止拖拽' },
                              { id: '4', name: '输入框自动获取焦点' },
                              { id: '5', name: '确认后节点名称更新' },
                              { id: '6', name: 'projectNavStore.changeNavInfoById同步更新标签名称' },
                              { id: '7', name: 'httpNodeStore.changeHttpNodeName同步更新详情名称' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'handleRenameNode触发重命名' },
                              { id: '2', name: 'renameNode同时更新banner,nav,httpNode三处名称(curd-node.ts:667-674)' },
                              { id: '3', name: 'handleWatchNodeInput验证输入不为空(Banner.vue:619-626)' },
                            ],
                            notes: [
                              { id: '1', name: '名称同时在多个地方显示需同步更新' },
                              { id: '2', name: '空名称会显示错误样式' },
                            ],
                          },
                          {
                            purpose: '鼠标右键非folder节点,点击删除(或delete),可以正常删除目录',
                            precondition: [
                              { id: '1', name: '已登录并打开任意项目工作区' },
                              { id: '2', name: '项目中存在至少一个非folder节点' },
                              { id: '3', name: '已在非folder节点上右键打开菜单' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击右键菜单中的"删除"选项(或直接按Delete快捷键)' },
                              { id: '2', name: '在弹出的确认对话框中点击"确定"' },
                              { id: '3', name: '观察节点的删除结果' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'ElMessageBox弹出删除确认对话框' },
                              { id: '2', name: '对话框显示"确定删除 xxx 节点"' },
                              { id: '3', name: '确认后节点从banner中移除' },
                              { id: '4', name: '相关的nav标签页被关闭' },
                              { id: '5', name: '离线模式调用apiNodesCache.deleteNodes' },
                              { id: '6', name: '在线模式调用/api/project/doc DELETE接口' },
                              { id: '7', name: '触发apidoc/deleteDocs事件' },
                            ],
                            checkpoints: [
                              { id: '1', name: 'deleteNode函数处理删除逻辑(curd-node.ts:33-119)' },
                              { id: '2', name: 'ElMessageBox.confirm显示确认对话框(curd-node.ts:112-118)' },
                              { id: '3', name: 'eventEmitter.emit触发删除事件(curd-node.ts:108)' },
                            ],
                            notes: [
                              { id: '1', name: '删除操作需要用户确认' },
                              { id: '2', name: '删除后数据不可恢复' },
                            ],
                          },
                        ],
                      },
                    ],
                  },
                  //其他
                  {
                    modelName: '节点树其他情况',
                    description: '节点树其他情况',
                    atomicFunc: [
                      {
                        purpose: '在根节点新增,粘贴非folder节点,会排序在末尾',
                        precondition: [
                          { id: '1', name: '已登录并打开任意项目工作区' },
                          { id: '2', name: '根节点下已存在若干节点(folder和非folder混合)' },
                          { id: '3', name: '执行新增或粘贴非folder节点操作' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在空白区域右键打开菜单' },
                          { id: '2', name: '点击"新建接口"或"粘贴"选项' },
                          { id: '3', name: '完成新增或粘贴操作' },
                          { id: '4', name: '观察新节点在banner中的位置' },
                        ],
                        expectedResults: [
                          { id: '1', name: '新节点出现在根节点列表的末尾' },
                          { id: '2', name: '新节点排在所有已有非folder节点之后' },
                          { id: '3', name: '新节点的pid为空字符串' },
                          { id: '4', name: '新节点的sort值为Date.now()确保排在末尾' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'addFileAndFolderCb对非folder节点使用bannerStore.banner.length作为插入位置(curd-node.ts:183-188)' },
                          { id: '2', name: 'currentOperationalNode为null时操作根节点' },
                        ],
                        notes: [
                          { id: '1', name: '非folder节点始终排在folder节点之后' },
                          { id: '2', name: '新节点自动成为选中状态并打开编辑' },
                        ],
                      },
                      {
                        purpose: '在根节点新增,粘贴folder节点,会排序到根目录下最后一个目录节点下面',
                        precondition: [
                          { id: '1', name: '已登录并打开任意项目工作区' },
                          { id: '2', name: '根节点下已存在若干folder节点和非folder节点' },
                          { id: '3', name: '执行新增或粘贴folder节点操作' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在空白区域右键打开菜单' },
                          { id: '2', name: '点击"新建文件夹"或粘贴folder节点' },
                          { id: '3', name: '完成新增或粘贴操作' },
                          { id: '4', name: '观察新folder节点在banner中的位置' },
                        ],
                        expectedResults: [
                          { id: '1', name: '新folder出现在已有folder之后' },
                          { id: '2', name: '新folder排在所有非folder节点之前' },
                          { id: '3', name: '新folder的pid为空字符串' },
                          { id: '4', name: 'folder区域和非folder区域保持分离' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'addFileAndFolderCb使用findIndex找到第一个非folder节点位置(curd-node.ts:170-180)' },
                          { id: '2', name: 'lastFolderIndex确定folder区域的边界' },
                          { id: '3', name: 'bannerStore.splice在正确位置插入folder' },
                        ],
                        notes: [
                          { id: '1', name: 'folder始终排在非folder之前是固定规则' },
                          { id: '2', name: '如果没有非folder节点,folder插入到末尾' },
                        ],
                      },
                      {
                        purpose: '在根节点粘贴包含folder节点的混合节点,folder节点会排序到根目录下最后一个目录节点下面,非folder节点会排序在末尾',
                        precondition: [
                          { id: '1', name: '已登录并打开任意项目工作区' },
                          { id: '2', name: '剪贴板中有包含folder和非folder的混合节点' },
                          { id: '3', name: '根节点下已存在若干节点' },
                        ],
                        operationSteps: [
                          { id: '1', name: '复制或剪切包含folder和非folder的多个节点' },
                          { id: '2', name: '在空白区域右键打开菜单' },
                          { id: '3', name: '点击"粘贴"选项' },
                          { id: '4', name: '观察各类型节点的最终位置' },
                        ],
                        expectedResults: [
                          { id: '1', name: 'folder节点插入到folder区域末尾' },
                          { id: '2', name: '非folder节点插入到非folder区域末尾' },
                          { id: '3', name: 'folder区域和非folder区域保持分离' },
                          { id: '4', name: '各类型节点保持原有的相对顺序' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'pasteNodes遍历copyPasteNodes分别处理(curd-node.ts:384-386)' },
                          { id: '2', name: 'addFileAndFolderCb根据data.type决定插入位置' },
                        ],
                        notes: [
                          { id: '1', name: '混合粘贴会自动按类型分组排序' },
                          { id: '2', name: '这是系统自动行为,用户无需手动调整' },
                        ],
                      },
                    ],
                  },
                ],
              },
              {
                modelName: '调用历史区域',
                description: '调用历史区域',
              },
            ],
          },
          {
            modelName: 'banner区域其他功能',
            description: 'banner区域其他功能',
            atomicFunc: [
              {
                purpose: '可左右拖拽banner,需要判断最大和最小宽度,双击需要还原为默认样式',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: 'banner区域已正常加载显示' },
                  { id: '3', name: 'SResizeX组件正常渲染' },
                ],
                operationSteps: [
                  { id: '1', name: '将鼠标移动到banner右侧边缘的拖拽条上' },
                  { id: '2', name: '鼠标左键按下开始拖拽' },
                  { id: '3', name: '向左或向右移动鼠标' },
                  { id: '4', name: '观察banner宽度变化和最大最小限制' },
                  { id: '5', name: '释放鼠标后,双击拖拽条' },
                ],
                expectedResults: [
                  { id: '1', name: '拖拽时显示实时宽度指示器' },
                  { id: '2', name: 'banner宽度随鼠标移动而变化' },
                  { id: '3', name: '宽度不会小于最小值(min属性)' },
                  { id: '4', name: '宽度不会大于最大值(max属性)' },
                  { id: '5', name: '拖拽过程中isDragging为true,禁用文本选择' },
                  { id: '6', name: '释放后宽度保存到localStorage' },
                  { id: '7', name: '双击后宽度还原为默认值' },
                ],
                checkpoints: [
                  { id: '1', name: 'SResizeX组件的handleResizeMousedown处理拖拽开始(ClResizeX.vue:88-93)' },
                  { id: '2', name: 'handleResizeMousemove判断min/max边界(ClResizeX.vue:67-71)' },
                  { id: '3', name: 'handleResetWidth处理双击还原(ClResizeX.vue:8)' },
                  { id: '4', name: 'localStorage保存宽度到dragBar/name键' },
                ],
                notes: [
                  { id: '1', name: '拖拽时显示"双击还原"提示' },
                  { id: '2', name: '宽度记忆功能可通过remember属性控制' },
                ],
              },
              {
                purpose: 'httpMockNode启动后,banner节点需要有呼吸小圆点效果',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '项目中存在至少一个httpMockNode节点' },
                  { id: '3', name: 'httpMockNode已配置Mock规则' },
                ],
                operationSteps: [
                  { id: '1', name: '在httpMockNode详情页点击启动Mock服务' },
                  { id: '2', name: '观察banner区域对应节点的变化' },
                  { id: '3', name: '停止Mock服务' },
                  { id: '4', name: '再次观察banner区域节点的变化' },
                ],
                expectedResults: [
                  { id: '1', name: '启动后节点显示呼吸动画小圆点' },
                  { id: '2', name: '小圆点颜色为绿色表示运行中' },
                  { id: '3', name: '呼吸动画使用CSS animation实现' },
                  { id: '4', name: '停止后小圆点消失或变为灰色' },
                  { id: '5', name: '包含运行中Mock的folder也显示指示器' },
                ],
                checkpoints: [
                  { id: '1', name: 'Banner.vue模板中mock状态指示器渲染逻辑' },
                  { id: '2', name: 'foldersWithRunningMock计算包含运行中Mock的folder' },
                  { id: '3', name: 'state字段表示Mock运行状态(running/starting/stopping/error)' },
                ],
                notes: [
                  { id: '1', name: '呼吸动画提示用户Mock正在运行' },
                  { id: '2', name: '父folder也会显示指示器便于快速定位' },
                ],
              },
            ],
          },
        ],
      },
      // 顶部导航
      {
        modelName: 'nav',
        description: '工作区导航',
        children: [
          //项目工作区导航基本样式
          {
            modelName: '项目工作区导航基本样式',
            description: '项目工作区导航基本样式',
            children: [
              {
                purpose: '正确显示httpNode节点不同请求方法样式',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '项目中存在不同请求方法的httpNode节点' },
                  { id: '3', name: '导航栏已正常加载' },
                ],
                operationSteps: [
                  { id: '1', name: '分别双击GET,POST,PUT,DELETE等不同请求方法的httpNode节点' },
                  { id: '2', name: '观察导航标签页的样式显示' },
                ],
                expectedResults: [
                  { id: '1', name: 'GET方法标签显示绿色图标' },
                  { id: '2', name: 'POST方法标签显示橙色图标' },
                  { id: '3', name: 'PUT方法标签显示蓝色图标' },
                  { id: '4', name: 'DELETE方法标签显示红色图标' },
                  { id: '5', name: '其他方法使用对应的预设颜色' },
                  { id: '6', name: '图标使用requestMethods中的配置' },
                ],
                checkpoints: [
                  { id: '1', name: 'requestMethods数据定义各方法的颜色(data/data.ts)' },
                  { id: '2', name: 'nav标签的head.icon存储请求方法' },
                  { id: '3', name: 'head.color或通过方法名映射颜色' },
                ],
                notes: [
                  { id: '1', name: '颜色区分便于快速识别请求类型' },
                  { id: '2', name: '遵循REST API的常见颜色约定' },
                ],
              },
              {
                purpose: '正确显示websocketNode,httpMockNode,websocketMockNode节点样式',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '项目中存在websocketNode,httpMockNode,websocketMockNode节点' },
                  { id: '3', name: '导航栏已正常加载' },
                ],
                operationSteps: [
                  { id: '1', name: '分别双击websocketNode,httpMockNode,websocketMockNode节点' },
                  { id: '2', name: '观察导航标签页的样式显示' },
                ],
                expectedResults: [
                  { id: '1', name: 'websocketNode标签显示ws/wss协议图标' },
                  { id: '2', name: 'httpMockNode标签显示mock文字图标' },
                  { id: '3', name: 'websocketMockNode标签显示websocketMock图标' },
                  { id: '4', name: '各类型节点图标样式清晰可区分' },
                ],
                checkpoints: [
                  { id: '1', name: 'addFileAndFolderCb为不同tabType设置不同head.icon(curd-node.ts:219-264)' },
                  { id: '2', name: 'websocket使用protocol(ws/wss)作为图标' },
                  { id: '3', name: 'httpMock使用"mock"作为图标' },
                  { id: '4', name: 'websocketMock使用"websocketMock"作为图标' },
                ],
                notes: [
                  { id: '1', name: '图标类型与节点类型一一对应' },
                  { id: '2', name: '可通过图标快速识别标签类型' },
                ],
              },
              {
                purpose: '正确显示变量tab,导入tab,导出tab,回收站tab,Cookie tab,公共请求头tab',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '导航栏已正常加载' },
                ],
                operationSteps: [
                  { id: '1', name: '分别打开变量,导入,导出,回收站,Cookie,公共请求头功能' },
                  { id: '2', name: '观察导航标签页的样式显示' },
                ],
                expectedResults: [
                  { id: '1', name: '变量tab显示变量专用图标' },
                  { id: '2', name: '导入tab显示导入专用图标' },
                  { id: '3', name: '导出tab显示导出专用图标' },
                  { id: '4', name: '回收站tab显示回收站专用图标' },
                  { id: '5', name: 'Cookie tab显示Cookie专用图标' },
                  { id: '6', name: '公共请求头tab显示请求头专用图标' },
                ],
                checkpoints: [
                  { id: '1', name: 'projectNavStore.addNav设置正确的tabType' },
                  { id: '2', name: '各特殊tab类型有对应的图标配置' },
                ],
                notes: [
                  { id: '1', name: '特殊功能tab使用固定图标' },
                  { id: '2', name: '图标风格与整体UI保持一致' },
                ],
              },
              {
                purpose: 'Tab标签超过50字符应显示省略号并有title提示',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '存在名称超过50字符的节点' },
                  { id: '3', name: '导航栏已正常加载' },
                ],
                operationSteps: [
                  { id: '1', name: '创建或重命名节点,名称超过50个字符' },
                  { id: '2', name: '双击该节点打开在导航栏' },
                  { id: '3', name: '观察标签的显示样式' },
                  { id: '4', name: '将鼠标悬停在标签上' },
                ],
                expectedResults: [
                  { id: '1', name: '标签文字显示省略号(...)' },
                  { id: '2', name: '标签宽度不超过预设最大值' },
                  { id: '3', name: '鼠标悬停时显示完整名称的title提示' },
                  { id: '4', name: '省略号样式使用CSS text-overflow: ellipsis' },
                ],
                checkpoints: [
                  { id: '1', name: 'nav标签组件设置max-width和text-overflow样式' },
                  { id: '2', name: 'title属性设置为完整的label值' },
                ],
                notes: [
                  { id: '1', name: '避免过长名称撑开导航栏' },
                  { id: '2', name: 'title提示确保用户可查看完整名称' },
                ],
              },
              {
                purpose: 'httpNode,websocketNode,httpMockNode,websocketMockNode节点,内容发生改变后,tab页签会出现未保存小圆点,保存后去掉小圆点',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '已打开任意类型的节点(http/websocket/mock)' },
                  { id: '3', name: '当前节点处于已保存状态' },
                ],
                operationSteps: [
                  { id: '1', name: '修改节点的任意配置(如URL,参数,请求头等)' },
                  { id: '2', name: '观察导航标签的变化' },
                  { id: '3', name: '按Ctrl+S或点击保存按钮保存' },
                  { id: '4', name: '再次观察导航标签的变化' },
                ],
                expectedResults: [
                  { id: '1', name: '修改后标签上出现未保存小圆点(如红色圆点)' },
                  { id: '2', name: 'nav对象的saved字段变为false' },
                  { id: '3', name: '保存后小圆点消失' },
                  { id: '4', name: 'nav对象的saved字段变为true' },
                  { id: '5', name: '关闭未保存标签时提示是否保存' },
                ],
                checkpoints: [
                  { id: '1', name: 'projectNavStore管理saved状态' },
                  { id: '2', name: '内容变化时调用changeNavInfoById更新saved' },
                  { id: '3', name: '保存成功后将saved设为true' },
                ],
                notes: [
                  { id: '1', name: '未保存标识防止用户意外丢失修改' },
                  { id: '2', name: '与常见IDE的未保存提示行为一致' },
                ],
              },
            ],
          },
          //banner与项目工作区导航交互
          {
            modelName: 'banner与项目工作区导航交互',
            description: 'banner与项目工作区导航交互',
            atomicFunc: [
              {
                purpose: '单击左侧非folder类型节点,右侧导航栏会新增一个tab页签,并且页签为非固定状态,页签中字体为斜体',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '项目中存在非folder类型节点(http/websocket/mock)' },
                  { id: '3', name: '导航栏已正常加载' },
                ],
                operationSteps: [
                  { id: '1', name: '在banner区域找到任意非folder节点' },
                  { id: '2', name: '单击该节点(非双击)' },
                  { id: '3', name: '观察导航栏的变化' },
                ],
                expectedResults: [
                  { id: '1', name: '导航栏新增一个tab页签' },
                  { id: '2', name: 'tab页签的fixed属性为false(非固定状态)' },
                  { id: '3', name: '页签文字显示为斜体样式' },
                  { id: '4', name: '页签处于选中状态(selected: true)' },
                  { id: '5', name: '内容区域显示对应节点的编辑界面' },
                ],
                checkpoints: [
                  { id: '1', name: 'banner节点单击事件触发addNav' },
                  { id: '2', name: 'addNav设置fixed: false表示非固定' },
                  { id: '3', name: 'CSS样式通过fixed属性控制font-style: italic' },
                ],
                notes: [
                  { id: '1', name: '非固定页签可被后续单击覆盖' },
                  { id: '2', name: '斜体样式提示用户该页签为预览状态' },
                ],
              },
              {
                purpose: '双击左侧非folder类型节点,右侧导航栏会新增一个tab页签,并且页签为固定状态,页签中字体正常展示',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '项目中存在非folder类型节点' },
                  { id: '3', name: '导航栏已正常加载' },
                ],
                operationSteps: [
                  { id: '1', name: '在banner区域找到任意非folder节点' },
                  { id: '2', name: '双击该节点' },
                  { id: '3', name: '观察导航栏的变化' },
                ],
                expectedResults: [
                  { id: '1', name: '导航栏新增一个tab页签' },
                  { id: '2', name: 'tab页签的fixed属性为true(固定状态)' },
                  { id: '3', name: '页签文字显示为正常样式(非斜体)' },
                  { id: '4', name: '页签处于选中状态' },
                  { id: '5', name: '固定页签不会被单击其他节点覆盖' },
                ],
                checkpoints: [
                  { id: '1', name: 'banner节点双击事件触发addNav' },
                  { id: '2', name: 'addNav设置fixed: true表示固定' },
                  { id: '3', name: 'CSS样式通过fixed属性控制正常字体' },
                ],
                notes: [
                  { id: '1', name: '双击直接打开为固定页签' },
                  { id: '2', name: '固定页签需要手动关闭' },
                ],
              },
              {
                purpose: '单击左侧folder类型节点,右侧导航栏不会新增一个tab页签',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '项目中存在folder类型节点' },
                  { id: '3', name: '导航栏已正常加载' },
                ],
                operationSteps: [
                  { id: '1', name: '在banner区域找到任意folder节点' },
                  { id: '2', name: '单击该folder节点' },
                  { id: '3', name: '观察导航栏的变化' },
                ],
                expectedResults: [
                  { id: '1', name: '导航栏不新增任何tab页签' },
                  { id: '2', name: 'folder节点展开或折叠状态切换' },
                  { id: '3', name: '当前选中的页签保持不变' },
                  { id: '4', name: '内容区域保持原有内容' },
                ],
                checkpoints: [
                  { id: '1', name: 'folder节点点击事件只处理展开/折叠' },
                  { id: '2', name: 'addNav不会为folder类型调用' },
                ],
                notes: [
                  { id: '1', name: 'folder只作为容器节点,没有编辑内容' },
                  { id: '2', name: '单击folder展开/折叠其子节点' },
                ],
              },
              {
                purpose: '单击左侧非folder类型节点A,再点击左侧folder类型节点B,节点B的tab会覆盖节点A的tab',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '项目中存在多个非folder类型节点' },
                  { id: '3', name: '当前无选中页签或有非固定页签' },
                ],
                operationSteps: [
                  { id: '1', name: '单击非folder节点A,产生非固定页签A' },
                  { id: '2', name: '单击另一个非folder节点B' },
                  { id: '3', name: '观察导航栏页签的变化' },
                ],
                expectedResults: [
                  { id: '1', name: '页签A被页签B替换覆盖' },
                  { id: '2', name: '导航栏页签总数不变' },
                  { id: '3', name: '页签B仍为非固定状态(斜体)' },
                  { id: '4', name: '内容区域显示节点B的内容' },
                ],
                checkpoints: [
                  { id: '1', name: '单击替换逻辑:找到非固定页签并覆盖' },
                  { id: '2', name: 'projectNavStore处理页签替换' },
                ],
                notes: [
                  { id: '1', name: '单击预览模式避免打开过多页签' },
                  { id: '2', name: '类似VS Code的预览模式行为' },
                ],
              },
              {
                purpose: 'tab页签存在固定页签和非固定页签,当前选中页签可以是固定也可以是非固定的,单击左侧非folder类型节点,会选中并覆盖未固定页签,并且也是未固定的',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '导航栏存在固定页签和非固定页签' },
                  { id: '3', name: '当前选中的可能是固定或非固定页签' },
                ],
                operationSteps: [
                  { id: '1', name: '确保导航栏有固定页签和非固定页签' },
                  { id: '2', name: '单击左侧任意非folder节点' },
                  { id: '3', name: '观察导航栏页签变化' },
                ],
                expectedResults: [
                  { id: '1', name: '非固定页签被新节点覆盖' },
                  { id: '2', name: '固定页签保持不变' },
                  { id: '3', name: '新页签仍为非固定状态' },
                  { id: '4', name: '新页签成为选中状态' },
                ],
                checkpoints: [
                  { id: '1', name: '单击逻辑只覆盖fixed: false的页签' },
                  { id: '2', name: 'fixed: true的页签受保护不被覆盖' },
                ],
                notes: [
                  { id: '1', name: '固定页签用于用户主动打开的重要内容' },
                  { id: '2', name: '非固定页签用于快速预览' },
                ],
              },
              {
                purpose: 'tab页签存在固定页签和非固定页签,当前选中页签可以是固定也可以是非固定的,双击左侧非folder类型节点,会选中并覆盖未固定页签,并且是固定的',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '导航栏存在非固定页签' },
                  { id: '3', name: '项目中存在非folder节点' },
                ],
                operationSteps: [
                  { id: '1', name: '确保导航栏有非固定页签' },
                  { id: '2', name: '双击左侧任意非folder节点' },
                  { id: '3', name: '观察导航栏页签变化' },
                ],
                expectedResults: [
                  { id: '1', name: '非固定页签被新节点覆盖' },
                  { id: '2', name: '新页签变为固定状态' },
                  { id: '3', name: '页签文字变为正常样式(非斜体)' },
                  { id: '4', name: '新页签成为选中状态' },
                ],
                checkpoints: [
                  { id: '1', name: '双击设置fixed: true' },
                  { id: '2', name: '覆盖非固定页签后设为固定' },
                ],
                notes: [
                  { id: '1', name: '双击表示用户确定要打开该节点' },
                  { id: '2', name: '固定页签防止意外覆盖' },
                ],
              },
              {
                purpose: 'banner新增一个节点会在右侧导航栏新增一个tab页签,页签位置在当前激活页签右侧',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '导航栏已有若干页签' },
                  { id: '3', name: '当前有选中的激活页签' },
                ],
                operationSteps: [
                  { id: '1', name: '通过右键菜单或工具栏新增一个节点' },
                  { id: '2', name: '观察导航栏页签的位置变化' },
                ],
                expectedResults: [
                  { id: '1', name: '新页签出现在当前激活页签的右侧' },
                  { id: '2', name: '新页签成为选中状态' },
                  { id: '3', name: '新页签为固定状态(新建即固定)' },
                  { id: '4', name: '其他页签位置相应右移' },
                ],
                checkpoints: [
                  { id: '1', name: 'addFileAndFolderCb调用addNav(curd-node.ts:210-264)' },
                  { id: '2', name: 'addNav在当前选中页签后插入' },
                ],
                notes: [
                  { id: '1', name: '新建节点自动打开编辑' },
                  { id: '2', name: '插入位置便于用户管理相关页签' },
                ],
              },
              {
                purpose: '删除banner节点,右侧导航栏删除对应tab页签',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: 'banner中存在节点且对应页签已打开' },
                ],
                operationSteps: [
                  { id: '1', name: '在banner中删除一个节点' },
                  { id: '2', name: '观察导航栏页签的变化' },
                ],
                expectedResults: [
                  { id: '1', name: '对应的tab页签被自动关闭' },
                  { id: '2', name: '如果删除的是当前选中页签,选中下一个页签' },
                  { id: '3', name: 'folder删除时其所有子节点的页签也被关闭' },
                ],
                checkpoints: [
                  { id: '1', name: 'deleteNode调用projectNavStore.deleteNavByIds(curd-node.ts:101-106)' },
                  { id: '2', name: 'forEachForest收集所有需删除的节点ID' },
                ],
                notes: [
                  { id: '1', name: '删除节点自动清理相关页签' },
                  { id: '2', name: '防止出现无效的孤立页签' },
                ],
              },
              {
                purpose: '重命名banner节点,右侧导航栏对应tab页签字体更新',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: 'banner中存在节点且对应页签已打开' },
                ],
                operationSteps: [
                  { id: '1', name: '在banner中重命名一个节点' },
                  { id: '2', name: '观察导航栏页签的变化' },
                ],
                expectedResults: [
                  { id: '1', name: '对应的tab页签名称同步更新' },
                  { id: '2', name: '页签的label字段更新为新名称' },
                  { id: '3', name: '页签的title提示也同步更新' },
                ],
                checkpoints: [
                  { id: '1', name: 'renameNode调用projectNavStore.changeNavInfoById(curd-node.ts:669-673)' },
                  { id: '2', name: 'changeNavInfoById更新label字段' },
                ],
                notes: [
                  { id: '1', name: '名称同步确保banner和nav一致' },
                  { id: '2', name: '用户可通过页签识别对应节点' },
                ],
              },
              {
                purpose: '点击tab页签,左侧banner节点高亮,若无节点相关tab页签被选中,则取消banner高亮',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '导航栏存在多个页签' },
                  { id: '3', name: 'banner中对应节点可见' },
                ],
                operationSteps: [
                  { id: '1', name: '点击导航栏中的某个节点类型页签' },
                  { id: '2', name: '观察banner中对应节点的高亮状态' },
                  { id: '3', name: '点击特殊功能页签(如变量,Cookie)' },
                  { id: '4', name: '观察banner节点的高亮状态' },
                ],
                expectedResults: [
                  { id: '1', name: '点击节点页签后,banner对应节点高亮' },
                  { id: '2', name: 'banner自动滚动使节点可见(如果需要)' },
                  { id: '3', name: '点击特殊功能页签后,banner取消所有节点高亮' },
                  { id: '4', name: 'el-tree的current-node-key同步更新' },
                ],
                checkpoints: [
                  { id: '1', name: 'activeNode computed根据选中页签计算' },
                  { id: '2', name: 'el-tree的highlight-current属性控制高亮' },
                ],
                notes: [
                  { id: '1', name: 'banner与nav双向联动' },
                  { id: '2', name: '高亮帮助用户定位当前编辑的节点' },
                ],
              },
            ],
          },
          //tab操作
          {
            modelName: 'tab操作',
            description: 'tab操作',
            children: [
              {
                purpose: '单击tab页签,页签高亮,双击未固定页签,页签变为固定页签',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '导航栏存在多个页签,包含固定和非固定页签' },
                ],
                operationSteps: [
                  { id: '1', name: '单击任意非选中的tab页签' },
                  { id: '2', name: '观察页签的高亮状态变化' },
                  { id: '3', name: '双击一个非固定(斜体)页签' },
                  { id: '4', name: '观察页签样式变化' },
                ],
                expectedResults: [
                  { id: '1', name: '单击后该页签变为选中状态(active类)' },
                  { id: '2', name: '其他页签取消选中状态' },
                  { id: '3', name: '双击后页签文字从斜体变为正常' },
                  { id: '4', name: '页签的fixed属性变为true' },
                ],
                checkpoints: [
                  { id: '1', name: 'selectCurrentTab(ProjectNav.vue:510-525)处理单击选中' },
                  { id: '2', name: 'fixCurrentTab(ProjectNav.vue:527-532)处理双击固定' },
                  { id: '3', name: 'projectNavStore.fixedNav更新fixed为true' },
                ],
                notes: [
                  { id: '1', name: '斜体样式通过.unfixed类控制' },
                  { id: '2', name: '固定页签防止被单击预览覆盖' },
                ],
              },
              {
                purpose: '单击tab页签,页签高亮,双击未固定页签,页签变为固定页签',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '导航栏存在非固定页签' },
                ],
                operationSteps: [
                  { id: '1', name: '单击一个非固定页签使其高亮' },
                  { id: '2', name: '双击该页签' },
                  { id: '3', name: '观察页签样式' },
                ],
                expectedResults: [
                  { id: '1', name: '页签从非固定变为固定' },
                  { id: '2', name: '文字样式从斜体变为正常' },
                  { id: '3', name: '页签保持选中状态' },
                ],
                checkpoints: [
                  { id: '1', name: 'projectNavStore.fixedNav设置fixed: true' },
                  { id: '2', name: 'projectWorkbenchCache.setProjectNavs持久化' },
                ],
                notes: [
                  { id: '1', name: '双击固定是用户确认要保留该页签的意图' },
                ],
              },
              {
                purpose: '大量tab时候,点击tab页签需要滚动到对应页签',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '导航栏页签数量超过可视区域宽度' },
                  { id: '3', name: '部分页签被隐藏在可视区域外' },
                ],
                operationSteps: [
                  { id: '1', name: '通过banner点击一个未在可视区域内的节点' },
                  { id: '2', name: '观察导航栏的滚动行为' },
                ],
                expectedResults: [
                  { id: '1', name: '导航栏自动滚动使新选中的页签可见' },
                  { id: '2', name: '选中的页签滚动到可视区域内' },
                  { id: '3', name: '滚动过渡平滑' },
                ],
                checkpoints: [
                  { id: '1', name: 'initViewTab(ProjectNav.vue:211-224)监听apidoc/tabs/addOrDeleteTab事件' },
                  { id: '2', name: 'activeNode.scrollIntoView()执行滚动' },
                  { id: '3', name: 'setTimeout确保DOM更新后再滚动' },
                ],
                notes: [
                  { id: '1', name: '使用scrollIntoView原生API' },
                  { id: '2', name: '新增和切换页签都会触发滚动' },
                ],
              },
              {
                purpose: '不存在未保存小圆点时候,点击关闭图标可以关闭页签',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '导航栏存在已保存(无小圆点)的页签' },
                ],
                operationSteps: [
                  { id: '1', name: '将鼠标移动到已保存页签上' },
                  { id: '2', name: '点击页签右侧的关闭图标(X)' },
                  { id: '3', name: '观察页签变化' },
                ],
                expectedResults: [
                  { id: '1', name: '页签被立即关闭' },
                  { id: '2', name: '无确认弹框出现' },
                  { id: '3', name: '其他页签位置自动调整' },
                ],
                checkpoints: [
                  { id: '1', name: 'handleCloseCurrentTab(ProjectNav.vue:356-376)' },
                  { id: '2', name: 'saved为true时直接删除无需确认' },
                  { id: '3', name: 'projectNavStore.deleteNavByIds执行删除' },
                ],
                notes: [
                  { id: '1', name: '已保存页签关闭不需要确认' },
                  { id: '2', name: '关闭图标在hover时显示' },
                ],
              },
              {
                purpose: '存在未保存小圆点时候,鼠标移动端小圆点区域,出现关闭按钮,点击关闭按钮可以关闭页签',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '导航栏存在未保存(有小圆点)的页签' },
                ],
                operationSteps: [
                  { id: '1', name: '修改某个节点内容使页签出现未保存小圆点' },
                  { id: '2', name: '将鼠标移动到小圆点区域' },
                  { id: '3', name: '观察小圆点区域变化' },
                  { id: '4', name: '点击出现的关闭按钮' },
                ],
                expectedResults: [
                  { id: '1', name: 'hover时小圆点变为关闭按钮(X)' },
                  { id: '2', name: '点击关闭按钮弹出确认对话框' },
                  { id: '3', name: '确认对话框提示是否保存修改' },
                  { id: '4', name: '可选择保存,不保存或取消' },
                ],
                checkpoints: [
                  { id: '1', name: 'v-show="!element.saved"控制小圆点显示' },
                  { id: '2', name: 'v-show="element.saved"控制关闭按钮显示' },
                  { id: '3', name: 'CSS :hover伪类切换显示' },
                ],
                notes: [
                  { id: '1', name: '小圆点和关闭按钮互斥显示' },
                  { id: '2', name: 'hover状态优先显示关闭按钮' },
                ],
              },
              {
                purpose: '关闭高亮tab页签,若还存在页签,则高亮最后一个页签,关闭非高亮页签不影响高亮',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '导航栏存在多个页签' },
                  { id: '3', name: '某个页签处于选中(高亮)状态' },
                ],
                operationSteps: [
                  { id: '1', name: '关闭当前选中的高亮页签' },
                  { id: '2', name: '观察其他页签的选中状态' },
                  { id: '3', name: '关闭一个非高亮页签' },
                  { id: '4', name: '观察当前高亮页签是否变化' },
                ],
                expectedResults: [
                  { id: '1', name: '关闭高亮页签后,最后一个页签变为高亮' },
                  { id: '2', name: '关闭非高亮页签不影响当前选中状态' },
                  { id: '3', name: '工作区内容随高亮页签切换' },
                ],
                checkpoints: [
                  { id: '1', name: 'deleteNavByIds中的freshNewSeletedNav(projectNavStore.ts:152-167)' },
                  { id: '2', name: '取navs.value[projectId].length - 1作为新选中' },
                  { id: '3', name: 'changeNavInfoById设置新页签selected为true' },
                ],
                notes: [
                  { id: '1', name: '选中最后一个页签而非相邻页签' },
                  { id: '2', name: '确保始终有一个页签处于选中状态' },
                ],
              },
              {
                purpose: '点击关闭按钮,鼠标中键,ctrl+w,鼠标右键关闭都可以关闭当前页签',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '导航栏存在可关闭的页签' },
                ],
                operationSteps: [
                  { id: '1', name: '点击页签的关闭图标(X)' },
                  { id: '2', name: '在另一个页签上按鼠标中键' },
                  { id: '3', name: '选中一个页签后按Ctrl+W' },
                  { id: '4', name: '右键页签选择关闭菜单项' },
                ],
                expectedResults: [
                  { id: '1', name: '所有四种方式都能成功关闭页签' },
                  { id: '2', name: '关闭行为一致' },
                  { id: '3', name: '未保存时都会弹出确认框' },
                ],
                checkpoints: [
                  { id: '1', name: '@click.stop="handleCloseCurrentTab(element)"处理点击关闭' },
                  { id: '2', name: 'handleMiddleClick(ProjectNav.vue:349-354)处理鼠标中键' },
                  { id: '3', name: 'e.button === 1判断中键点击' },
                  { id: '4', name: '右键菜单调用handleCloseCurrentTab()' },
                ],
                notes: [
                  { id: '1', name: 'Ctrl+W可能由快捷键系统处理' },
                  { id: '2', name: '中键点击是常见的浏览器关闭标签习惯' },
                ],
              },
              {
                purpose: '鼠标右键关闭左侧,关闭右侧,关闭其他,全部关闭,强制全部关闭都正确关闭相关页签',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '导航栏存在多个页签' },
                ],
                operationSteps: [
                  { id: '1', name: '右键某个页签,选择关闭左侧' },
                  { id: '2', name: '右键某个页签,选择关闭右侧' },
                  { id: '3', name: '右键某个页签,选择关闭其他' },
                  { id: '4', name: '右键某个页签,选择全部关闭' },
                  { id: '5', name: '右键某个页签,选择强制全部关闭' },
                ],
                expectedResults: [
                  { id: '1', name: '关闭左侧:关闭该页签左侧所有页签' },
                  { id: '2', name: '关闭右侧:关闭该页签右侧所有页签' },
                  { id: '3', name: '关闭其他:仅保留该页签' },
                  { id: '4', name: '全部关闭:关闭所有页签(未保存需确认)' },
                  { id: '5', name: '强制全部关闭:直接关闭所有页签不确认' },
                ],
                checkpoints: [
                  { id: '1', name: 'handleCloseLeftTab(ProjectNav.vue:417-443)' },
                  { id: '2', name: 'handleCloseRightTab(ProjectNav.vue:445-470)' },
                  { id: '3', name: 'handleCloseOtherTab(ProjectNav.vue:378-415)' },
                  { id: '4', name: 'handleCloseAllTab(ProjectNav.vue:472-486)' },
                  { id: '5', name: 'handleForceCloseAllTab(ProjectNav.vue:488-500)调用forceDeleteAllNav' },
                ],
                notes: [
                  { id: '1', name: '批量关闭时会逐个检查未保存状态' },
                  { id: '2', name: '强制关闭跳过所有确认直接删除' },
                ],
              },
              {
                purpose: '被关闭的页签如果是httpNode,websocketNode,httpMockNode,websocketMockNode节点,存在未保存的内容,关闭时候需要提醒用户`是否要保存对内容的修改`',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '存在未保存的节点类型页签(saved: false)' },
                ],
                operationSteps: [
                  { id: '1', name: '修改httpNode内容使页签出现未保存标记' },
                  { id: '2', name: '尝试关闭该页签' },
                  { id: '3', name: '观察弹出的确认对话框' },
                ],
                expectedResults: [
                  { id: '1', name: '弹出ElMessageBox确认框' },
                  { id: '2', name: '提示内容包含节点名称' },
                  { id: '3', name: '提供保存,不保存,取消三个选项' },
                  { id: '4', name: '选择保存则保存后关闭' },
                  { id: '5', name: '选择不保存则直接关闭' },
                  { id: '6', name: '选择取消则保留页签' },
                ],
                checkpoints: [
                  { id: '1', name: 'deleteNavByIds(projectNavStore.ts:141-200)' },
                  { id: '2', name: 'unsavedNavs过滤出saved为false的页签' },
                  { id: '3', name: 'ElMessageBox.confirm显示确认框' },
                  { id: '4', name: 'i18n.global.t("是否要保存对内容的修改")' },
                  { id: '5', name: 'distinguishCancelAndClose区分取消和关闭' },
                ],
                notes: [
                  { id: '1', name: '多个未保存页签会逐个询问' },
                  { id: '2', name: '确认框支持国际化' },
                ],
              },
            ],
          },
          //tab拖拽
          {
            modelName: 'tab拖拽',
            description: 'tab拖拽',
            children: [
              {
                purpose: '可以将tab页签拖拽到首位,末尾,任意标签左侧,任意标签右侧,拖拽后刷新页面保持不变',
                precondition: [
                  { id: '1', name: '已登录并打开任意项目工作区' },
                  { id: '2', name: '导航栏存在多个页签(至少3个)' },
                ],
                operationSteps: [
                  { id: '1', name: '拖拽中间位置的页签到最左侧' },
                  { id: '2', name: '拖拽一个页签到最右侧(末尾)' },
                  { id: '3', name: '拖拽一个页签到另一个页签左侧' },
                  { id: '4', name: '拖拽一个页签到另一个页签右侧' },
                  { id: '5', name: '刷新页面观察页签顺序' },
                ],
                expectedResults: [
                  { id: '1', name: '页签成功移动到目标位置' },
                  { id: '2', name: '拖拽过程有150ms动画效果' },
                  { id: '3', name: '其他页签自动调整位置' },
                  { id: '4', name: '刷新页面后页签顺序保持不变' },
                ],
                checkpoints: [
                  { id: '1', name: 'SDraggable组件(vuedraggable)实现拖拽' },
                  { id: '2', name: 'v-model="tabs"双向绑定实现顺序更新' },
                  { id: '3', name: 'animation="150"控制动画时长' },
                  { id: '4', name: 'updateAllNavs(projectNavStore.ts:79-83)更新完整列表' },
                  { id: '5', name: 'projectWorkbenchCache.setProjectNavs持久化顺序' },
                ],
                notes: [
                  { id: '1', name: '使用vuedraggable第三方库' },
                  { id: '2', name: 'item-key="name"作为拖拽项标识' },
                ],
              },
            ],
          },
        ],
      },
      // httpNode工作区
      {
        modelName: 'httpNode工作区',
        description: 'httpNode工作区',
        children: [
          // 操作区域
          {
            modelName: 'operation',
            description: '操作区域',
            children: [
              {
                modelName: '请求方法录入区域',
                description: '请求方法录入区域',
                atomicFunc: [
                  {
                    purpose: '正确展示GET, POST, PUT, DEL, PATCH, HEAD, OPTIONS,选择或者点击空白区域下拉菜单消失',
                    precondition: [
                      { id: '1', name: '已登录并打开任意项目工作区' },
                      { id: '2', name: '已打开httpNode节点页签' },
                    ],
                    operationSteps: [
                      { id: '1', name: '点击请求方法下拉框' },
                      { id: '2', name: '查看下拉选项列表' },
                      { id: '3', name: '选择某个请求方法' },
                      { id: '4', name: '点击下拉框外的空白区域' },
                    ],
                    expectedResults: [
                      { id: '1', name: '下拉框展示GET, POST, PUT, DEL, PATCH, HEAD, OPTIONS七个选项' },
                      { id: '2', name: '各选项颜色与定义一致(GET绿色,POST黄色,PUT蓝色等)' },
                      { id: '3', name: '选择后下拉框关闭,显示选中值' },
                      { id: '4', name: '点击空白区域下拉菜单消失' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'requestMethodEnum来自data/data.ts中的requestMethods' },
                      { id: '2', name: 'el-select组件处理下拉展示和关闭' },
                      { id: '3', name: 'data-testid="method-select"用于测试定位' },
                    ],
                    notes: [
                      { id: '1', name: 'DEL对应value为DELETE' },
                      { id: '2', name: 'iconColor定义各方法颜色' },
                    ],
                  },
                  {
                    purpose: '切换请求方法不会改变banner节点中的请求方法,也不会改变nav栏节点中的请求方法,只有保存后才会生效',
                    precondition: [
                      { id: '1', name: '已登录并打开任意项目工作区' },
                      { id: '2', name: '已打开已保存的httpNode节点' },
                      { id: '3', name: '当前请求方法为GET' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在操作区切换请求方法为POST' },
                      { id: '2', name: '观察banner中该节点的方法图标' },
                      { id: '3', name: '观察nav页签中的方法图标' },
                      { id: '4', name: '点击保存按钮' },
                      { id: '5', name: '再次观察banner和nav的方法图标' },
                    ],
                    expectedResults: [
                      { id: '1', name: '切换后banner节点图标仍为GET' },
                      { id: '2', name: '切换后nav页签图标仍为GET' },
                      { id: '3', name: '页签出现未保存小圆点' },
                      { id: '4', name: '保存后banner和nav图标变为POST' },
                      { id: '5', name: '保存后未保存小圆点消失' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'requestMethod通过computed绑定httpNodeStore' },
                      { id: '2', name: 'saveHttpNode执行后更新banner和nav' },
                      { id: '3', name: '未保存状态通过saved字段控制' },
                    ],
                    notes: [
                      { id: '1', name: '编辑态与展示态分离设计' },
                      { id: '2', name: '确保用户明确保存意图后才生效' },
                    ],
                  },
                  {
                    purpose: '切换所有请求方法,点击发送请求,调用测试服务器/echo接口,返回method为选中的method',
                    precondition: [
                      { id: '1', name: '已登录并打开任意项目工作区' },
                      { id: '2', name: '已打开httpNode节点' },
                      { id: '3', name: '测试服务器已启动' },
                    ],
                    operationSteps: [
                      { id: '1', name: '输入测试服务器/echo接口地址' },
                      { id: '2', name: '依次切换为GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS' },
                      { id: '3', name: '每次切换后点击发送请求' },
                      { id: '4', name: '查看响应结果中的method字段' },
                    ],
                    expectedResults: [
                      { id: '1', name: '每次请求都成功返回' },
                      { id: '2', name: '响应中method字段与选中的方法一致' },
                      { id: '3', name: 'GET返回method:"GET"' },
                      { id: '4', name: 'POST返回method:"POST"' },
                      { id: '5', name: '其他方法类似' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'handleSendRequest调用sendRequest发送请求' },
                      { id: '2', name: 'httpNodeRequestStore.fullUrl包含完整URL' },
                      { id: '3', name: 'requestMethod传递给后端请求' },
                    ],
                    notes: [
                      { id: '1', name: '/echo接口会回显请求的method' },
                      { id: '2', name: 'HEAD和OPTIONS可能返回特殊格式' },
                    ],
                  },
                ],
              },
              {
                modelName: '请求url录入区域',
                description: '请求url录入区域',
                atomicFunc: [
                  {
                    purpose: '输入http://localhost:{环境变量中的端口}/echo,点击发送请求,调用测试服务器/echo接口,成功返回',
                    precondition: [
                      { id: '1', name: '已登录并打开任意项目工作区' },
                      { id: '2', name: '已打开httpNode节点' },
                      { id: '3', name: '测试服务器已启动' },
                      { id: '4', name: '环境变量中已配置端口变量' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在URL输入框输入http://localhost:{{port}}/echo' },
                      { id: '2', name: '点击发送请求按钮' },
                      { id: '3', name: '查看响应结果' },
                    ],
                    expectedResults: [
                      { id: '1', name: '变量{{port}}被正确解析为实际端口' },
                      { id: '2', name: '请求成功返回200状态码' },
                      { id: '3', name: '响应body包含echo接口返回内容' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'ClRichInput组件处理变量语法' },
                      { id: '2', name: 'variableStore解析变量值' },
                      { id: '3', name: 'localhost解析为127.0.0.1' },
                    ],
                    notes: [
                      { id: '1', name: 'localhost在某些环境可能需要配置hosts' },
                    ],
                  },
                  {
                    purpose: '输入http://127.0.0.1:{环境变量中的端口}/echo,点击发送请求,调用测试服务器/echo接口,成功返回',
                    precondition: [
                      { id: '1', name: '已登录并打开任意项目工作区' },
                      { id: '2', name: '已打开httpNode节点' },
                      { id: '3', name: '测试服务器已启动' },
                      { id: '4', name: '环境变量中已配置端口变量' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在URL输入框输入http://127.0.0.1:{{port}}/echo' },
                      { id: '2', name: '点击发送请求按钮' },
                      { id: '3', name: '查看响应结果' },
                    ],
                    expectedResults: [
                      { id: '1', name: '变量{{port}}被正确解析' },
                      { id: '2', name: '请求成功返回200状态码' },
                      { id: '3', name: 'IP地址直接访问成功' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'IP地址格式验证通过' },
                      { id: '2', name: '变量替换在发送前完成' },
                    ],
                    notes: [
                      { id: '1', name: '127.0.0.1是最可靠的本地地址' },
                    ],
                  },
                  {
                    purpose: '定义一个localUrl变量,输入http://{{ localUrl }}:{环境变量中的端口}/echo,点击发送请求,调用测试服务器/echo接口,成功返回',
                    precondition: [
                      { id: '1', name: '已登录并打开任意项目工作区' },
                      { id: '2', name: '已打开httpNode节点' },
                      { id: '3', name: '测试服务器已启动' },
                      { id: '4', name: '已定义localUrl变量值为127.0.0.1' },
                      { id: '5', name: '已定义port变量为测试服务器端口' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在URL输入框输入http://{{localUrl}}:{{port}}/echo' },
                      { id: '2', name: '点击发送请求按钮' },
                      { id: '3', name: '查看响应结果' },
                    ],
                    expectedResults: [
                      { id: '1', name: 'localUrl变量被解析为127.0.0.1' },
                      { id: '2', name: 'port变量被解析为实际端口' },
                      { id: '3', name: '请求成功返回' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'getVariableValue(label)获取变量值' },
                      { id: '2', name: 'variableStore.objectVariable存储变量映射' },
                      { id: '3', name: '多个变量同时替换' },
                    ],
                    notes: [
                      { id: '1', name: '变量可以在URL的任意位置使用' },
                      { id: '2', name: '变量语法为双大括号包裹' },
                    ],
                  },
                  {
                    purpose: '输入127.0.0.1:{环境变量中的端口}/echo(没有协议自动添加http), 点击发送请求,调用测试服务器/echo接口,成功返回',
                    precondition: [
                      { id: '1', name: '已登录并打开任意项目工作区' },
                      { id: '2', name: '已打开httpNode节点' },
                      { id: '3', name: '测试服务器已启动' },
                      { id: '4', name: '环境变量中已配置端口变量' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在URL输入框输入127.0.0.1:{{port}}/echo(不带http://)' },
                      { id: '2', name: 'blur失焦或点击发送请求' },
                      { id: '3', name: '查看请求地址展示区域' },
                    ],
                    expectedResults: [
                      { id: '1', name: '自动添加http://协议前缀' },
                      { id: '2', name: '请求地址展示为http://127.0.0.1:port/echo' },
                      { id: '3', name: '请求成功返回' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'handleFormatUrl(Operation.vue:21)处理blur事件' },
                      { id: '2', name: 'URL校验与自动补全逻辑' },
                    ],
                    notes: [
                      { id: '1', name: '类似http.baidu.com也需要添加http://' },
                      { id: '2', name: '自动补全提升用户体验' },
                    ],
                  },
                  {
                    purpose: '输入127.0.0.1:{环境变量中的端口}/echo?id=3&name=lee, blur后,url结果为http://127.0.0.1:{环境变量中的端口}/echo,id和name会出现在query参数中',
                    precondition: [
                      { id: '1', name: '已登录并打开任意项目工作区' },
                      { id: '2', name: '已打开httpNode节点' },
                      { id: '3', name: '环境变量中已配置端口变量' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在URL输入框输入127.0.0.1:{{port}}/echo?id=3&name=lee' },
                      { id: '2', name: 'blur失焦URL输入框' },
                      { id: '3', name: '查看URL展示区域和query参数列表' },
                    ],
                    expectedResults: [
                      { id: '1', name: 'URL展示区域为http://127.0.0.1:port/echo(不含查询参数)' },
                      { id: '2', name: 'query参数列表出现id参数,值为3' },
                      { id: '3', name: 'query参数列表出现name参数,值为lee' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'handleChangeUrl解析URL中的查询参数' },
                      { id: '2', name: '查询参数自动提取到params列表' },
                      { id: '3', name: 'path和query分离处理' },
                    ],
                    notes: [
                      { id: '1', name: '查询参数自动解析方便用户管理' },
                      { id: '2', name: '支持多个查询参数同时解析' },
                    ],
                  },
                  {
                    purpose: '输入127.0.0.1:{环境变量中的端口}/echo?id=3&name=lee, blur后,url结果为http://127.0.0.1:{环境变量中的端口}/echo,id和name会出现在query参数中,点击发送请求,返回结果中url和query参数正确',
                    precondition: [
                      { id: '1', name: '已登录并打开任意项目工作区' },
                      { id: '2', name: '已打开httpNode节点' },
                      { id: '3', name: '测试服务器已启动' },
                      { id: '4', name: '环境变量中已配置端口变量' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在URL输入框输入127.0.0.1:{{port}}/echo?id=3&name=lee' },
                      { id: '2', name: 'blur失焦确保参数解析' },
                      { id: '3', name: '点击发送请求按钮' },
                      { id: '4', name: '查看响应结果' },
                    ],
                    expectedResults: [
                      { id: '1', name: '响应中包含正确的url地址' },
                      { id: '2', name: '响应中query参数包含id=3' },
                      { id: '3', name: '响应中query参数包含name=lee' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'httpNodeRequestStore.fullUrl包含完整URL' },
                      { id: '2', name: '查询参数正确拼接到请求URL' },
                      { id: '3', name: 'echo接口返回完整请求信息' },
                    ],
                    notes: [
                      { id: '1', name: '查询参数会被自动URL编码' },
                    ],
                  },
                  {
                    purpose: '输入127.0.0.1:{环境变量中的端口}/echo/{userId}/posts/{postId},userId和postId会出现在query参数中,点击发送请求,返回结果中url和path参数正确',
                    precondition: [
                      { id: '1', name: '已登录并打开任意项目工作区' },
                      { id: '2', name: '已打开httpNode节点' },
                      { id: '3', name: '测试服务器已启动' },
                      { id: '4', name: '环境变量中已配置端口变量' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在URL输入框输入127.0.0.1:{{port}}/echo/{userId}/posts/{postId}' },
                      { id: '2', name: '查看path参数列表' },
                      { id: '3', name: '填userId和postId的值' },
                      { id: '4', name: '点击发送请求' },
                    ],
                    expectedResults: [
                      { id: '1', name: 'path参数列表出现userId和postId' },
                      { id: '2', name: '填写的值会替换URL中的占位符' },
                      { id: '3', name: '响应中url包含替换后的path' },
                    ],
                    checkpoints: [
                      { id: '1', name: '{param}语法解析为path参数' },
                      { id: '2', name: 'path参数与query参数分开管理' },
                      { id: '3', name: '发送前path参数替换到URL' },
                    ],
                    notes: [
                      { id: '1', name: 'path参数使用单大括号语法' },
                      { id: '2', name: '与变量双大括号语法不同' },
                    ],
                  },
                  {
                    purpose: '输入127.0.0.1:{环境变量中的端口}/echo/{变量名称},点击变量名称如果存在,显示变量名称和变量值,如果变量不存在提醒跳转到变量管理页面,点击跳转后,跳转到变量管理页面并且关闭变量弹窗',
                    precondition: [
                      { id: '1', name: '已登录并打开任意项目工作区' },
                      { id: '2', name: '已打开httpNode节点' },
                      { id: '3', name: '存在已定义和未定义的变量' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在URL中输入{{existVar}}已存在的变量' },
                      { id: '2', name: '点击变量标签查看popover' },
                      { id: '3', name: '在URL中输入{{notExist}}不存在的变量' },
                      { id: '4', name: '点击变量标签查看popover' },
                      { id: '5', name: '点击前往变量管理链接' },
                    ],
                    expectedResults: [
                      { id: '1', name: '已存在变量显示名称和值' },
                      { id: '2', name: '不存在变量显示警告提示' },
                      { id: '3', name: '提供前往变量管理链接' },
                      { id: '4', name: '点击后跳转到变量管理页签' },
                      { id: '5', name: 'popover自动关闭' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'ClRichInput的#variable插槽处理变量popover' },
                      { id: '2', name: 'getVariableValue(label)判断变量是否存在' },
                      { id: '3', name: 'handleGoToVariableManage跳转变量管理' },
                      { id: '4', name: 'urlRichInputRef.hideVariablePopover()关闭popover' },
                    ],
                    notes: [
                      { id: '1', name: '变量不存在时给用户明确引导' },
                    ],
                  },
                  {
                    purpose: '粘贴的url需要去除前后空格',
                    precondition: [
                      { id: '1', name: '已登录并打开任意项目工作区' },
                      { id: '2', name: '已打开httpNode节点' },
                      { id: '3', name: '剪贴板中包含前后有空格的URL' },
                    ],
                    operationSteps: [
                      { id: '1', name: '复制一个前后带空格的URL到剪贴板' },
                      { id: '2', name: '在URL输入框中Ctrl+V粘贴' },
                      { id: '3', name: '查看URL输入框内容' },
                    ],
                    expectedResults: [
                      { id: '1', name: 'URL前后的空格被自动去除' },
                      { id: '2', name: 'URL内容中间的空格保留(如果有)' },
                      { id: '3', name: '粘贴后URL格式正确' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'ClRichInput的trim-on-paste属性为true' },
                      { id: '2', name: '粘贴事件处理中调用trim()' },
                    ],
                    notes: [
                      { id: '1', name: '避免意外空格导致请求失败' },
                    ],
                  },
                  {
                    purpose: 'url中存在内容,光标在内容中间,ctrl+v粘贴时候,url展示内容正确',
                    precondition: [
                      { id: '1', name: '已登录并打开任意项目工作区' },
                      { id: '2', name: '已打开httpNode节点' },
                      { id: '3', name: 'URL输入框已有内容' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在URL输入框输入http://test.com/api' },
                      { id: '2', name: '将光标定位到test.com之后' },
                      { id: '3', name: '复制.example到剪贴板' },
                      { id: '4', name: 'Ctrl+V粘贴' },
                    ],
                    expectedResults: [
                      { id: '1', name: 'URL变为http://test.com.example/api' },
                      { id: '2', name: '粘贴内容插入到光标位置' },
                      { id: '3', name: '前后内容保持不变' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'ClRichInput组件处理中间位置粘贴' },
                      { id: '2', name: '光标位置正确记录和恢复' },
                    ],
                    notes: [
                      { id: '1', name: '确保编辑体验符合预期' },
                    ],
                  },
                ],
              },
              {
                modelName: '请求url展示区域',
                description: '请求url展示区域',
                atomicFunc: [
                  {
                    purpose: 'url地址展示encode后的结果',
                    precondition: [{ id: '1', name: '已打开httpNode节点编辑页面' }],
                    operationSteps: [{ id: '1', name: '在url输入框输入包含中文或特殊字符的url(如http://example.com/测试)' }, { id: '2', name: '观察url展示区域显示的内容' }],
                    expectedResults: [{ id: '1', name: 'url展示区域显示encode后的结果(如http://example.com/%E6%B5%8B%E8%AF%95)' }],
                    checkpoints: [{ id: '1', name: 'url展示区域使用encodeURI或encodeURIComponent处理url' }],
                    notes: [{ id: '1', name: 'url编码确保特殊字符正确传输' }],
                  },
                  {
                    purpose: '如果url地址存在异常(非https?://,双//,包含空格,存在未定义的变量等),需要提示tooltip',
                    precondition: [{ id: '1', name: '已打开httpNode节点编辑页面' }],
                    operationSteps: [{ id: '1', name: '输入异常url(如ftp://example.com或http://example.com//path或http://example.com/{{undefinedVar}})' }, { id: '2', name: '鼠标悬停在url展示区域' }],
                    expectedResults: [{ id: '1', name: '显示tooltip提示url异常原因' }],
                    checkpoints: [{ id: '1', name: 'url验证逻辑检测协议,双斜杠,空格,未定义变量' }],
                    notes: [{ id: '1', name: 'tooltip帮助用户快速定位url问题' }],
                  },
                  {
                    purpose: 'url如果没有http://或者https://开头,自动添加http://或者https://,注意:http.baidu.com这个地址也需要自动添加http://',
                    precondition: [{ id: '1', name: '已打开httpNode节点编辑页面' }],
                    operationSteps: [{ id: '1', name: '输入不带协议的url(如example.com或http.baidu.com)' }, { id: '2', name: '点击发送请求按钮' }],
                    expectedResults: [{ id: '1', name: '系统自动添加http://前缀(如http://example.com或http://http.baidu.com)' }],
                    checkpoints: [{ id: '1', name: '发送请求前检查url是否以http://或https://开头,否则自动添加' }],
                    notes: [{ id: '1', name: '自动添加协议提升用户体验,避免请求失败' }],
                  },
                ],
              },
              {
                modelName: '请求操作区域',
                description: '请求操作区域',
                children: [
                  {
                    modelName: '发送请求按钮',
                    description: '发送请求按钮',
                    atomicFunc: [
                      {
                        purpose: '发送请求按钮点击后,请求过程中出现取消请求按钮,点击后取消请求,并且在返回值区域展示请求已取消',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,配置了有效的请求url' }],
                        operationSteps: [{ id: '1', name: '点击发送请求按钮' }, { id: '2', name: '在请求进行中点击取消请求按钮' }],
                        expectedResults: [{ id: '1', name: '请求被中止,返回值区域显示"请求已取消"或类似提示' }, { id: '2', name: '按钮恢复为发送请求状态' }],
                        checkpoints: [{ id: '1', name: '使用AbortController或类似机制取消请求' }],
                        notes: [{ id: '1', name: '取消功能避免长时间等待无响应的请求' }],
                      },
                      {
                        purpose: '发送请求按钮点击后变成取消请求按钮,请求成功或者失败后,取消请求按钮变为发送请求按钮',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面' }],
                        operationSteps: [{ id: '1', name: '点击发送请求按钮' }, { id: '2', name: '等待请求完成(成功或失败)' }],
                        expectedResults: [{ id: '1', name: '请求过程中按钮文本变为"取消请求"' }, { id: '2', name: '请求完成后按钮文本恢复为"发送请求"' }],
                        checkpoints: [{ id: '1', name: '按钮状态通过loading或requesting响应式变量控制' }],
                        notes: [{ id: '1', name: '按钮状态反馈请求生命周期' }],
                      },
                    ],
                  },
                  {
                    modelName: '保存按钮',
                    description: '保存按钮',
                    atomicFunc: [
                      {
                        purpose: '无任何数据变更时候可以点击保存按钮',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,无任何修改' }],
                        operationSteps: [{ id: '1', name: '直接点击保存按钮' }],
                        expectedResults: [{ id: '1', name: '保存成功,无错误提示' }],
                        checkpoints: [{ id: '1', name: '保存逻辑允许无变更时保存' }],
                        notes: [{ id: '1', name: '允许无变更保存确保用户操作自由度' }],
                      },
                      {
                        purpose: '存在数据变更点击保存按钮,未保存小圆点消失,刷新页面数据保持不变',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面' }],
                        operationSteps: [{ id: '1', name: '修改任意字段(如url)' }, { id: '2', name: '观察保存按钮出现未保存小圆点' }, { id: '3', name: '点击保存按钮' }, { id: '4', name: '刷新页面' }],
                        expectedResults: [{ id: '1', name: '保存后小圆点消失' }, { id: '2', name: '刷新页面后数据保持修改后的值' }],
                        checkpoints: [{ id: '1', name: '未保存标识通过isDirty或hasChanges变量控制' }, { id: '2', name: '保存后更新IndexedDB或调用服务器API' }],
                        notes: [{ id: '1', name: '小圆点提示用户有未保存的修改' }],
                      },
                      {
                        purpose:
                          '验证每一个录入项(请求方法,请求url,query参数key,query参数value,query参数备注,query参数是否发送,query参数是否必有,query参数顺序,query参数个数,body参数mode,body参数值,请求头,返回参数,前置脚本,后置脚本,备注)变更后,保存按钮小圆点消失,刷新页面数据保持不变',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面' }],
                        operationSteps: [{ id: '1', name: '逐一修改每个录入项' }, { id: '2', name: '每次修改后点击保存' }, { id: '3', name: '刷新页面验证数据持久化' }],
                        expectedResults: [{ id: '1', name: '所有录入项修改后保存成功,小圆点消失,刷新后数据不丢失' }],
                        checkpoints: [{ id: '1', name: '所有字段变更都触发isDirty标识' }, { id: '2', name: '保存时完整序列化所有字段到存储层' }],
                        notes: [{ id: '1', name: '全字段验证确保数据完整性' }],
                      },
                    ],
                  },
                  {
                    modelName: '刷新按钮',
                    description: '刷新按钮',
                    atomicFunc: [
                      {
                        purpose: '刷新按钮点击后,清空修改的值',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,修改了部分字段但未保存' }],
                        operationSteps: [{ id: '1', name: '修改url等字段' }, { id: '2', name: '点击刷新按钮' }],
                        expectedResults: [{ id: '1', name: '所有修改的值恢复为上次保存的值' }, { id: '2', name: '未保存小圆点消失' }],
                        checkpoints: [{ id: '1', name: '刷新按钮重新从IndexedDB或服务器加载数据' }],
                        notes: [{ id: '1', name: '刷新功能用于撤销未保存的修改' }],
                      },
                      {
                        purpose: '验证每一个录入项(请求方法,请求url,query参数key,query参数value,query参数备注,query参数是否发送,query参数是否必有,query参数顺序,query参数个数,body参数mode,body参数值,请求头,返回参数,前置脚本,后置脚本,备注)变更后,刷新页面数据恢复',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面' }],
                        operationSteps: [{ id: '1', name: '逐一修改每个录入项' }, { id: '2', name: '每次修改后点击刷新按钮' }],
                        expectedResults: [{ id: '1', name: '所有录入项修改后点击刷新,数据全部恢复为原值' }],
                        checkpoints: [{ id: '1', name: '刷新按钮重新加载所有字段' }],
                        notes: [{ id: '1', name: '全字段验证确保刷新功能完整性' }],
                      },
                    ],
                  },
                ],
              },
              {
                modelName: '撤销操作',
                description: '撤销操作',
                children: [
                  {
                    modelName: '请求方法撤销',
                    description: '请求方法撤销',
                    atomicFunc: [
                      {
                        purpose: '切换请求方法两次,点击撤销按钮,请求方法恢复到上一次的状态,再次点击撤销按钮,请求方法恢复到最初,并且撤销按钮置灰不可点击',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,初始请求方法为GET' }],
                        operationSteps: [
                          { id: '1', name: '将请求方法切换为POST' },
                          { id: '2', name: '将请求方法切换为PUT' },
                          { id: '3', name: '点击撤销按钮' },
                          { id: '4', name: '再次点击撤销按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '第一次撤销后请求方法恢复为POST' },
                          { id: '2', name: '第二次撤销后请求方法恢复为GET' },
                          { id: '3', name: '撤销按钮置灰不可点击' },
                        ],
                        checkpoints: [{ id: '1', name: 'redoUndoStore管理操作历史栈,撤销按钮依赖canUndo状态' }],
                        notes: [{ id: '1', name: '撤销功能使用栈结构记录每次操作' }],
                      },
                      {
                        purpose: '切换请求方法两次,按ctrl+z,请求方法恢复到上一次的状态,再次按ctrl+z,请求方法恢复到最初,并且撤销按钮置灰不可点击',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,初始请求方法为GET' }],
                        operationSteps: [
                          { id: '1', name: '将请求方法切换为POST' },
                          { id: '2', name: '将请求方法切换为PUT' },
                          { id: '3', name: '按ctrl+z快捷键' },
                          { id: '4', name: '再次按ctrl+z快捷键' },
                        ],
                        expectedResults: [
                          { id: '1', name: '第一次按快捷键后请求方法恢复为POST' },
                          { id: '2', name: '第二次按快捷键后请求方法恢复为GET' },
                          { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                        ],
                        checkpoints: [{ id: '1', name: '快捷键监听绑定到redoUndoStore.undo方法' }],
                        notes: [{ id: '1', name: 'ctrl+z快捷键与撤销按钮功能一致' }],
                      },
                    ],
                  },
                  {
                    modelName: '请求url撤销',
                    description: '请求url撤销',
                    atomicFunc: [
                      {
                        purpose: '请求url中输入字符串ab,点击撤销按钮,url值为a,再次点击撤销按钮,url值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,url输入框为空' }],
                        operationSteps: [
                          { id: '1', name: '在url输入框输入字符a' },
                          { id: '2', name: '继续输入字符b,url值为ab' },
                          { id: '3', name: '点击撤销按钮' },
                          { id: '4', name: '再次点击撤销按钮' },
                          { id: '5', name: '尝试继续按ctrl+z' },
                        ],
                        expectedResults: [
                          { id: '1', name: '第一次撤销后url值为a' },
                          { id: '2', name: '第二次撤销后url值为空' },
                          { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                        ],
                        checkpoints: [{ id: '1', name: 'redoUndoStore记录每个字符输入操作' }],
                        notes: [{ id: '1', name: '文本输入每个字符变化都记录为独立操作' }],
                      },
                      {
                        purpose: '请求url中输入字符串ab,按ctrl+z,url值为a,再次按ctrl+z,url值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,url输入框为空' }],
                        operationSteps: [
                          { id: '1', name: '在url输入框输入字符a' },
                          { id: '2', name: '继续输入字符b,url值为ab' },
                          { id: '3', name: '按ctrl+z快捷键' },
                          { id: '4', name: '再次按ctrl+z快捷键' },
                          { id: '5', name: '尝试继续按ctrl+z' },
                        ],
                        expectedResults: [
                          { id: '1', name: '第一次按快捷键后url值为a' },
                          { id: '2', name: '第二次按快捷键后url值为空' },
                          { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                        ],
                        checkpoints: [{ id: '1', name: '快捷键与撤销按钮共享同一操作历史栈' }],
                        notes: [{ id: '1', name: '快捷键行为与按钮一致' }],
                      },
                      {
                        purpose: '请求url中输入中文字符串`你好`,点击撤销按钮,url值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,url输入框为空' }],
                        operationSteps: [
                          { id: '1', name: '在url输入框输入中文字符串"你好"' },
                          { id: '2', name: '点击撤销按钮' },
                          { id: '3', name: '尝试继续按ctrl+z' },
                        ],
                        expectedResults: [
                          { id: '1', name: '撤销后url值为空' },
                          { id: '2', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                        ],
                        checkpoints: [{ id: '1', name: '中文输入法输入可能作为单次操作记录' }],
                        notes: [{ id: '1', name: '中文输入通常在确认后才记录操作' }],
                      },
                      {
                        purpose: '请求url中输入中文字符串`你好`,按ctrl+z,url值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,url输入框为空' }],
                        operationSteps: [
                          { id: '1', name: '在url输入框输入中文字符串"你好"' },
                          { id: '2', name: '按ctrl+z快捷键' },
                          { id: '3', name: '尝试继续按ctrl+z' },
                        ],
                        expectedResults: [
                          { id: '1', name: '按快捷键后url值为空' },
                          { id: '2', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                        ],
                        checkpoints: [{ id: '1', name: '快捷键处理中文输入操作' }],
                        notes: [{ id: '1', name: '中文输入撤销行为与英文一致' }],
                      },
                      {
                        purpose: '请求url中输入字符串a,ctrl+v粘贴`test.demo.com`,点击撤销按钮,url值为a,再次点击撤销按钮,url值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,url输入框为空' }],
                        operationSteps: [
                          { id: '1', name: '在url输入框输入字符a' },
                          { id: '2', name: '按ctrl+v粘贴"test.demo.com"' },
                          { id: '3', name: '点击撤销按钮' },
                          { id: '4', name: '再次点击撤销按钮' },
                          { id: '5', name: '尝试继续按ctrl+z' },
                        ],
                        expectedResults: [
                          { id: '1', name: '第一次撤销后url值为a' },
                          { id: '2', name: '第二次撤销后url值为空' },
                          { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                        ],
                        checkpoints: [{ id: '1', name: '粘贴操作作为单次操作记录' }],
                        notes: [{ id: '1', name: '粘贴整段文本算一次操作,可一次性撤销' }],
                      },
                      {
                        purpose: '请求url中输入字符串a,ctrl+v粘贴`test.demo.com`,按ctrl+z,url值为a,再次按ctrl+z,url值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,url输入框为空' }],
                        operationSteps: [
                          { id: '1', name: '在url输入框输入字符a' },
                          { id: '2', name: '按ctrl+v粘贴"test.demo.com"' },
                          { id: '3', name: '按ctrl+z快捷键' },
                          { id: '4', name: '再次按ctrl+z快捷键' },
                          { id: '5', name: '尝试继续按ctrl+z' },
                        ],
                        expectedResults: [
                          { id: '1', name: '第一次按快捷键后url值为a' },
                          { id: '2', name: '第二次按快捷键后url值为空' },
                          { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                        ],
                        checkpoints: [{ id: '1', name: '快捷键处理粘贴操作撤销' }],
                        notes: [{ id: '1', name: '快捷键撤销粘贴操作与按钮行为一致' }],
                      },
                    ],
                  },
                  {
                    modelName: 'query参数撤销',
                    description: 'query参数撤销',
                    children: [
                      {
                        modelName: 'url与query参数联动撤销',
                        description: 'url与query参数联动撤销',
                        atomicFunc: [
                          {
                            purpose: '请求url中粘贴http://demo.com/user?id=3,blur后,点击撤销按钮,删除query参数,再次点击撤销按钮,url值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,url输入框为空' }],
                            operationSteps: [
                              { id: '1', name: '在url输入框粘贴http://demo.com/user?id=3' },
                              { id: '2', name: '失焦(blur)触发url解析,query参数自动提取到query参数表格' },
                              { id: '3', name: '点击撤销按钮' },
                              { id: '4', name: '再次点击撤销按钮' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次撤销后query参数表格清空,url恢复为http://demo.com/user?id=3' },
                              { id: '2', name: '第二次撤销后url值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: 'url blur事件触发query参数解析并记录操作历史' }],
                            notes: [{ id: '1', name: 'url与query参数联动,blur时自动解析query参数' }],
                          },
                          {
                            purpose: '请求url中粘贴http://demo.com/user?id=3,blur后,点击ctrl+z,删除query参数,再次按ctrl+z,url值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,url输入框为空' }],
                            operationSteps: [
                              { id: '1', name: '在url输入框粘贴http://demo.com/user?id=3' },
                              { id: '2', name: '失焦(blur)触发url解析,query参数自动提取到query参数表格' },
                              { id: '3', name: '按ctrl+z快捷键' },
                              { id: '4', name: '再次按ctrl+z快捷键' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后query参数表格清空,url恢复为http://demo.com/user?id=3' },
                              { id: '2', name: '第二次按快捷键后url值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '快捷键撤销url解析操作' }],
                            notes: [{ id: '1', name: '快捷键撤销与按钮行为一致' }],
                          },
                        ],
                      },
                      {
                        modelName: 'query参数拖拽撤销',
                        description: 'query参数联动撤销',
                        atomicFunc: [
                          {
                            purpose: '已存在三个query项ABC,将A拖拽到BC中间,再将A拖拽到C下方,点击撤销按钮,顺序变为BAC,再次点击撤销按钮,顺序变为ABC,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格存在三个参数A,B,C(顺序为ABC)' }],
                            operationSteps: [
                              { id: '1', name: '拖拽参数A到B,C中间,顺序变为BAC' },
                              { id: '2', name: '拖拽参数A到C下方,顺序变为BCA' },
                              { id: '3', name: '点击撤销按钮' },
                              { id: '4', name: '再次点击撤销按钮' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次撤销后顺序恢复为BAC' },
                              { id: '2', name: '第二次撤销后顺序恢复为ABC' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '每次拖拽操作记录到操作历史栈' }],
                            notes: [{ id: '1', name: '拖拽调整顺序操作可以撤销' }],
                          },
                          {
                            purpose: '已存在三个query项ABC,将A拖拽到BC中间,再将A拖拽到C下方,按ctrl+z,顺序变为BAC,再次按ctrl+z,顺序变为ABC,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格存在三个参数A,B,C(顺序为ABC)' }],
                            operationSteps: [
                              { id: '1', name: '拖拽参数A到B,C中间,顺序变为BAC' },
                              { id: '2', name: '拖拽参数A到C下方,顺序变为BCA' },
                              { id: '3', name: '按ctrl+z快捷键' },
                              { id: '4', name: '再次按ctrl+z快捷键' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后顺序恢复为BAC' },
                              { id: '2', name: '第二次按快捷键后顺序恢复为ABC' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '快捷键撤销拖拽操作' }],
                            notes: [{ id: '1', name: '快捷键与撤销按钮行为一致' }],
                          },
                        ],
                      },
                      {
                        modelName: 'query参数key撤销',
                        description: 'query参数key撤销',
                        atomicFunc: [
                          {
                            purpose: 'query参数key没有值并且处于末尾,在key中输入字符串ab,按ctrl+z,取消选中next输入项选中状态,再按ctrl+z,删除next输入项并且当前key输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格末尾存在空输入行' }],
                            operationSteps: [
                              { id: '1', name: '在末尾空行的key输入框输入字符a' },
                              { id: '2', name: '继续输入字符b,key值为ab,自动选中next输入项' },
                              { id: '3', name: '按ctrl+z快捷键' },
                              { id: '4', name: '再次按ctrl+z快捷键' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后取消next输入项选中状态' },
                              { id: '2', name: '第二次按快捷键后删除next输入项且key输入框值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: 'key输入触发自动添加next输入行,记录操作历史' }],
                            notes: [{ id: '1', name: '末尾输入key时会自动添加下一行输入框' }],
                          },
                          {
                            purpose: 'query参数key存在值,在key中输入字符串ab,按ctrl+z, 输入框值为a,再按ctrl+z,key输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中间行key值为空' }],
                            operationSteps: [
                              { id: '1', name: '在中间行key输入框输入字符a' },
                              { id: '2', name: '继续输入字符b,key值为ab' },
                              { id: '3', name: '按ctrl+z快捷键' },
                              { id: '4', name: '再次按ctrl+z快捷键' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后key值为a' },
                              { id: '2', name: '第二次按快捷键后key值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '每个字符输入记录为独立操作' }],
                            notes: [{ id: '1', name: '中间行输入不会触发添加next输入项' }],
                          },
                          {
                            purpose: 'query参数key没有值并且处于末尾,在key中输入字符串ab,按撤销按钮,取消选中next输入项选中状态,再按撤销按钮,删除next输入项并且当前key输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格末尾存在空输入行' }],
                            operationSteps: [
                              { id: '1', name: '在末尾空行的key输入框输入字符a' },
                              { id: '2', name: '继续输入字符b,key值为ab,自动选中next输入项' },
                              { id: '3', name: '点击撤销按钮' },
                              { id: '4', name: '再次点击撤销按钮' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次点击撤销后取消next输入项选中状态' },
                              { id: '2', name: '第二次点击撤销后删除next输入项且key输入框值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '撤销按钮与快捷键共享同一操作历史栈' }],
                            notes: [{ id: '1', name: '撤销按钮行为与快捷键一致' }],
                          },
                          {
                            purpose: 'query参数key存在值,在key中输入字符串ab,按撤销按钮, 输入框值为a,再按撤销按钮,key输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中间行key值为空' }],
                            operationSteps: [
                              { id: '1', name: '在中间行key输入框输入字符a' },
                              { id: '2', name: '继续输入字符b,key值为ab' },
                              { id: '3', name: '点击撤销按钮' },
                              { id: '4', name: '再次点击撤销按钮' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次点击撤销后key值为a' },
                              { id: '2', name: '第二次点击撤销后key值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '撤销按钮撤销文本输入操作' }],
                            notes: [{ id: '1', name: '撤销按钮与快捷键行为一致' }],
                          },
                        ],
                      },
                      {
                        modelName: 'query参数value撤销',
                        description: 'query参数value撤销',
                        atomicFunc: [
                          {
                            purpose: 'path参数在value中输入字符串ab,按ctrl+z,当前value输入框值为a,再按ctrl+z,当前value输入框值为空字符串,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,path参数表格中存在一行参数' }],
                            operationSteps: [
                              { id: '1', name: '在value输入框输入字符a' },
                              { id: '2', name: '继续输入字符b,value值为ab' },
                              { id: '3', name: '按ctrl+z快捷键' },
                              { id: '4', name: '再次按ctrl+z快捷键' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后value值为a' },
                              { id: '2', name: '第二次按快捷键后value值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '每个字符输入记录为独立操作' }],
                            notes: [{ id: '1', name: '文本输入撤销功能正常' }],
                          },
                          {
                            purpose: 'path参数value输入字符串a,输入@唤起变量框选择mock字段,按ctrl+z, 输入框值为a,再按ctrl+z,value输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,path参数表格中存在一行参数' }],
                            operationSteps: [
                              { id: '1', name: '在value输入框输入字符a' },
                              { id: '2', name: '输入@符号唤起变量框' },
                              { id: '3', name: '选择mock字段' },
                              { id: '4', name: '按ctrl+z快捷键' },
                              { id: '5', name: '再次按ctrl+z快捷键' },
                              { id: '6', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后value值为a(取消mock选择)' },
                              { id: '2', name: '第二次按快捷键后value值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '变量选择操作记录到操作历史栈' }],
                            notes: [{ id: '1', name: '变量选择可以撤销' }],
                          },
                          {
                            purpose: 'path参数value输入字符串a,输入@唤起变量框选择变量字段,按ctrl+z, 输入框值为a,再按ctrl+z,value输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数' }],
                            operationSteps: [
                              { id: '1', name: '在value输入框输入字符a' },
                              { id: '2', name: '输入@符号唤起变量框' },
                              { id: '3', name: '选择变量字段' },
                              { id: '4', name: '按ctrl+z快捷键' },
                              { id: '5', name: '再次按ctrl+z快捷键' },
                              { id: '6', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后value值为a(取消变量选择)' },
                              { id: '2', name: '第二次按快捷键后value值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '变量选择操作记录到操作历史栈' }],
                            notes: [{ id: '1', name: '变量选择撤销功能正常' }],
                          },
                          {
                            purpose: 'path参数在value中输入字符串ab,点击撤销按钮,当前value输入框值为a,再点击撤销按钮,当前value输入框值为空字符串,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数' }],
                            operationSteps: [
                              { id: '1', name: '在value输入框输入字符a' },
                              { id: '2', name: '继续输入字符b,value值为ab' },
                              { id: '3', name: '点击撤销按钮' },
                              { id: '4', name: '再次点击撤销按钮' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次点击撤销后value值为a' },
                              { id: '2', name: '第二次点击撤销后value值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '撤销按钮与快捷键共享操作历史栈' }],
                            notes: [{ id: '1', name: '撤销按钮与快捷键行为一致' }],
                          },
                          {
                            purpose: 'path参数value输入字符串a,输入@唤起变量框选择mock字段,点击撤销按钮, 输入框值为a,再点击撤销按钮,value输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数' }],
                            operationSteps: [
                              { id: '1', name: '在value输入框输入字符a' },
                              { id: '2', name: '输入@符号唤起变量框' },
                              { id: '3', name: '选择mock字段' },
                              { id: '4', name: '点击撤销按钮' },
                              { id: '5', name: '再次点击撤销按钮' },
                              { id: '6', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次点击撤销后value值为a(取消mock选择)' },
                              { id: '2', name: '第二次点击撤销后value值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '撤销按钮撤销变量选择' }],
                            notes: [{ id: '1', name: '按钮与快捷键行为一致' }],
                          },
                          {
                            purpose: 'path参数value输入字符串a,输入@唤起变量框选择变量字段,点击撤销按钮, 输入框值为a,再点击撤销按钮,value输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数' }],
                            operationSteps: [
                              { id: '1', name: '在value输入框输入字符a' },
                              { id: '2', name: '输入@符号唤起变量框' },
                              { id: '3', name: '选择变量字段' },
                              { id: '4', name: '点击撤销按钮' },
                              { id: '5', name: '再次点击撤销按钮' },
                              { id: '6', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次点击撤销后value值为a(取消变量选择)' },
                              { id: '2', name: '第二次点击撤销后value值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '撤销按钮撤销变量选择操作' }],
                            notes: [{ id: '1', name: '撤销按钮与快捷键功能一致' }],
                          },
                        ],
                      },
                      {
                        modelName: 'query参数description撤销',
                        description: 'query参数description撤销',
                        atomicFunc: [
                          {
                            purpose: 'path在description中输入字符串ab,按ctrl+z, 输入框值为a,再按ctrl+z,description输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数' }],
                            operationSteps: [
                              { id: '1', name: '在description输入框输入字符a' },
                              { id: '2', name: '继续输入字符b,description值为ab' },
                              { id: '3', name: '按ctrl+z快捷键' },
                              { id: '4', name: '再次按ctrl+z快捷键' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后description值为a' },
                              { id: '2', name: '第二次按快捷键后description值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '每个字符输入记录为独立操作' }],
                            notes: [{ id: '1', name: '文本输入撤销功能正常' }],
                          },
                          {
                            purpose: 'path在description中输入字符串ab,按撤销按钮,输入框值为a,再按撤销按钮,description输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数' }],
                            operationSteps: [
                              { id: '1', name: '在description输入框输入字符a' },
                              { id: '2', name: '继续输入字符b,description值为ab' },
                              { id: '3', name: '点击撤销按钮' },
                              { id: '4', name: '再次点击撤销按钮' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次点击撤销后description值为a' },
                              { id: '2', name: '第二次点击撤销后description值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '撤销按钮与快捷键共享操作历史栈' }],
                            notes: [{ id: '1', name: '撤销按钮与快捷键行为一致' }],
                          },
                        ],
                      },
                      {
                        modelName: 'query参数必有checkbox撤销',
                        description: 'query参数必有checkbox撤销',
                        atomicFunc: [
                          {
                            purpose: '取消勾选path参数必有选项,再次勾选path参数必有选项,按ctrl+z, 必有选项未被勾选,再按ctrl+z,必有选项被勾选,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数,必有选项初始为勾选状态' }],
                            operationSteps: [
                              { id: '1', name: '点击必有checkbox取消勾选' },
                              { id: '2', name: '再次点击必有checkbox勾选' },
                              { id: '3', name: '按ctrl+z快捷键' },
                              { id: '4', name: '再次按ctrl+z快捷键' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后必有选项恢复为未勾选' },
                              { id: '2', name: '第二次按快捷键后必有选项恢复为勾选' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: 'checkbox勾选状态变化记录到操作历史栈' }],
                            notes: [{ id: '1', name: 'checkbox操作可以撤销' }],
                          },
                          {
                            purpose: '取消勾选path参数必有选项,再次勾选path参数必有选项,按撤销按钮, 必有选项未被勾选,再按撤销按钮,必有选项被勾选,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数,必有选项初始为勾选状态' }],
                            operationSteps: [
                              { id: '1', name: '点击必有checkbox取消勾选' },
                              { id: '2', name: '再次点击必有checkbox勾选' },
                              { id: '3', name: '点击撤销按钮' },
                              { id: '4', name: '再次点击撤销按钮' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次点击撤销后必有选项恢复为未勾选' },
                              { id: '2', name: '第二次点击撤销后必有选项恢复为勾选' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '撤销按钮与快捷键共享操作历史栈' }],
                            notes: [{ id: '1', name: '撤销按钮与快捷键行为一致' }],
                          },
                        ],
                      },
                      {
                        modelName: 'query参数是否发送checkbox撤销',
                        description: 'query参数是否发送checkbox撤销',
                        atomicFunc: [
                          {
                            purpose: '取消勾选path参数是否发送,再次勾选path参数是否发送,按ctrl+z, 是否发送未被勾选,再按ctrl+z,是否发送被勾选,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数,是否发送选项初始为勾选状态' }],
                            operationSteps: [
                              { id: '1', name: '点击是否发送checkbox取消勾选' },
                              { id: '2', name: '再次点击是否发送checkbox勾选' },
                              { id: '3', name: '按ctrl+z快捷键' },
                              { id: '4', name: '再次按ctrl+z快捷键' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后是否发送恢复为未勾选' },
                              { id: '2', name: '第二次按快捷键后是否发送恢复为勾选' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: 'checkbox勾选状态变化记录到操作历史栈' }],
                            notes: [{ id: '1', name: 'checkbox操作可以撤销' }],
                          },
                          {
                            purpose: '取消勾选path参数是否发送,再次勾选path参数是否发送,按撤销按钮, 是否发送未被勾选,再按撤销按钮,是否发送被勾选,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数,是否发送选项初始为勾选状态' }],
                            operationSteps: [
                              { id: '1', name: '点击是否发送checkbox取消勾选' },
                              { id: '2', name: '再次点击是否发送checkbox勾选' },
                              { id: '3', name: '点击撤销按钮' },
                              { id: '4', name: '再次点击撤销按钮' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次点击撤销后是否发送恢复为未勾选' },
                              { id: '2', name: '第二次点击撤销后是否发送恢复为勾选' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '撤销按钮与快捷键共享操作历史栈' }],
                            notes: [{ id: '1', name: '撤销按钮与快捷键行为一致' }],
                          },
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'path参数撤销',
                    description: 'path参数撤销',
                    children: [
                      {
                        modelName: 'url与path参数联动撤销',
                        description: 'url与path参数联动撤销',
                        atomicFunc: [
                          {
                            purpose: '请求url中粘贴http://demo.com/user{id},blur后,点击撤销按钮,删除path参数,再次点击撤销按钮,url值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,url输入框为空' }],
                            operationSteps: [
                              { id: '1', name: '在url输入框粘贴http://demo.com/user{id}' },
                              { id: '2', name: '失焦(blur)触发url解析,path参数自动提取到path参数表格' },
                              { id: '3', name: '点击撤销按钮' },
                              { id: '4', name: '再次点击撤销按钮' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次撤销后path参数表格清空,url恢复为http://demo.com/user{id}' },
                              { id: '2', name: '第二次撤销后url值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: 'url blur事件触发path参数解析并记录操作历史' }],
                            notes: [{ id: '1', name: 'url与path参数联动,blur时自动解析path参数' }],
                          },
                          {
                            purpose: '请求url中粘贴http://demo.com/user{id},blur后,点击ctrl+z,删除path参数,再次按ctrl+z,url值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,url输入框为空' }],
                            operationSteps: [
                              { id: '1', name: '在url输入框粘贴http://demo.com/user{id}' },
                              { id: '2', name: '失焦(blur)触发url解析,path参数自动提取到path参数表格' },
                              { id: '3', name: '按ctrl+z快捷键' },
                              { id: '4', name: '再次按ctrl+z快捷键' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后path参数表格清空,url恢复为http://demo.com/user{id}' },
                              { id: '2', name: '第二次按快捷键后url值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '快捷键撤销url解析操作' }],
                            notes: [{ id: '1', name: '快捷键撤销与按钮行为一致' }],
                          },
                        ],
                      },
                      {
                        modelName: 'path参数拖拽撤销',
                        description: 'path参数拖拽撤销',
                        atomicFunc: [
                          {
                            purpose: '已存在三个path项ABC,将A拖拽到BC中间,再将A拖拽到C下方,点击撤销按钮,顺序变为BAC,再次点击撤销按钮,顺序变为ABC,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,path参数表格存在三个参数A,B,C(顺序为ABC)' }],
                            operationSteps: [
                              { id: '1', name: '拖拽参数A到B,C中间,顺序变为BAC' },
                              { id: '2', name: '拖拽参数A到C下方,顺序变为BCA' },
                              { id: '3', name: '点击撤销按钮' },
                              { id: '4', name: '再次点击撤销按钮' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次撤销后顺序恢复为BAC' },
                              { id: '2', name: '第二次撤销后顺序恢复为ABC' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '每次拖拽操作记录到操作历史栈' }],
                            notes: [{ id: '1', name: '拖拽调整顺序操作可以撤销' }],
                          },
                          {
                            purpose: '已存在三个path项ABC,将A拖拽到BC中间,再将A拖拽到C下方,按ctrl+z,顺序变为BAC,再次按ctrl+z,顺序变为ABC,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,path参数表格存在三个参数A,B,C(顺序为ABC)' }],
                            operationSteps: [
                              { id: '1', name: '拖拽参数A到B,C中间,顺序变为BAC' },
                              { id: '2', name: '拖拽参数A到C下方,顺序变为BCA' },
                              { id: '3', name: '按ctrl+z快捷键' },
                              { id: '4', name: '再次按ctrl+z快捷键' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后顺序恢复为BAC' },
                              { id: '2', name: '第二次按快捷键后顺序恢复为ABC' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '快捷键撤销拖拽操作' }],
                            notes: [{ id: '1', name: '快捷键与撤销按钮行为一致' }],
                          },
                        ],
                      },
                      {
                        modelName: 'path参数key撤销',
                        description: 'path参数key撤销',
                        atomicFunc: [
                          {
                            purpose: 'path参数key没有值并且处于末尾,在key中输入字符串ab,按ctrl+z,取消选中next输入项选中状态,再按ctrl+z,删除next输入项并且当前key输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,path参数表格末尾存在空输入行' }],
                            operationSteps: [
                              { id: '1', name: '在末尾空行的key输入框输入字符a' },
                              { id: '2', name: '继续输入字符b,key值为ab,自动选中next输入项' },
                              { id: '3', name: '按ctrl+z快捷键' },
                              { id: '4', name: '再次按ctrl+z快捷键' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后取消next输入项选中状态' },
                              { id: '2', name: '第二次按快捷键后删除next输入项且key输入框值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: 'key输入触发自动添加next输入行,记录操作历史' }],
                            notes: [{ id: '1', name: '末尾输入key时会自动添加下一行输入框' }],
                          },
                          {
                            purpose: 'path参数key存在值,在key中输入字符串ab,按ctrl+z, 输入框值为a,再按ctrl+z,key输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,path参数表格中间行key值为空' }],
                            operationSteps: [
                              { id: '1', name: '在中间行key输入框输入字符a' },
                              { id: '2', name: '继续输入字符b,key值为ab' },
                              { id: '3', name: '按ctrl+z快捷键' },
                              { id: '4', name: '再次按ctrl+z快捷键' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后key值为a' },
                              { id: '2', name: '第二次按快捷键后key值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '每个字符输入记录为独立操作' }],
                            notes: [{ id: '1', name: '中间行输入不会触发添加next输入项' }],
                          },
                          {
                            purpose: 'path参数key没有值并且处于末尾,在key中输入字符串ab,按撤销按钮,取消选中next输入项选中状态,再按撤销按钮,删除next输入项并且当前key输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,path参数表格末尾存在空输入行' }],
                            operationSteps: [
                              { id: '1', name: '在末尾空行的key输入框输入字符a' },
                              { id: '2', name: '继续输入字符b,key值为ab,自动选中next输入项' },
                              { id: '3', name: '点击撤销按钮' },
                              { id: '4', name: '再次点击撤销按钮' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次点击撤销后取消next输入项选中状态' },
                              { id: '2', name: '第二次点击撤销后删除next输入项且key输入框值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '撤销按钮与快捷键共享同一操作历史栈' }],
                            notes: [{ id: '1', name: '撤销按钮行为与快捷键一致' }],
                          },
                          {
                            purpose: 'path参数key存在值,在key中输入字符串ab,按撤销按钮, 输入框值为a,再按撤销按钮,key输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,path参数表格中间行key值为空' }],
                            operationSteps: [
                              { id: '1', name: '在中间行key输入框输入字符a' },
                              { id: '2', name: '继续输入字符b,key值为ab' },
                              { id: '3', name: '点击撤销按钮' },
                              { id: '4', name: '再次点击撤销按钮' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次点击撤销后key值为a' },
                              { id: '2', name: '第二次点击撤销后key值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '撤销按钮撤销文本输入操作' }],
                            notes: [{ id: '1', name: '撤销按钮与快捷键行为一致' }],
                          },
                        ],
                      },
                      {
                        modelName: 'query参数value撤销',
                        description: 'query参数value撤销',
                        atomicFunc: [
                          {
                            purpose: 'path参数在value中输入字符串ab,按ctrl+z,当前value输入框值为a,再按ctrl+z,当前value输入框值为空字符串,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,path参数表格中存在一行参数' }],
                            operationSteps: [
                              { id: '1', name: '在value输入框输入字符a' },
                              { id: '2', name: '继续输入字符b,value值为ab' },
                              { id: '3', name: '按ctrl+z快捷键' },
                              { id: '4', name: '再次按ctrl+z快捷键' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后value值为a' },
                              { id: '2', name: '第二次按快捷键后value值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '每个字符输入记录为独立操作' }],
                            notes: [{ id: '1', name: '文本输入撤销功能正常' }],
                          },
                          {
                            purpose: 'path参数value输入字符串a,输入@唤起变量框选择mock字段,按ctrl+z, 输入框值为a,再按ctrl+z,value输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,path参数表格中存在一行参数' }],
                            operationSteps: [
                              { id: '1', name: '在value输入框输入字符a' },
                              { id: '2', name: '输入@符号唤起变量框' },
                              { id: '3', name: '选择mock字段' },
                              { id: '4', name: '按ctrl+z快捷键' },
                              { id: '5', name: '再次按ctrl+z快捷键' },
                              { id: '6', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后value值为a(取消mock选择)' },
                              { id: '2', name: '第二次按快捷键后value值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '变量选择操作记录到操作历史栈' }],
                            notes: [{ id: '1', name: '变量选择可以撤销' }],
                          },
                          {
                            purpose: 'path参数value输入字符串a,输入@唤起变量框选择变量字段,按ctrl+z, 输入框值为a,再按ctrl+z,value输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数' }],
                            operationSteps: [
                              { id: '1', name: '在value输入框输入字符a' },
                              { id: '2', name: '输入@符号唤起变量框' },
                              { id: '3', name: '选择变量字段' },
                              { id: '4', name: '按ctrl+z快捷键' },
                              { id: '5', name: '再次按ctrl+z快捷键' },
                              { id: '6', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后value值为a(取消变量选择)' },
                              { id: '2', name: '第二次按快捷键后value值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '变量选择操作记录到操作历史栈' }],
                            notes: [{ id: '1', name: '变量选择撤销功能正常' }],
                          },
                          {
                            purpose: 'path参数在value中输入字符串ab,点击撤销按钮,当前value输入框值为a,再点击撤销按钮,当前value输入框值为空字符串,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数' }],
                            operationSteps: [
                              { id: '1', name: '在value输入框输入字符a' },
                              { id: '2', name: '继续输入字符b,value值为ab' },
                              { id: '3', name: '点击撤销按钮' },
                              { id: '4', name: '再次点击撤销按钮' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次点击撤销后value值为a' },
                              { id: '2', name: '第二次点击撤销后value值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '撤销按钮与快捷键共享操作历史栈' }],
                            notes: [{ id: '1', name: '撤销按钮与快捷键行为一致' }],
                          },
                          {
                            purpose: 'path参数value输入字符串a,输入@唤起变量框选择mock字段,点击撤销按钮, 输入框值为a,再点击撤销按钮,value输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数' }],
                            operationSteps: [
                              { id: '1', name: '在value输入框输入字符a' },
                              { id: '2', name: '输入@符号唤起变量框' },
                              { id: '3', name: '选择mock字段' },
                              { id: '4', name: '点击撤销按钮' },
                              { id: '5', name: '再次点击撤销按钮' },
                              { id: '6', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次点击撤销后value值为a(取消mock选择)' },
                              { id: '2', name: '第二次点击撤销后value值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '撤销按钮撤销变量选择' }],
                            notes: [{ id: '1', name: '按钮与快捷键行为一致' }],
                          },
                          {
                            purpose: 'path参数value输入字符串a,输入@唤起变量框选择变量字段,点击撤销按钮, 输入框值为a,再点击撤销按钮,value输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数' }],
                            operationSteps: [
                              { id: '1', name: '在value输入框输入字符a' },
                              { id: '2', name: '输入@符号唤起变量框' },
                              { id: '3', name: '选择变量字段' },
                              { id: '4', name: '点击撤销按钮' },
                              { id: '5', name: '再次点击撤销按钮' },
                              { id: '6', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次点击撤销后value值为a(取消变量选择)' },
                              { id: '2', name: '第二次点击撤销后value值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '撤销按钮撤销变量选择操作' }],
                            notes: [{ id: '1', name: '撤销按钮与快捷键功能一致' }],
                          },
                        ],
                      },
                      {
                        modelName: 'query参数description撤销',
                        description: 'query参数description撤销',
                        atomicFunc: [
                          {
                            purpose: 'path在description中输入字符串ab,按ctrl+z, 输入框值为a,再按ctrl+z,description输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数' }],
                            operationSteps: [
                              { id: '1', name: '在description输入框输入字符a' },
                              { id: '2', name: '继续输入字符b,description值为ab' },
                              { id: '3', name: '按ctrl+z快捷键' },
                              { id: '4', name: '再次按ctrl+z快捷键' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后description值为a' },
                              { id: '2', name: '第二次按快捷键后description值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '每个字符输入记录为独立操作' }],
                            notes: [{ id: '1', name: '文本输入撤销功能正常' }],
                          },
                          {
                            purpose: 'path在description中输入字符串ab,按撤销按钮,输入框值为a,再按撤销按钮,description输入框值为空,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数' }],
                            operationSteps: [
                              { id: '1', name: '在description输入框输入字符a' },
                              { id: '2', name: '继续输入字符b,description值为ab' },
                              { id: '3', name: '点击撤销按钮' },
                              { id: '4', name: '再次点击撤销按钮' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次点击撤销后description值为a' },
                              { id: '2', name: '第二次点击撤销后description值为空' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '撤销按钮与快捷键共享操作历史栈' }],
                            notes: [{ id: '1', name: '撤销按钮与快捷键行为一致' }],
                          },
                        ],
                      },
                      {
                        modelName: 'query参数必有checkbox撤销',
                        description: 'query参数必有checkbox撤销',
                        atomicFunc: [
                          {
                            purpose: '取消勾选path参数必有选项,再次勾选path参数必有选项,按ctrl+z, 必有选项未被勾选,再按ctrl+z,必有选项被勾选,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数,必有选项初始为勾选状态' }],
                            operationSteps: [
                              { id: '1', name: '点击必有checkbox取消勾选' },
                              { id: '2', name: '再次点击必有checkbox勾选' },
                              { id: '3', name: '按ctrl+z快捷键' },
                              { id: '4', name: '再次按ctrl+z快捷键' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后必有选项恢复为未勾选' },
                              { id: '2', name: '第二次按快捷键后必有选项恢复为勾选' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: 'checkbox勾选状态变化记录到操作历史栈' }],
                            notes: [{ id: '1', name: 'checkbox操作可以撤销' }],
                          },
                          {
                            purpose: '取消勾选path参数必有选项,再次勾选path参数必有选项,按撤销按钮, 必有选项未被勾选,再按撤销按钮,必有选项被勾选,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数,必有选项初始为勾选状态' }],
                            operationSteps: [
                              { id: '1', name: '点击必有checkbox取消勾选' },
                              { id: '2', name: '再次点击必有checkbox勾选' },
                              { id: '3', name: '点击撤销按钮' },
                              { id: '4', name: '再次点击撤销按钮' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次点击撤销后必有选项恢复为未勾选' },
                              { id: '2', name: '第二次点击撤销后必有选项恢复为勾选' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '撤销按钮与快捷键共享操作历史栈' }],
                            notes: [{ id: '1', name: '撤销按钮与快捷键行为一致' }],
                          },
                        ],
                      },
                      {
                        modelName: 'query参数是否发送checkbox撤销',
                        description: 'query参数是否发送checkbox撤销',
                        atomicFunc: [
                          {
                            purpose: '取消勾选path参数是否发送,再次勾选path参数是否发送,按ctrl+z, 是否发送未被勾选,再按ctrl+z,是否发送被勾选,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数,是否发送选项初始为勾选状态' }],
                            operationSteps: [
                              { id: '1', name: '点击是否发送checkbox取消勾选' },
                              { id: '2', name: '再次点击是否发送checkbox勾选' },
                              { id: '3', name: '按ctrl+z快捷键' },
                              { id: '4', name: '再次按ctrl+z快捷键' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次按快捷键后是否发送恢复为未勾选' },
                              { id: '2', name: '第二次按快捷键后是否发送恢复为勾选' },
                              { id: '3', name: '撤销按钮置灰不可点击,继续按ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: 'checkbox勾选状态变化记录到操作历史栈' }],
                            notes: [{ id: '1', name: 'checkbox操作可以撤销' }],
                          },
                          {
                            purpose: '取消勾选path参数是否发送,再次勾选path参数是否发送,按撤销按钮, 是否发送未被勾选,再按撤销按钮,是否发送被勾选,并且撤销按钮置灰不可点击,ctrl+z无反应',
                            precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数表格中存在一行参数,是否发送选项初始为勾选状态' }],
                            operationSteps: [
                              { id: '1', name: '点击是否发送checkbox取消勾选' },
                              { id: '2', name: '再次点击是否发送checkbox勾选' },
                              { id: '3', name: '点击撤销按钮' },
                              { id: '4', name: '再次点击撤销按钮' },
                              { id: '5', name: '尝试继续按ctrl+z' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一次点击撤销后是否发送恢复为未勾选' },
                              { id: '2', name: '第二次点击撤销后是否发送恢复为勾选' },
                              { id: '3', name: '撤销按钮置灰不可点击,ctrl+z无反应' },
                            ],
                            checkpoints: [{ id: '1', name: '撤销按钮与快捷键共享操作历史栈' }],
                            notes: [{ id: '1', name: '撤销按钮与快捷键行为一致' }],
                          },
                        ],
                      },
                    ],
                  },
                ],
              },
              {
                modelName: '重做操作',
                description: '重做操作',
                children: [
                  {
                    modelName: '请求方法重做',
                    description: '请求方法重做',
                    atomicFunc: [
                      {
                        purpose: '切换请求方法两次后点击撤销按钮,再点击重做按钮,请求方法恢复到撤销前的状态',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,初始请求方法为GET' }],
                        operationSteps: [
                          { id: '1', name: '将请求方法切换为POST' },
                          { id: '2', name: '将请求方法切换为PUT' },
                          { id: '3', name: '点击撤销按钮' },
                          { id: '4', name: '点击重做按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '撤销后请求方法为POST' },
                          { id: '2', name: '重做后请求方法恢复为PUT' },
                        ],
                        checkpoints: [{ id: '1', name: '重做按钮依赖canRedo状态' }],
                        notes: [{ id: '1', name: '重做功能恢复上一次撤销的操作' }],
                      },
                      {
                        purpose: '切换请求方法两次后按ctrl+z,再按ctrl+shift+z,请求方法恢复到撤销前的状态',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,初始请求方法为GET' }],
                        operationSteps: [
                          { id: '1', name: '将请求方法切换为POST' },
                          { id: '2', name: '将请求方法切换为PUT' },
                          { id: '3', name: '按ctrl+z快捷键撤销' },
                          { id: '4', name: '按ctrl+shift+z快捷键重做' },
                        ],
                        expectedResults: [
                          { id: '1', name: '撤销后请求方法为POST' },
                          { id: '2', name: '重做后请求方法恢复为PUT' },
                        ],
                        checkpoints: [{ id: '1', name: '快捷键与按钮共享重做历史栈' }],
                        notes: [{ id: '1', name: 'ctrl+shift+z快捷键与重做按钮功能一致' }],
                      },
                    ],
                  },
                  {
                    modelName: '请求url重做',
                    description: '请求url重做',
                    atomicFunc: [
                      {
                        purpose: '请求url中输入字符串ab,按ctrl+z撤销到a,再按ctrl+shift+z重做,url值为ab',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,请求url为空' }],
                        operationSteps: [
                          { id: '1', name: '在url输入框中输入字符a' },
                          { id: '2', name: '继续输入字符b,url值变为ab' },
                          { id: '3', name: '按ctrl+z快捷键撤销' },
                          { id: '4', name: '按ctrl+shift+z快捷键重做' },
                        ],
                        expectedResults: [
                          { id: '1', name: '撤销后url值为a' },
                          { id: '2', name: '重做后url值恢复为ab' },
                        ],
                        checkpoints: [{ id: '1', name: 'url输入变更操作被记录到撤销栈中' }],
                        notes: [{ id: '1', name: '快捷键重做应恢复被撤销的输入' }],
                      },
                      {
                        purpose: '请求url中输入字符串ab,点击撤销按钮撤销到a,再点击重做按钮,url值为ab',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,请求url为空' }],
                        operationSteps: [
                          { id: '1', name: '在url输入框中输入字符a' },
                          { id: '2', name: '继续输入字符b,url值变为ab' },
                          { id: '3', name: '点击撤销按钮' },
                          { id: '4', name: '点击重做按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '撤销后url值为a' },
                          { id: '2', name: '重做后url值恢复为ab' },
                        ],
                        checkpoints: [{ id: '1', name: '撤销重做按钮与快捷键共享操作历史栈' }],
                        notes: [{ id: '1', name: '按钮操作与快捷键效果应一致' }],
                      },
                    ],
                  },
                  {
                    modelName: 'query参数重做',
                    description: 'query参数重做',
                    atomicFunc: [
                      {
                        purpose: 'query参数key输入值后撤销,再重做,值恢复到撤销前的状态',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数列表为空' }],
                        operationSteps: [
                          { id: '1', name: '点击添加query参数按钮' },
                          { id: '2', name: '在query参数key输入框中输入page' },
                          { id: '3', name: '点击撤销按钮' },
                          { id: '4', name: '点击重做按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '撤销后query参数key为空' },
                          { id: '2', name: '重做后query参数key值恢复为page' },
                        ],
                        checkpoints: [{ id: '1', name: 'query参数输入变更被记录到撤销栈中' }],
                        notes: [{ id: '1', name: '参数编辑的每次输入都应记录到操作历史' }],
                      },
                      {
                        purpose: 'query参数拖拽后撤销,再重做,顺序恢复到撤销前的状态',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,query参数中存在两个参数page和size' }],
                        operationSteps: [
                          { id: '1', name: '鼠标拖拽第一个query参数到第二个位置' },
                          { id: '2', name: '点击撤销按钮' },
                          { id: '3', name: '点击重做按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '拖拽后page和size的顺序互换' },
                          { id: '2', name: '撤销后顺序恢复为page,size' },
                          { id: '3', name: '重做后顺序恢复为size,page' },
                        ],
                        checkpoints: [{ id: '1', name: '拖拽操作被记录到撤销栈中' }],
                        notes: [{ id: '1', name: '顺序变更应可以通过撤销重做恢复' }],
                      },
                    ],
                  },
                  {
                    modelName: '重做边界情况',
                    description: '重做边界情况',
                    atomicFunc: [
                      {
                        purpose: '没有可重做的操作时,重做按钮置灰不可点击,ctrl+shift+z无反应',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,未进行任何撤销操作' }],
                        operationSteps: [
                          { id: '1', name: '观察重做按钮的状态' },
                          { id: '2', name: '尝试按ctrl+shift+z快捷键' },
                        ],
                        expectedResults: [
                          { id: '1', name: '重做按钮呈灰色禁用状态' },
                          { id: '2', name: 'ctrl+shift+z快捷键无响应,不执行任何操作' },
                        ],
                        checkpoints: [{ id: '1', name: '当canRedo为false时重做按钮应禁用' }],
                        notes: [{ id: '1', name: '边界情况:无可重做操作时的表现' }],
                      },
                      {
                        purpose: '撤销后进行新操作,重做历史被清空,重做按钮置灰不可点击',
                        precondition: [{ id: '1', name: '已打开httpNode节点编辑页面,请求方法为GET' }],
                        operationSteps: [
                          { id: '1', name: '将请求方法切换为POST' },
                          { id: '2', name: '点击撤销按钮,请求方法恢复为GET' },
                          { id: '3', name: '将请求方法切换为PUT(进行新操作)' },
                          { id: '4', name: '观察重做按钮状态' },
                        ],
                        expectedResults: [
                          { id: '1', name: '进行新操作后,重做历史栈被清空' },
                          { id: '2', name: '重做按钮变为灰色禁用状态' },
                          { id: '3', name: '无法再重做到POST状态,只能撤销到GET' },
                        ],
                        checkpoints: [{ id: '1', name: '新操作应清空重做历史栈,更新canRedo为false' }],
                        notes: [{ id: '1', name: '边界情况:撤销后新操作导致重做历史丢失' }],
                      },
                    ],
                  },
                ],
              },
              {
                modelName: '节点历史记录',
                description: '节点历史记录',
                atomicFunc: [
                  {
                    purpose: '点击历史记录按钮,展示当前节点的发送历史列表,列表按时间倒序排列',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: '该节点有多条历史请求记录(按时间顺序为A,B,C)' },
                    ],
                    operationSteps: [
                      { id: '1', name: '点击工具栏中的历史记录按钮' },
                      { id: '2', name: '观察历史记录列表的显示内容和顺序' },
                    ],
                    expectedResults: [
                      { id: '1', name: '历史记录弹窗或面板打开' },
                      { id: '2', name: '列表显示所有历史请求,按时间倒序排列(C在最上方,A在最下方)' },
                      { id: '3', name: '每条历史记录显示时间戳和请求概要信息' },
                    ],
                    checkpoints: [{ id: '1', name: '历史记录在IndexedDB中按时间戳排序' }],
                    notes: [{ id: '1', name: '列表应展示最近的请求在顶部' }],
                  },
                  {
                    purpose: '历史记录列表滚动到底部时自动加载更多历史记录',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: '该节点的历史记录数量超过50条(当前显示前50条)' },
                      { id: '3', name: '历史记录面板已打开' },
                    ],
                    operationSteps: [
                      { id: '1', name: '向下滚动历史记录列表至底部' },
                      { id: '2', name: '观察列表是否自动加载更多历史记录' },
                    ],
                    expectedResults: [
                      { id: '1', name: '滚动到底部时触发自动加载' },
                      { id: '2', name: '新的历史记录项自动追加到列表底部' },
                      { id: '3', name: '加载过程中显示加载提示或骨架屏' },
                    ],
                    checkpoints: [{ id: '1', name: '分页加载机制,默认50条为一页' }],
                    notes: [{ id: '1', name: '应使用虚拟滚动以优化大量历史记录的显示' }],
                  },
                  {
                    purpose: '历史记录支持搜索功能,输入关键字后过滤匹配的历史记录',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: '该节点有多条历史记录,url为/user/list,/user/detail,/user/delete' },
                      { id: '3', name: '历史记录面板已打开' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在搜索输入框中输入关键字detail' },
                      { id: '2', name: '观察历史记录列表的变化' },
                      { id: '3', name: '清空搜索输入框' },
                    ],
                    expectedResults: [
                      { id: '1', name: '输入关键字后,列表实时过滤出包含detail的历史记录' },
                      { id: '2', name: '仅显示/user/detail记录' },
                      { id: '3', name: '清空搜索后,列表恢复显示所有历史记录' },
                    ],
                    checkpoints: [{ id: '1', name: '搜索应支持url和请求方法的模糊匹配' }],
                    notes: [{ id: '1', name: '搜索应实时过滤,无需点击搜索按钮' }],
                  },
                  {
                    purpose: '点击刷新按钮重新加载历史记录列表',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: '历史记录面板已打开,显示旧的历史记录列表' },
                    ],
                    operationSteps: [
                      { id: '1', name: '点击历史记录面板中的刷新按钮' },
                      { id: '2', name: '观察历史记录列表是否更新' },
                    ],
                    expectedResults: [
                      { id: '1', name: '刷新按钮显示加载中状态(如旋转图标)' },
                      { id: '2', name: '列表重新从数据库加载最新的历史记录' },
                      { id: '3', name: '如果有新的请求,列表会显示新增的历史记录' },
                    ],
                    checkpoints: [{ id: '1', name: '刷新操作从IndexedDB重新查询最新数据' }],
                    notes: [{ id: '1', name: '刷新应清除当前的搜索和过滤条件' }],
                  },
                  {
                    purpose: '点击历史记录项可以查看该次请求的详细信息,包括请求参数,响应数据,时间戳',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: '历史记录面板已打开,列表中有多条历史记录' },
                    ],
                    operationSteps: [
                      { id: '1', name: '点击历史记录列表中的某条记录' },
                      { id: '2', name: '观察详细信息面板的显示内容' },
                    ],
                    expectedResults: [
                      { id: '1', name: '右侧显示该历史记录的详细信息面板' },
                      { id: '2', name: '面板显示请求参数(URL,方法,Headers,Body等)' },
                      { id: '3', name: '面板显示响应数据(状态码,Headers,Body等)' },
                      { id: '4', name: '面板显示请求的时间戳和响应耗时' },
                    ],
                    checkpoints: [{ id: '1', name: '历史记录详情来自IndexedDB中的完整记录' }],
                    notes: [{ id: '1', name: '应支持查看原始请求和响应的比对' }],
                  },
                  {
                    purpose: '节点没有历史记录时展示空状态提示',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: '该节点从未发送过任何请求,历史记录为空' },
                    ],
                    operationSteps: [
                      { id: '1', name: '点击历史记录按钮打开历史记录面板' },
                      { id: '2', name: '观察面板中的内容显示' },
                    ],
                    expectedResults: [
                      { id: '1', name: '历史记录面板打开' },
                      { id: '2', name: '显示空状态提示,如"暂无历史记录"或无数据提示图' },
                      { id: '3', name: '提示建议用户先发送请求以生成历史记录' },
                    ],
                    checkpoints: [{ id: '1', name: '空状态应显示合适的提示文案和图标' }],
                    notes: [{ id: '1', name: '空状态设计应符合UI规范,提升用户体验' }],
                  },
                ],
              },
              {
                modelName: '布局操作',
                description: '布局操作',
                atomicFunc: [
                  {
                    purpose: '点击水平布局按钮,请求区域和响应区域左右排列',
                    precondition: [
                      { id: '1', name: '已登录并打开任意项目工作区' },
                      { id: '2', name: '点击或新建一个HTTP请求节点进入编辑界面' },
                      { id: '3', name: '当前布局状态为垂直布局(上下排列)' },
                      { id: '4', name: 'projectWorkbenchStore.layout值为"vertical"' },
                    ],
                    operationSteps: [
                      { id: '1', name: '定位到HTTP节点参数编辑区域(Params.vue组件)顶部工具栏' },
                      { id: '2', name: '找到并点击带有LayoutGrid图标的"布局"下拉按钮(data-testid="http-params-layout-dropdown")' },
                      { id: '3', name: '在弹出的el-dropdown-menu下拉菜单中选择"左右布局"选项' },
                      { id: '4', name: '观察布局立即切换效果' },
                      { id: '5', name: '拖动中间的垂直分隔条验证可左右调节响应区域宽度' },
                      { id: '6', name: '双击垂直分隔条验证可重置响应区域宽度' },
                    ],
                    expectedResults: [
                      { id: '1', name: '布局立即从上下排列切换为左右排列,无需刷新页面' },
                      { id: '2', name: '请求编辑区域(包含URL输入框,Params/Headers/Body等tabs)固定显示在左侧,占据剩余宽度' },
                      { id: '3', name: '响应区域(Response组件)固定显示在右侧,初始宽度为500px或上次拖拽保存的宽度' },
                      { id: '4', name: '两个区域之间显示垂直分隔条(.request-layout的border-right样式)' },
                      { id: '5', name: '垂直分隔条可以左右拖拽,实时调整响应区域宽度,拖拽时显示宽度提示文字' },
                      { id: '6', name: '响应区域宽度范围限制在500px-750px之间,超出范围时分隔条无法继续拖动' },
                      { id: '7', name: '双击垂直分隔条后响应区域宽度重置为默认值' },
                      { id: '8', name: '"左右布局"菜单项文字显示主题色高亮(theme-color类名)' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'projectWorkbenchStore.layout响应式值为"horizontal"' },
                      { id: '2', name: 'localStorage["projectWorkbench/layout"]存储值为"horizontal"' },
                      { id: '3', name: 'HttpNode.vue中.apidoc容器不包含.vertical类名' },
                      { id: '4', name: 'HttpNode.vue中.request-layout容器不包含.vertical类名' },
                      { id: '5', name: 'HttpNode.vue条件渲染ClResizeX组件(v-if="layout === \'horizontal\'"为true)' },
                      { id: '6', name: 'HttpNode.vue不渲染ClResizeY组件(v-if="layout === \'vertical\'"为false)' },
                      { id: '7', name: 'ClResizeX组件props包含:min=500, max=750, width=500, bar-left=true, name="response"' },
                      { id: '8', name: '拖拽后的宽度值实时保存到localStorage["dragBar/response"]' },
                      { id: '9', name: '.apidoc容器CSS为display: flex(默认flex-direction: row)' },
                      { id: '10', name: '.request-layout右侧边框样式为border-right: 1px solid var(--gray-400)' },
                    ],
                    notes: [
                      { id: '1', name: '布局切换通过handleChangeLayout函数调用projectWorkbenchStore.changeLayout方法实现' },
                      { id: '2', name: '布局状态通过projectWorkbenchCache.setProjectWorkbenchLayout方法持久化到localStorage' },
                      { id: '3', name: '响应区域宽度由ClResizeX组件管理,拖拽宽度自动记忆' },
                      { id: '4', name: '重启应用或刷新页面后布局保持为水平布局' },
                      { id: '5', name: 'ClResizeX组件支持双击重置,实时宽度提示,记忆功能' },
                    ],
                  },
                  {
                    purpose: '点击垂直布局按钮,请求区域和响应区域上下排列',
                    precondition: [
                      { id: '1', name: '已登录并打开任意项目工作区' },
                      { id: '2', name: '点击或新建一个HTTP请求节点进入编辑界面' },
                      { id: '3', name: '当前布局状态为水平布局(左右排列)' },
                      { id: '4', name: 'projectWorkbenchStore.layout值为"horizontal"' },
                    ],
                    operationSteps: [
                      { id: '1', name: '定位到HTTP节点参数编辑区域(Params.vue组件)顶部工具栏' },
                      { id: '2', name: '找到并点击带有LayoutGrid图标的"布局"下拉按钮(data-testid="http-params-layout-dropdown")' },
                      { id: '3', name: '在弹出的el-dropdown-menu下拉菜单中选择"上下布局"选项' },
                      { id: '4', name: '观察布局立即切换效果' },
                      { id: '5', name: '拖动中间的水平分隔条验证可上下调节响应区域高度' },
                      { id: '6', name: '双击水平分隔条验证可重置响应区域高度' },
                    ],
                    expectedResults: [
                      { id: '1', name: '布局立即从左右排列切换为上下排列,无需刷新页面' },
                      { id: '2', name: '请求编辑区域(包含URL输入框,Params/Headers/Body等tabs)显示在上方,自适应高度并支持滚动' },
                      { id: '3', name: '响应区域(Response组件)显示在下方,初始高度为350px或上次拖拽保存的高度' },
                      { id: '4', name: '两个区域之间显示水平分隔条(.y-bar的border-top样式)' },
                      { id: '5', name: '水平分隔条可以上下拖拽,实时调整响应区域高度,拖拽时显示高度提示文字' },
                      { id: '6', name: '响应区域高度范围限制在100px-750px之间(ClResizeY的min和max属性),超出范围时分隔条无法继续拖动' },
                      { id: '7', name: '双击水平分隔条后响应区域高度重置为默认值350px' },
                      { id: '8', name: '"上下布局"菜单项文字显示主题色高亮(theme-color类名)' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'projectWorkbenchStore.layout响应式值为"vertical"' },
                      { id: '2', name: 'localStorage["projectWorkbench/layout"]存储值为"vertical"' },
                      { id: '3', name: 'HttpNode.vue中.apidoc容器包含.vertical类名' },
                      { id: '4', name: 'HttpNode.vue中.request-layout容器包含.vertical类名' },
                      { id: '5', name: 'HttpNode.vue条件渲染ClResizeY组件(v-if="layout === \'vertical\'"为true)' },
                      { id: '6', name: 'HttpNode.vue不渲染ClResizeX组件(v-if="layout === \'horizontal\'"为false)' },
                      { id: '7', name: 'ClResizeY组件props包含:min=100, max=750, height=responseHeight, default-height=350, name="response-y"' },
                      { id: '8', name: '拖拽触发heightChange事件,调用handleResponseHeightChange方法' },
                      { id: '9', name: 'projectWorkbenchStore.changeResponseHeight方法更新响应高度' },
                      { id: '10', name: 'appStateCache.setResponseHeight方法保存高度到localStorage["projectWorkbench/responseHeight"]' },
                      { id: '11', name: '.apidoc容器CSS包含flex-direction: column' },
                      { id: '12', name: '.apidoc容器CSS包含overflow: hidden(防止整体滚动)' },
                      { id: '13', name: '.request-layout的.vertical类样式包含flex: 1和overflow-y: auto(支持内部滚动)' },
                      { id: '14', name: '.y-bar顶部边框样式为border-top: 1px solid var(--gray-400)' },
                    ],
                    notes: [
                      { id: '1', name: '布局切换通过handleChangeLayout函数调用projectWorkbenchStore.changeLayout方法实现' },
                      { id: '2', name: '布局状态通过projectWorkbenchCache.setProjectWorkbenchLayout方法持久化到localStorage' },
                      { id: '3', name: '响应区域高度由ClResizeY组件管理,拖拽高度通过projectWorkbenchStore和appStateCache持久化' },
                      { id: '4', name: '垂直布局下请求区域支持overflow-y滚动,响应区域固定高度' },
                      { id: '5', name: '重启应用或刷新页面后布局保持为垂直布局,响应区域高度也保持' },
                      { id: '6', name: 'ClResizeY组件支持双击重置,实时高度提示,拖拽事件监听(dragStart/dragEnd)' },
                    ],
                  },
                  {
                    purpose: '切换布局后刷新页面,布局保持不变',
                    precondition: [
                      { id: '1', name: '已登录并打开任意项目工作区' },
                      { id: '2', name: '点击或新建一个HTTP请求节点进入编辑界面' },
                      { id: '3', name: '初始布局为水平布局' },
                    ],
                    operationSteps: [
                      { id: '1', name: '点击"布局"按钮,切换到"上下布局"' },
                      { id: '2', name: '验证布局已切换为垂直布局(请求区域在上,响应区域在下)' },
                      { id: '3', name: '按F5或点击浏览器刷新按钮刷新页面' },
                      { id: '4', name: '等待页面完全加载' },
                      { id: '5', name: '观察布局状态' },
                      { id: '6', name: '点击"布局"按钮,切换到"左右布局"' },
                      { id: '7', name: '验证布局已切换为水平布局(请求区域在左,响应区域在右)' },
                      { id: '8', name: '按F5或点击浏览器刷新按钮再次刷新页面' },
                      { id: '9', name: '等待页面完全加载' },
                      { id: '10', name: '观察布局状态' },
                    ],
                    expectedResults: [
                      { id: '1', name: '步骤3刷新后,布局保持为垂直布局(上下排列)' },
                      { id: '2', name: '步骤3刷新后,响应区域高度保持为上次拖拽的高度或默认350px' },
                      { id: '3', name: '步骤8刷新后,布局保持为水平布局(左右排列)' },
                      { id: '4', name: '步骤8刷新后,响应区域宽度保持为上次拖拽的宽度或默认500px' },
                      { id: '5', name: '刷新后布局菜单中对应选项保持主题色高亮状态' },
                      { id: '6', name: '页面刷新过程不会出现布局闪烁或错误的布局状态' },
                    ],
                    checkpoints: [
                      { id: '1', name: '垂直布局刷新后localStorage["projectWorkbench/layout"]值仍为"vertical"' },
                      { id: '2', name: '水平布局刷新后localStorage["projectWorkbench/layout"]值仍为"horizontal"' },
                      { id: '3', name: 'projectWorkbenchStore.initLayout方法在应用启动时被正确调用' },
                      { id: '4', name: 'initLayout方法通过projectWorkbenchCache.getProjectWorkbenchLayout从localStorage读取布局状态' },
                      { id: '5', name: 'HttpNode.vue的computed: layout正确响应projectWorkbenchStore.layout值' },
                      { id: '6', name: '垂直布局刷新后localStorage["projectWorkbench/responseHeight"]保持高度值' },
                      { id: '7', name: '水平布局刷新后localStorage["dragBar/response"]保持宽度值' },
                      { id: '8', name: 'appStateCache.getResponseHeight方法在垂直布局初始化时正确读取高度' },
                      { id: '9', name: 'ClResizeX/ClResizeY组件的记忆功能正确恢复拖拽尺寸' },
                      { id: '10', name: 'projectWorkbenchCache.getProjectWorkbenchLayout在localStorage值异常时返回默认值"horizontal"' },
                    ],
                    notes: [
                      { id: '1', name: '布局持久化依赖localStorage["projectWorkbench/layout"]存储' },
                      { id: '2', name: '应用启动时projectWorkbenchStore的setup中会调用initLayout初始化布局' },
                      { id: '3', name: 'projectWorkbenchCache提供容错处理:getProjectWorkbenchLayout方法会验证值合法性,非法时返回默认值"horizontal"' },
                      { id: '4', name: '响应区域尺寸也会持久化:垂直布局高度存储在"projectWorkbench/responseHeight",水平布局宽度存储在"dragBar/response"' },
                      { id: '5', name: 'ClResizeX和ClResizeY组件都支持name属性,用于在localStorage中区分不同拖拽条的记忆数据' },
                      { id: '6', name: '测试时应验证跨会话持久化:关闭应用重新打开,布局仍保持' },
                    ],
                  },
                  {
                    purpose: '不同布局模式下响应区域的按钮显示正确(水平布局显示详情按钮,垂直布局不显示)',
                    precondition: [
                      { id: '1', name: '已登录并打开任意项目工作区' },
                      { id: '2', name: '点击或新建一个HTTP请求节点进入编辑界面' },
                      { id: '3', name: '已发送过至少一次HTTP请求,响应区域有数据' },
                    ],
                    operationSteps: [
                      { id: '1', name: '确认当前布局为水平布局(左右排列)' },
                      { id: '2', name: '观察响应区域顶部是否显示BaseInfoView组件(基本信息)' },
                      { id: '3', name: '观察响应区域是否显示ResponseSummaryView组件(响应摘要:状态码,时长,大小,格式)' },
                      { id: '4', name: '点击布局按钮,切换到垂直布局(上下排列)' },
                      { id: '5', name: '观察响应区域顶部BaseInfoView组件是否隐藏' },
                      { id: '6', name: '观察ResponseSummaryView组件是否隐藏' },
                      { id: '7', name: '再次点击布局按钮,切换回水平布局' },
                      { id: '8', name: '验证BaseInfoView和ResponseSummaryView组件重新显示' },
                    ],
                    expectedResults: [
                      { id: '1', name: '水平布局模式下,BaseInfoView组件在响应区域顶部显示' },
                      { id: '2', name: 'BaseInfoView显示请求地址,请求方式,维护人员,创建人员,更新日期,创建日期' },
                      { id: '3', name: 'ResponseSummaryView组件在BaseInfoView下方显示' },
                      { id: '4', name: 'ResponseSummaryView显示状态码(绿色<300/橙色300-400/红色≥400),时长(绿色<2s/橙色2-5s/红色≥5s),大小(绿色<10KB/橙色10-15KB/红色≥15KB),格式(橙色显示contentType)' },
                      { id: '5', name: '垂直布局模式下,BaseInfoView组件通过v-show="layout === \'horizontal\'"条件隐藏,DOM存在但display:none' },
                      { id: '6', name: '垂直布局模式下,ResponseSummaryView组件通过v-show="layout === \'horizontal\'"条件隐藏,DOM存在但display:none' },
                      { id: '7', name: '垂直布局模式下,响应区域tabs直接显示,无基本信息和响应摘要' },
                      { id: '8', name: '切换回水平布局后,两个组件立即重新显示,数据保持不变' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'ResponseView.vue第2行:<SBaseInfoView v-show="layout === \'horizontal\'"></SBaseInfoView>' },
                      { id: '2', name: 'ResponseView.vue第3行:<SResponseSummaryView v-show="layout === \'horizontal\'"></SResponseSummaryView>' },
                      { id: '3', name: 'ResponseView.vue第83行:layout = computed(() => projectWorkbenchStore.layout)' },
                      { id: '4', name: 'BaseInfoView组件高度固定:height: var(--apiflow-apidoc-request-view-height)' },
                      { id: '5', name: 'ResponseSummaryView组件高度固定:height: var(--apiflow-response-summary-height)' },
                      { id: '6', name: '水平布局时,BaseInfoView的v-show="layout === \'horizontal\'"为true,组件可见' },
                      { id: '7', name: '水平布局时,ResponseSummaryView的v-show="layout === \'horizontal\'"为true,组件可见' },
                      { id: '8', name: '垂直布局时,BaseInfoView的v-show="layout === \'horizontal\'"为false,组件隐藏' },
                      { id: '9', name: '垂直布局时,ResponseSummaryView的v-show="layout === \'horizontal\'"为false,组件隐藏' },
                      { id: '10', name: 'BaseInfoView显示数据来自httpNodeStore.httpNodeInfo和httpNodeRequestStore.fullUrl' },
                      { id: '11', name: 'ResponseSummaryView显示数据来自httpNodeResponseStore.responseInfo' },
                      { id: '12', name: '响应摘要的颜色逻辑:状态码(<300绿色/300-400橙色/≥400红色),时长(<2s绿色/2-5s橙色/≥5s红色),大小(<10KB绿色/10-15KB橙色/≥15KB红色)' },
                    ],
                    notes: [
                      { id: '1', name: 'BaseInfoView和ResponseSummaryView都使用v-show指令,不是v-if,因此DOM节点始终存在,只是切换display属性' },
                      { id: '2', name: '这种设计避免了布局切换时重新渲染组件,提高性能' },
                      { id: '3', name: '垂直布局隐藏这两个组件是为了节省垂直空间,因为垂直布局下请求和响应上下排列,空间更紧张' },
                      { id: '4', name: 'BaseInfoView显示的是接口的元数据信息,对测试接口功能来说是次要信息' },
                      { id: '5', name: 'ResponseSummaryView显示的是响应的快速概览信息(状态码,时长等),但详细信息仍可在tabs中查看' },
                      { id: '6', name: '布局切换由projectWorkbenchStore.layout状态控制,通过computed响应式更新UI' },
                    ],
                  },
                ],
              },
              {
                modelName: '变量操作',
                description: '变量操作',
                children: [
                  {
                    modelName: '变量弹窗',
                    description: '变量弹窗',
                    atomicFunc: [
                      {
                        purpose: '点击变量按钮打开变量管理弹窗,弹窗展示当前项目的所有变量',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          '已在项目中创建多个变量',
                        ],
                        operationSteps: [
                          '1. 在HTTP节点编辑器工具栏中找到变量管理按钮',
                          '2. 点击变量管理按钮',
                          '3. 观察弹窗显示的内容',
                          '4. 检查弹窗中的变量列表',
                        ],
                        expectedResults: [
                          '弹窗正确打开',
                          '弹窗显示所有项目级别变量',
                          '变量列表显示变量名,类型,值',
                          '弹窗样式正确,易于阅读',
                          '弹窗包含新增,编辑,删除等按钮',
                        ],
                        checkpoints: [
                          '验证弹窗打开',
                          '验证变量列表完整',
                          '验证所有变量都显示',
                          '验证弹窗操作按钮可用',
                        ],
                        notes: [
                          '此测试验证变量管理弹窗的基本功能',
                        ],
                      },
                      {
                        purpose: '变量弹窗可以拖拽移动位置,关闭后再打开位置保持不变',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已打开变量管理弹窗',
                        ],
                        operationSteps: [
                          '1. 拖拽变量弹窗的标题栏移动窗口位置',
                          '2. 记录窗口的最终位置',
                          '3. 关闭变量弹窗',
                          '4. 再次点击变量按钮打开弹窗',
                          '5. 检查弹窗位置是否保持',
                        ],
                        expectedResults: [
                          '弹窗可以被正确拖拽',
                          '弹窗位置在拖拽后改变',
                          '关闭弹窗后位置被记忆',
                          '重新打开弹窗时位置保持不变',
                          '位置信息被保存在localStorage',
                        ],
                        checkpoints: [
                          '验证拖拽功能',
                          '验证位置记忆功能',
                          '验证页面刷新后位置保持',
                        ],
                        notes: [
                          '此测试验证弹窗的可拖拽和位置记忆功能',
                          '这提高了用户体验',
                        ],
                      },
                    ],
                  },
                  {
                    modelName: '变量增删改查',
                    description: '变量增删改查',
                    atomicFunc: [
                      {
                        purpose: '新增string类型变量,输入变量名和值后保存成功',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已打开变量管理弹窗',
                        ],
                        operationSteps: [
                          '1. 点击新增变量按钮',
                          '2. 选择变量类型为string',
                          '3. 输入变量名:testString',
                          '4. 输入变量值:hello world',
                          '5. 点击保存按钮',
                          '6. 检查变量是否添加到列表',
                        ],
                        expectedResults: [
                          '新增弹窗打开',
                          '可以选择string类型',
                          '变量名和值正确输入',
                          '保存成功',
                          '新增的变量显示在列表中',
                          '变量可以被正常使用',
                        ],
                        checkpoints: [
                          '验证变量添加成功',
                          '验证变量名正确',
                          '验证变量值正确',
                          '验证变量类型正确',
                        ],
                        notes: [
                          '此测试验证字符串类型变量的创建',
                        ],
                      },
                      {
                        purpose: '新增number类型变量,输入变量名和数字值后保存成功',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已打开变量管理弹窗',
                        ],
                        operationSteps: [
                          '1. 点击新增变量按钮',
                          '2. 选择变量类型为number',
                          '3. 输入变量名:testNumber',
                          '4. 输入数字值:12345',
                          '5. 点击保存按钮',
                          '6. 检查变量添加结果',
                        ],
                        expectedResults: [
                          '新增弹窗打开',
                          '可以选择number类型',
                          '数字值被正确解析',
                          '保存成功',
                          '新增的数字变量显示在列表',
                          '变量值显示为数字而非字符串',
                        ],
                        checkpoints: [
                          '验证number类型变量创建',
                          '验证数值类型识别',
                        ],
                        notes: [
                          '此测试验证数字类型变量的创建',
                        ],
                      },
                      {
                        purpose: '新增boolean类型变量,选择true或false后保存成功',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已打开变量管理弹窗',
                        ],
                        operationSteps: [
                          '1. 点击新增变量按钮',
                          '2. 选择变量类型为boolean',
                          '3. 输入变量名:testBool',
                          '4. 选择值为true',
                          '5. 点击保存按钮',
                          '6. 再添加一个false值的boolean变量验证',
                        ],
                        expectedResults: [
                          '新增弹窗打开',
                          '可以选择boolean类型',
                          '布尔值选择器可用',
                          'true和false都能正确保存',
                          '保存成功',
                          '变量显示在列表中',
                        ],
                        checkpoints: [
                          '验证boolean类型创建',
                          '验证true值保存',
                          '验证false值保存',
                        ],
                        notes: [
                          '此测试验证布尔类型变量的创建',
                        ],
                      },
                      {
                        purpose: '新增file类型变量,选择文件后保存成功',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已打开变量管理弹窗',
                          '系统中存在可上传的文件',
                        ],
                        operationSteps: [
                          '1. 点击新增变量按钮',
                          '2. 选择变量类型为file',
                          '3. 输入变量名:testFile',
                          '4. 点击选择文件',
                          '5. 选择一个本地文件',
                          '6. 点击保存按钮',
                        ],
                        expectedResults: [
                          '新增弹窗打开',
                          '可以选择file类型',
                          '文件选择器可用',
                          '文件被正确选择',
                          '保存成功',
                          '文件变量显示在列表中',
                        ],
                        checkpoints: [
                          '验证file类型创建',
                          '验证文件选择',
                          '验证文件信息保存',
                        ],
                        notes: [
                          '此测试验证文件类型变量的创建',
                        ],
                      },
                      {
                        purpose: '新增any类型变量,输入JavaScript表达式后保存成功',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已打开变量管理弹窗',
                        ],
                        operationSteps: [
                          '1. 点击新增变量按钮',
                          '2. 选择变量类型为any',
                          '3. 输入变量名:testAny',
                          '4. 输入JavaScript表达式:{name: "test", age: 20}',
                          '5. 点击保存按钮',
                          '6. 检查变量是否保存成功',
                        ],
                        expectedResults: [
                          '新增弹窗打开',
                          '可以选择any类型',
                          'JavaScript表达式被输入',
                          '表达式被保存',
                          '变量显示在列表中',
                          '表达式被正确解析和执行',
                        ],
                        checkpoints: [
                          '验证any类型创建',
                          '验证JavaScript执行',
                          '验证复杂对象保存',
                        ],
                        notes: [
                          '此测试验证any类型变量(复杂JavaScript对象)的创建',
                        ],
                      },
                      {
                        purpose: '变量名重复时提示错误,不允许保存',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已打开变量管理弹窗',
                          '已在项目中创建变量:testVar',
                        ],
                        operationSteps: [
                          '1. 点击新增变量按钮',
                          '2. 输入与已有变量相同的名称:testVar',
                          '3. 输入值',
                          '4. 尝试保存',
                          '5. 观察错误提示',
                        ],
                        expectedResults: [
                          '保存时显示错误提示',
                          '错误信息明确说明变量名重复',
                          '保存被阻止',
                          '变量未被添加到列表',
                          '弹窗仍保持打开状态',
                        ],
                        checkpoints: [
                          '验证重复名称检测',
                          '验证错误提示',
                          '验证保存被阻止',
                        ],
                        notes: [
                          '此测试验证变量名唯一性验证',
                        ],
                      },
                      {
                        purpose: '修改已存在变量的值,保存后变量值更新',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已打开变量管理弹窗',
                          '已在项目中创建变量:testVar=old_value',
                        ],
                        operationSteps: [
                          '1. 在变量列表中找到testVar变量',
                          '2. 点击编辑按钮',
                          '3. 修改变量值为:new_value',
                          '4. 点击保存按钮',
                          '5. 检查变量值是否更新',
                        ],
                        expectedResults: [
                          '编辑弹窗打开',
                          '原始值显示在表单中',
                          '值被正确修改',
                          '保存成功',
                          '列表中的变量值已更新',
                          '新值可以被使用',
                        ],
                        checkpoints: [
                          '验证编辑功能',
                          '验证值更新',
                          '验证新值生效',
                        ],
                        notes: [
                          '此测试验证变量的修改功能',
                        ],
                      },
                      {
                        purpose: '删除变量后,变量从列表中移除',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已打开变量管理弹窗',
                          '已在项目中创建变量:testVar',
                        ],
                        operationSteps: [
                          '1. 在变量列表中找到testVar变量',
                          '2. 点击删除按钮',
                          '3. 在确认对话框中确认删除',
                          '4. 检查变量是否被移除',
                          '5. 验证变量不能再被使用',
                        ],
                        expectedResults: [
                          '删除确认对话框显示',
                          '确认后变量被删除',
                          '变量从列表中移除',
                          '保存成功',
                          '删除后变量不可用',
                          '使用该变量会提示未定义',
                        ],
                        checkpoints: [
                          '验证删除功能',
                          '验证列表更新',
                          '验证变量不可用',
                        ],
                        notes: [
                          '此测试验证变量的删除功能',
                        ],
                      },
                    ],
                  },
                  {
                    modelName: '变量使用',
                    description: '变量使用',
                    atomicFunc: [
                      {
                        purpose: '在url中使用{{ 变量名 }}语法,发送请求时变量被正确替换',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          '已创建变量:baseUrl=https://api.example.com',
                          '已创建变量:apiPath=/api/users',
                        ],
                        operationSteps: [
                          '1. 在URL字段中输入:{{baseUrl}}{{apiPath}}',
                          '2. 点击发送请求',
                          '3. 查看请求信息中的URL',
                          '4. 验证变量是否被替换',
                        ],
                        expectedResults: [
                          '变量语法被正确识别',
                          '发送请求时变量被替换为实际值',
                          '最终URL为:https://api.example.com/api/users',
                          '请求信息中显示完整的URL',
                          '响应正确返回',
                        ],
                        checkpoints: [
                          '验证URL中的变量替换',
                          '验证多个变量的替换',
                          '验证URL编码正确',
                        ],
                        notes: [
                          '此测试验证URL中的变量替换功能',
                        ],
                      },
                      {
                        purpose: '在query参数value中使用变量,发送请求时变量被正确替换',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          '已创建变量:userId=12345',
                          '已创建变量:pageSize=20',
                        ],
                        operationSteps: [
                          '1. 在Query参数区域添加:id={{userId}}, limit={{pageSize}}',
                          '2. 点击发送请求',
                          '3. 查看请求URL中的参数',
                          '4. 验证变量是否被替换',
                        ],
                        expectedResults: [
                          'Query参数中的变量被识别',
                          '发送时变量被替换为实际值',
                          'URL显示为:?id=12345&limit=20',
                          '服务器接收到正确的参数值',
                          '响应正确返回',
                        ],
                        checkpoints: [
                          '验证Query参数中的变量替换',
                          '验证参数值的正确性',
                        ],
                        notes: [
                          '此测试验证Query参数中的变量替换功能',
                        ],
                      },
                      {
                        purpose: '在header参数value中使用变量,发送请求时变量被正确替换',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          '已创建变量:authToken=Bearer xyz123',
                          '已创建变量:apiKey=secret-key-value',
                        ],
                        operationSteps: [
                          '1. 在Header参数区域添加:Authorization={{authToken}}, X-API-Key={{apiKey}}',
                          '2. 点击发送请求',
                          '3. 查看请求头信息',
                          '4. 验证Header值是否被替换',
                        ],
                        expectedResults: [
                          'Header值中的变量被识别',
                          '发送时变量被替换为实际值',
                          'Header显示为:Authorization: Bearer xyz123, X-API-Key: secret-key-value',
                          '服务器接收到正确的头部值',
                          '响应正确返回',
                        ],
                        checkpoints: [
                          '验证Header中的变量替换',
                          '验证敏感信息(Token)正确传递',
                          '验证多个Header变量',
                        ],
                        notes: [
                          '此测试验证Header参数中的变量替换功能',
                        ],
                      },
                      {
                        purpose: '在body json中使用变量,发送请求时变量被正确替换',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          '已创建变量:userName=John, userAge=30',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body选择JSON类型',
                          '3. 输入JSON:{"name":"{{userName}}","age":"{{userAge}}"}',
                          '4. 点击发送请求',
                          '5. 查看请求body',
                        ],
                        expectedResults: [
                          'JSON中的变量被识别',
                          '发送时变量被替换为实际值',
                          'Body中显示为:{"name":"John","age":"30"}',
                          '服务器接收到正确的JSON数据',
                          '响应正确返回',
                        ],
                        checkpoints: [
                          '验证JSON Body中的变量替换',
                          '验证JSON格式正确',
                          '验证多个变量替换',
                        ],
                        notes: [
                          '此测试验证JSON Body中的变量替换功能',
                        ],
                      },
                      {
                        purpose: '使用不存在的变量时,变量提示未定义',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                        ],
                        operationSteps: [
                          '1. 在URL字段中输入:http://api.example.com/{{undefinedVar}}',
                          '2. 观察是否有警告提示',
                          '3. 尝试点击发送请求',
                          '4. 查看是否显示变量未定义的错误',
                        ],
                        expectedResults: [
                          '输入不存在的变量时显示警告',
                          '警告信息说明变量未定义',
                          '发送前或发送时显示错误提示',
                          '用户可以清楚地了解哪个变量未定义',
                          '阻止发送带有未定义变量的请求',
                        ],
                        checkpoints: [
                          '验证未定义变量的检测',
                          '验证错误提示的清晰性',
                          '验证请求被阻止',
                        ],
                        notes: [
                          '此测试验证变量未定义时的错误处理',
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
          // 请求参数录入区域
          {
            modelName: 'inputArea',
            description: '录入区域',
            children: [
              // query参数
              {
                modelName: 'query',
                description: 'Query参数',
                atomicFunc: [
                  {
                    purpose: 'query参数key输入值以后,如果不存在next节点,则自动新增一行数据,自动新增数据需要被选中',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: 'query参数表格中只有一行,且该行的key,value都为空' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在第一行query参数的key输入框中输入page' },
                      { id: '2', name: '点击key输入框外的区域使其失焦(或按Tab键)' },
                      { id: '3', name: '观察query参数表格的变化' },
                    ],
                    expectedResults: [
                      { id: '1', name: '第一行key值为page,自动新增第二行空的query参数行' },
                      { id: '2', name: '新增的第二行被自动选中(高亮显示)' },
                      { id: '3', name: '第二行的key输入框获得焦点,可直接输入' },
                    ],
                    checkpoints: [{ id: '1', name: '自动新增逻辑在httpNode编辑器中实现' }],
                    notes: [{ id: '1', name: '新增行应自动获得焦点提升用户体验' }],
                  },
                  {
                    purpose: 'query参数key,value,description输入值以后,调用127.0.0.1:{环境变量中的端口}/echo,返回结果query参数正确',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                      { id: '3', name: '环境变量中端口变量已配置为8000' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在query参数表格中添加一条参数:key="page", value="1", description="页码"' },
                      { id: '2', name: '添加第二条参数:key="size", value="10", description="分页大小"' },
                      { id: '3', name: '点击发送按钮发送请求' },
                      { id: '4', name: '观察响应数据中query参数的值' },
                    ],
                    expectedResults: [
                      { id: '1', name: '请求URL中包含query参数:?page=1&size=10' },
                      { id: '2', name: '服务器返回正确的query参数,响应体中包含page=1和size=10' },
                      { id: '3', name: '响应中的description字段被正确地记录和展示' },
                    ],
                    checkpoints: [{ id: '1', name: '手动编辑的query参数正确发送到服务器' }],
                    notes: [{ id: '1', name: '应支持多个query参数的同时发送' }],
                  },
                  {
                    purpose: 'query参数key,value支持变量(需验证所有的变量类型),调用127.0.0.1:{环境变量中的端口}/echo,返回结果query参数正确',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                      { id: '3', name: '已配置项目变量:page_num=2' },
                      { id: '4', name: '已配置全局变量:page_size=20' },
                      { id: '5', name: '已配置环境变量:page_offset=0' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在query参数表格中添加参数:key="page", value="{{page_num}}"(项目变量)' },
                      { id: '2', name: '添加参数:key="size", value="{{page_size}}"(全局变量)' },
                      { id: '3', name: '添加参数:key="offset", value="{{page_offset}}"(环境变量)' },
                      { id: '4', name: '点击发送按钮发送请求' },
                      { id: '5', name: '观察响应中的query参数值是否被正确替换' },
                    ],
                    expectedResults: [
                      { id: '1', name: '请求URL中query参数被正确替换:?page=2&size=20&offset=0' },
                      { id: '2', name: '响应体显示所有变量已被正确解析和替换' },
                      { id: '3', name: '三种变量类型(项目,全局,环境)都能正确工作' },
                    ],
                    checkpoints: [{ id: '1', name: 'query参数变量替换在发送前执行' }],
                    notes: [{ id: '1', name: '需验证项目变量,全局变量,环境变量的优先级' }],
                  },
                  {
                    purpose: 'query参数key,value支持mock(需验证所有的mock情况),调用127.0.0.1:{环境变量中的端口}/echo,返回结果query参数正确',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                      { id: '3', name: '已配置mock数据:@name(用户名),@int(1-100),@email,@date' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在query参数中添加参数:key="username", value="@name"' },
                      { id: '2', name: '添加参数:key="user_id", value="@int(1-100)"' },
                      { id: '3', name: '添加参数:key="email", value="@email"' },
                      { id: '4', name: '添加参数:key="date", value="@date"' },
                      { id: '5', name: '点击发送按钮发送请求' },
                      { id: '6', name: '观察响应中的query参数值是否被正确生成' },
                    ],
                    expectedResults: [
                      { id: '1', name: '请求URL中query参数被mock数据替换,如:?username=张三&user_id=45&email=test@example.com&date=2024-01-15' },
                      { id: '2', name: '每次发送请求时mock数据会重新生成不同的值' },
                      { id: '3', name: '响应体中显示生成后的mock数据' },
                    ],
                    checkpoints: [{ id: '1', name: '多种mock类型都能被正确解析和生成' }],
                    notes: [{ id: '1', name: '需验证所有支持的mock函数及其参数' }],
                  },
                  {
                    purpose: 'query参数key,value支持混合变量(需验证所有的混合情况),调用127.0.0.1:{环境变量中的端口}/echo,返回结果query参数正确',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                      { id: '3', name: '已配置变量:prefix="api_v1",已配置mock:@id' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在query参数中添加参数:key="type", value="{{prefix}}_user"(变量混合文本)' },
                      { id: '2', name: '添加参数:key="id", value="ID_@id"(文本混合mock)' },
                      { id: '3', name: '添加参数:key="request", value="{{prefix}}_@id"(变量混合mock)' },
                      { id: '4', name: '点击发送按钮发送请求' },
                      { id: '5', name: '观察响应中的query参数值' },
                    ],
                    expectedResults: [
                      { id: '1', name: '请求URL中参数被正确替换:?type=api_v1_user&id=ID_12345&request=api_v1_abc123' },
                      { id: '2', name: '混合场景中变量和mock都能正确解析' },
                      { id: '3', name: '混合顺序正确处理,不会出现残留标记符' },
                    ],
                    checkpoints: [{ id: '1', name: '混合变量处理逻辑支持变量+文本,文本+mock,变量+mock的组合' }],
                    notes: [{ id: '1', name: '需验证混合情况下的优先级和执行顺序' }],
                  },
                  {
                    purpose: 'query参数是否发送未勾选那么当前参数不会发送,调用127.0.0.1:{环境变量中的端口}/echo,返回结果query参数正确',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                      { id: '3', name: 'query参数表格中有两个参数:page=1(已勾选),size=10(未勾选)' },
                    ],
                    operationSteps: [
                      { id: '1', name: '确认size参数的"是否发送"checkbox处于未勾选状态' },
                      { id: '2', name: '点击发送按钮发送请求' },
                      { id: '3', name: '观察响应中的query参数' },
                      { id: '4', name: '勾选size参数的"是否发送"checkbox' },
                      { id: '5', name: '再次点击发送按钮' },
                      { id: '6', name: '观察响应中的query参数变化' },
                    ],
                    expectedResults: [
                      { id: '1', name: '未勾选时,请求URL只包含page参数:?page=1,不包含size参数' },
                      { id: '2', name: '响应体中也不包含size参数的信息' },
                      { id: '3', name: '勾选后,请求URL包含所有参数:?page=1&size=10' },
                      { id: '4', name: '响应体中包含完整的query参数信息' },
                    ],
                    checkpoints: [{ id: '1', name: '未勾选参数在HTTP请求中被过滤,不会发送到服务器' }],
                    notes: [{ id: '1', name: '应支持动态启用/禁用个别query参数而不删除' }],
                  },
                ],
              },
              // body参数
              {
                modelName: 'body',
                description: '请求体',
                children: [
                  {
                    modelName: 'json',
                    description: 'json参数',
                    atomicFunc: [
                      {
                        purpose: '输入满足json5格式数据以后,调用127.0.0.1:{环境变量中的端口}/echo,返回结果body参数正确,并且content-type为application/json',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '请求方法为POST,URL为http://127.0.0.1:8000/echo' },
                          { id: '3', name: '已选择body类型为json' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在json编辑器中输入json5格式数据:{name: "test", age: 25, active: true}' },
                          { id: '2', name: '观察编辑器是否出现语法错误提示' },
                          { id: '3', name: '点击发送按钮发送请求' },
                          { id: '4', name: '观察请求头和响应数据' },
                        ],
                        expectedResults: [
                          { id: '1', name: 'json5格式数据被正确识别和解析,编辑器无错误提示' },
                          { id: '2', name: '请求头中Content-Type为application/json' },
                          { id: '3', name: '响应体中body参数与输入数据一致' },
                          { id: '4', name: '服务器正确接收并返回json数据' },
                        ],
                        checkpoints: [{ id: '1', name: '支持json5格式(允许无引号的key,单引号等)' }],
                        notes: [{ id: '1', name: '应支持json和json5格式的自动检测和转换' }],
                      },
                      {
                        purpose: 'json数据的值字段支持变量,支持超大数字,mock,调用127.0.0.1:{环境变量中的端口}/echo,返回结果body参数正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '请求方法为POST,URL为http://127.0.0.1:8000/echo' },
                          { id: '3', name: '已配置变量:user_id="123", api_version="v1"' },
                          { id: '4', name: '已配置mock:@id,@name' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在json编辑器中输入包含变量和mock的json数据' },
                          { id: '2', name: '例如:{"user_id": "{{user_id}}", "version": "{{api_version}}", "id": "@id", "username": "@name", "big_number": 9007199254740992}' },
                          { id: '3', name: '点击发送按钮' },
                          { id: '4', name: '观察响应中的json数据是否被正确替换和解析' },
                        ],
                        expectedResults: [
                          { id: '1', name: '变量被正确替换:user_id=123, version=v1' },
                          { id: '2', name: 'mock数据被正确生成:id和username为随机值' },
                          { id: '3', name: '超大数字被正确处理:big_number=9007199254740992' },
                          { id: '4', name: '响应体显示完整的替换后的json数据' },
                        ],
                        checkpoints: [{ id: '1', name: 'json值支持变量,mock和大数字的处理' }],
                        notes: [{ id: '1', name: '需验证json中对超大数字的精度保持' }],
                      },
                    ],
                  },
                  {
                    modelName: 'formData参数',
                    description: 'formData参数',
                    children: [
                      {
                        modelName: '类型全为string的formdata参数',
                        description: '类型全为string的formdata参数',
                        atomicFunc: [
                          {
                            purpose: 'formdata参数key输入值以后,如果不存在next节点,则自动新增一行数据,自动新增数据需要被选中',
                            precondition: [
                              { id: '1', name: '已打开httpNode节点编辑页面' },
                              { id: '2', name: '已选择body类型为formData' },
                              { id: '3', name: 'formdata参数表格中只有一行,且该行为空' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在第一行formdata参数的key输入框中输入username' },
                              { id: '2', name: '点击key输入框外的区域使其失焦' },
                              { id: '3', name: '观察formdata参数表格的变化' },
                            ],
                            expectedResults: [
                              { id: '1', name: '第一行key值为username,自动新增第二行空的formdata参数行' },
                              { id: '2', name: '新增的第二行被自动选中(高亮显示)' },
                              { id: '3', name: '第二行的key输入框获得焦点' },
                            ],
                            checkpoints: [{ id: '1', name: '自动新增逻辑在formdata编辑器中实现' }],
                            notes: [{ id: '1', name: '应与query参数保持一致的自动新增行为' }],
                          },
                          {
                            purpose: 'formdata参数key,value,description输入值以后,调用127.0.0.1:{环境变量中的端口}/echo,返回结果formdata参数正确',
                            precondition: [
                              { id: '1', name: '已打开httpNode节点编辑页面' },
                              { id: '2', name: '请求方法为POST,URL为http://127.0.0.1:8000/echo' },
                              { id: '3', name: '已选择body类型为formData' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在formdata参数表格中添加参数:key="username", value="admin", description="用户名"' },
                              { id: '2', name: '添加参数:key="password", value="123456", description="密码"' },
                              { id: '3', name: '点击发送按钮' },
                              { id: '4', name: '观察响应数据' },
                            ],
                            expectedResults: [
                              { id: '1', name: '请求Content-Type为multipart/form-data' },
                              { id: '2', name: '服务器接收到formdata参数:username=admin, password=123456' },
                              { id: '3', name: '响应体显示完整的formdata参数信息' },
                            ],
                            checkpoints: [{ id: '1', name: '手动编辑的formdata参数正确发送到服务器' }],
                            notes: [{ id: '1', name: '应支持多个formdata参数的同时发送' }],
                          },
                          {
                            purpose: 'formdata参数key,value支持变量(需验证所有的变量类型),调用127.0.0.1:{环境变量中的端口}/echo,返回结果formdata参数正确',
                            precondition: [
                              { id: '1', name: '已打开httpNode节点编辑页面' },
                              { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                              { id: '3', name: '已配置项目变量:app_id="mobile_app"' },
                              { id: '4', name: '已配置全局变量:access_token="token_abc123"' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在formdata参数中添加:key="app_id", value="{{app_id}}"(项目变量)' },
                              { id: '2', name: '添加:key="token", value="{{access_token}}"(全局变量)' },
                              { id: '3', name: '点击发送按钮' },
                              { id: '4', name: '观察响应中的formdata参数值' },
                            ],
                            expectedResults: [
                              { id: '1', name: '变量被正确替换:app_id=mobile_app, token=token_abc123' },
                              { id: '2', name: '响应体显示所有变量已被正确解析' },
                              { id: '3', name: '三种变量类型都能正确工作' },
                            ],
                            checkpoints: [{ id: '1', name: 'formdata参数变量替换在发送前执行' }],
                            notes: [{ id: '1', name: '需验证formdata中的变量优先级' }],
                          },
                          {
                            purpose: 'formdata参数key,value支持mock(需验证所有的mock情况),调用127.0.0.1:{环境变量中的端口}/echo,返回结果formdata参数正确',
                            precondition: [
                              { id: '1', name: '已打开httpNode节点编辑页面' },
                              { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                              { id: '3', name: '已配置mock:@phone,@address,@id' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在formdata参数中添加:key="phone", value="@phone"' },
                              { id: '2', name: '添加:key="address", value="@address"' },
                              { id: '3', name: '添加:key="user_id", value="@id"' },
                              { id: '4', name: '点击发送按钮' },
                              { id: '5', name: '观察响应中的formdata参数值' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'formdata参数被mock数据替换,如:phone=13800138000&address=北京市朝阳区&user_id=123456' },
                              { id: '2', name: '每次发送请求时mock数据会重新生成' },
                              { id: '3', name: '响应体显示生成后的mock数据' },
                            ],
                            checkpoints: [{ id: '1', name: '多种mock类型都能被正确解析和生成' }],
                            notes: [{ id: '1', name: '需验证所有支持的mock函数' }],
                          },
                          {
                            purpose: 'formdata参数key,value支持混合变量(需验证所有的混合情况),调用127.0.0.1:{环境变量中的端口}/echo,返回结果formdata参数正确',
                            precondition: [
                              { id: '1', name: '已打开httpNode节点编辑页面' },
                              { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                              { id: '3', name: '已配置变量:service="user", 已配置mock:@id' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在formdata参数中添加:key="action", value="{{service}}_query"(变量混合文本)' },
                              { id: '2', name: '添加:key="req_id", value="REQ_@id"(文本混合mock)' },
                              { id: '3', name: '点击发送按钮' },
                              { id: '4', name: '观察响应值' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'formdata参数被正确替换:action=user_query&req_id=REQ_abc123' },
                              { id: '2', name: '混合场景中变量和mock都能正确解析' },
                            ],
                            checkpoints: [{ id: '1', name: '混合变量处理支持多种组合方式' }],
                            notes: [{ id: '1', name: '应支持formdata中的复杂混合情况' }],
                          },
                          {
                            purpose: 'formdata参数是否发送未勾选那么当前参数不会发送,调用127.0.0.1:{环境变量中的端口}/echo,返回结果formdata参数正确',
                            precondition: [
                              { id: '1', name: '已打开httpNode节点编辑页面' },
                              { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                              { id: '3', name: 'formdata参数有两个:username(已勾选),password(未勾选)' },
                            ],
                            operationSteps: [
                              { id: '1', name: '确认password参数的"是否发送"checkbox处于未勾选状态' },
                              { id: '2', name: '点击发送按钮' },
                              { id: '3', name: '观察响应中的formdata参数' },
                              { id: '4', name: '勾选password的"是否发送"checkbox' },
                              { id: '5', name: '再次点击发送按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: '未勾选时,请求只包含username,不包含password' },
                              { id: '2', name: '勾选后,请求包含所有参数' },
                            ],
                            checkpoints: [{ id: '1', name: '未勾选参数在formdata中被过滤' }],
                            notes: [{ id: '1', name: '应支持动态启用/禁用formdata参数' }],
                          },
                        ],
                      },
                      {
                        modelName: '类型全为file的formdata参数',
                        description: '类型全为file的formdata参数',
                        atomicFunc: [
                          {
                            purpose: 'value模式切换后要清空之前的数据',
                            precondition: [
                              { id: '1', name: '已打开httpNode节点编辑页面' },
                              { id: '2', name: '已选择body类型为formData' },
                              { id: '3', name: 'formdata参数类型已设为file' },
                              { id: '4', name: 'formdata参数的value值已输入为/path/to/file.txt' },
                            ],
                            operationSteps: [
                              { id: '1', name: '点击formdata参数的value输入框旁的模式切换按钮' },
                              { id: '2', name: '从文件模式切换为变量模式(或文本模式)' },
                              { id: '3', name: '观察value输入框的值' },
                              { id: '4', name: '再次点击切换回文件模式' },
                            ],
                            expectedResults: [
                              { id: '1', name: '切换模式后,value值被清空' },
                              { id: '2', name: '新的模式对应的输入框显示,旧的value值不再显示' },
                              { id: '3', name: '再次切换回文件模式,value仍为空' },
                            ],
                            checkpoints: [{ id: '1', name: '模式切换时清空前一个模式的数据' }],
                            notes: [{ id: '1', name: '防止模式混淆导致的数据错误' }],
                          },
                          {
                            purpose: 'value如果为文件模式,选择文件,调用127.0.0.1:{环境变量中的端口}/echo,返回结果formdata参数正确',
                            precondition: [
                              { id: '1', name: '已打开httpNode节点编辑页面' },
                              { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                              { id: '3', name: 'formdata参数为file类型' },
                              { id: '4', name: '系统存在测试文件:/tmp/test.txt' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在formdata参数中,key="avatar",type="file"' },
                              { id: '2', name: '点击value输入框旁的文件选择按钮' },
                              { id: '3', name: '在文件浏览器中选择/tmp/test.txt文件' },
                              { id: '4', name: '点击发送按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: '文件被正确上传' },
                              { id: '2', name: '请求Content-Type为multipart/form-data' },
                              { id: '3', name: '服务器接收到avatar参数和文件内容' },
                              { id: '4', name: '响应体显示上传的文件信息' },
                            ],
                            checkpoints: [{ id: '1', name: '文件上传使用FormData API' }],
                            notes: [{ id: '1', name: '支持大文件上传的进度显示' }],
                          },
                          {
                            purpose: 'value如果为文件模式,未选择文件,调用127.0.0.1:{环境变量中的端口}/echo,value输入框下方提示文件不存在,返回值提示准确',
                            precondition: [
                              { id: '1', name: '已打开httpNode节点编辑页面' },
                              { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                              { id: '3', name: 'formdata参数为file类型,但未选择文件' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在formdata参数中,key="avatar",type="file",value为空' },
                              { id: '2', name: '点击发送按钮' },
                              { id: '3', name: '观察value输入框下方的提示信息' },
                            ],
                            expectedResults: [
                              { id: '1', name: '点击发送前显示错误提示:文件不存在' },
                              { id: '2', name: '发送被阻止,不会发起HTTP请求' },
                              { id: '3', name: '提示信息清晰明确' },
                            ],
                            checkpoints: [{ id: '1', name: '未选择文件时应验证并拦截发送' }],
                            notes: [{ id: '1', name: '应提供友好的错误提示' }],
                          },
                          {
                            purpose: 'value如果为变量模式,并且值为文件类型变量,并且文件存在,调用127.0.0.1:{环境变量中的端口}/echo,返回结果formdata参数正确',
                            precondition: [
                              { id: '1', name: '已打开httpNode节点编辑页面' },
                              { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                              { id: '3', name: '已配置文件类型变量:avatar_path="/tmp/avatar.jpg"' },
                              { id: '4', name: '文件/tmp/avatar.jpg存在' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在formdata参数中,key="avatar",type="file"' },
                              { id: '2', name: '点击value输入框的模式切换按钮,选择变量模式' },
                              { id: '3', name: '输入变量:{{avatar_path}}' },
                              { id: '4', name: '点击发送按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: '变量被正确解析为文件路径' },
                              { id: '2', name: '文件被正确上传' },
                              { id: '3', name: '响应体显示上传的文件信息' },
                            ],
                            checkpoints: [{ id: '1', name: '文件类型变量在发送前被解析' }],
                            notes: [{ id: '1', name: '支持动态文件路径的上传' }],
                          },
                          {
                            purpose: 'value如果为变量模式,并且值为文件类型变量,并且文件不存在,调用127.0.0.1:{环境变量中的端口}/echo,value输入框下方提示文件不存在,返回值提示准确',
                            precondition: [
                              { id: '1', name: '已打开httpNode节点编辑页面' },
                              { id: '2', name: '已配置变量:avatar_path="/nonexistent/file.jpg"' },
                              { id: '3', name: '该文件实际不存在' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在formdata参数中输入变量:{{avatar_path}}' },
                              { id: '2', name: '点击发送按钮' },
                              { id: '3', name: '观察提示信息' },
                            ],
                            expectedResults: [
                              { id: '1', name: '显示提示:文件不存在或无法访问' },
                              { id: '2', name: '发送被阻止' },
                              { id: '3', name: '提示信息包含文件路径信息' },
                            ],
                            checkpoints: [{ id: '1', name: '发送前验证文件类型变量的有效性' }],
                            notes: [{ id: '1', name: '应检查文件系统权限和路径有效性' }],
                          },
                          {
                            purpose: 'value如果为变量模式,并且值不是变量,调用127.0.0.1:{环境变量中的端口}/echo,value输入框下方提示文件不存在,返回值提示准确',
                            precondition: [
                              { id: '1', name: '已打开httpNode节点编辑页面' },
                              { id: '2', name: 'formdata参数的value模式为变量' },
                              { id: '3', name: 'value值为普通文本,不是合法的变量格式' },
                            ],
                            operationSteps: [
                              { id: '1', name: '切换value为变量模式' },
                              { id: '2', name: '输入普通文本:invalid_file_path' },
                              { id: '3', name: '点击发送按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: '显示提示:变量不存在或无效' },
                              { id: '2', name: '发送被阻止' },
                            ],
                            checkpoints: [{ id: '1', name: '变量模式下验证变量格式' }],
                            notes: [{ id: '1', name: '应区分文件不存在和变量不存在的错误' }],
                          },
                          {
                            purpose: 'value值合法,formdata参数key为变量(需验证所有的变量类型),调用127.0.0.1:{环境变量中的端口}/echo,返回结果formdata参数正确',
                            precondition: [
                              { id: '1', name: '已打开httpNode节点编辑页面' },
                              { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                              { id: '3', name: '已配置变量:upload_key="document",file_path="/tmp/doc.pdf"' },
                              { id: '4', name: '文件/tmp/doc.pdf存在' },
                            ],
                            operationSteps: [
                              { id: '1', name: 'formdata参数的key设为变量:{{upload_key}}' },
                              { id: '2', name: '类型为file,value设为{{file_path}}' },
                              { id: '3', name: '点击发送按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: '变量被正确替换:key="document",value="/tmp/doc.pdf"' },
                              { id: '2', name: '文件被正确上传' },
                              { id: '3', name: '响应体显示正确的key和文件信息' },
                            ],
                            checkpoints: [{ id: '1', name: 'formdata的key和value都支持变量替换' }],
                            notes: [{ id: '1', name: '支持多种变量类型的组合' }],
                          },
                          {
                            purpose: 'value值合法,formdata参数key为变量(需验证所有的mock情况),调用127.0.0.1:{环境变量中的端口}/echo,返回结果formdata参数正确',
                            precondition: [
                              { id: '1', name: '已打开httpNode节点编辑页面' },
                              { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                              { id: '3', name: '已配置mock:@filename,@ext' },
                              { id: '4', name: '文件/tmp/test.pdf存在' },
                            ],
                            operationSteps: [
                              { id: '1', name: 'formdata参数的key设为mock生成:@filename' },
                              { id: '2', name: '类型为file,value设为真实文件路径:/tmp/test.pdf' },
                              { id: '3', name: '点击发送按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'key被mock数据替换为动态文件名,如:document_abc123' },
                              { id: '2', name: '文件被正确上传' },
                              { id: '3', name: '响应体显示生成后的key和文件信息' },
                            ],
                            checkpoints: [{ id: '1', name: 'formdata的key支持mock生成' }],
                            notes: [{ id: '1', name: '支持key和value的不同类型处理组合' }],
                          },
                          {
                            purpose: 'value值合法,formdata参数key为变量(需验证所有的混合情况),调用127.0.0.1:{环境变量中的端口}/echo,返回结果formdata参数正确',
                            precondition: [
                              { id: '1', name: '已打开httpNode节点编辑页面' },
                              { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                              { id: '3', name: '已配置变量:file_field="upload_file",已配置mock:@ext' },
                              { id: '4', name: '文件/tmp/test.doc存在' },
                            ],
                            operationSteps: [
                              { id: '1', name: 'formdata参数的key设为混合:{{file_field}}_@ext,如:upload_file_pdf' },
                              { id: '2', name: '类型为file,value设为文件路径:/tmp/test.doc' },
                              { id: '3', name: '点击发送按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: 'key被混合后正确替换为:upload_file_pdf' },
                              { id: '2', name: '文件被正确上传' },
                              { id: '3', name: '响应体显示混合后的key和文件信息' },
                            ],
                            checkpoints: [{ id: '1', name: 'formdata的key支持变量和mock的混合' }],
                            notes: [{ id: '1', name: '支持复杂的混合处理场景' }],
                          },
                          {
                            purpose: 'formdata参数是否发送未勾选那么当前参数不会发送,调用127.0.0.1:{环境变量中的端口}/echo,返回结果formdata参数正确',
                            precondition: [
                              { id: '1', name: '已打开httpNode节点编辑页面' },
                              { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                              { id: '3', name: 'formdata参数有两个file类型:avatar(已勾选),document(未勾选)' },
                              { id: '4', name: '两个文件都已选择' },
                            ],
                            operationSteps: [
                              { id: '1', name: '确认document参数的"是否发送"checkbox处于未勾选状态' },
                              { id: '2', name: '点击发送按钮' },
                              { id: '3', name: '观察响应中发送的formdata参数' },
                              { id: '4', name: '勾选document的"是否发送"checkbox' },
                              { id: '5', name: '再次点击发送按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: '未勾选时,只发送avatar文件,不发送document' },
                              { id: '2', name: '响应体中只包含avatar的上传信息' },
                              { id: '3', name: '勾选后,发送所有文件' },
                              { id: '4', name: '响应体中包含avatar和document的上传信息' },
                            ],
                            checkpoints: [{ id: '1', name: '未勾选的file类型参数在formdata中被过滤' }],
                            notes: [{ id: '1', name: '应支持动态启用/禁用file参数' }],
                          },
                        ],
                      },
                      {
                        modelName: '类型为file和string的混合类型的formdata参数',
                        description: '类型为file和string的混合类型的formdata参数',
                        atomicFunc: [
                          {
                            purpose: '存在string类型value和file类型value时候,调用127.0.0.1:{环境变量中的端口}/echo,返回结果formdata参数正确',
                            precondition: [
                              { id: '1', name: '已打开httpNode节点编辑页面' },
                              { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                              { id: '3', name: '文件/tmp/image.jpg存在' },
                            ],
                            operationSteps: [
                              { id: '1', name: '在formdata参数中添加string类型:key="username", value="admin"' },
                              { id: '2', name: '添加file类型:key="avatar", value="/tmp/image.jpg"' },
                              { id: '3', name: '添加string类型:key="desc", value="user description"' },
                              { id: '4', name: '点击发送按钮' },
                            ],
                            expectedResults: [
                              { id: '1', name: '混合类型的formdata被正确发送' },
                              { id: '2', name: '服务器接收到string和file参数' },
                              { id: '3', name: '响应体显示所有参数信息' },
                            ],
                            checkpoints: [{ id: '1', name: '混合类型formdata使用multipart/form-data编码' }],
                            notes: [{ id: '1', name: '应正确处理string和file的混合' }],
                          },
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'urlencoded参数',
                    description: 'urlencoded参数',
                    atomicFunc: [
                      {
                        purpose: 'urlencoded参数key输入值以后,如果不存在next节点,则自动新增一行数据,自动新增数据需要被选中',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '已选择body类型为urlencoded' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在urlencoded参数的key输入框中输入username' },
                          { id: '2', name: '点击key输入框外的区域使其失焦' },
                        ],
                        expectedResults: [
                          { id: '1', name: 'key值为username,自动新增一行空的参数行' },
                          { id: '2', name: '新增的行被自动选中' },
                        ],
                        checkpoints: [{ id: '1', name: '自动新增逻辑在urlencoded编辑器中实现' }],
                        notes: [{ id: '1', name: '与query和formdata保持一致的行为' }],
                      },
                      {
                        purpose: 'urlencoded参数key,value,description输入值以后,调用127.0.0.1:{环境变量中的端口}/echo,返回结果urlencoded参数正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '请求URL为http://127.0.0.1:8000/echo,method为POST' },
                          { id: '3', name: '已选择body类型为urlencoded' },
                        ],
                        operationSteps: [
                          { id: '1', name: '添加参数:key="username", value="admin"' },
                          { id: '2', name: '添加参数:key="password", value="secret"' },
                          { id: '3', name: '点击发送按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '请求Content-Type为application/x-www-form-urlencoded' },
                          { id: '2', name: '服务器接收到正确的urlencoded参数' },
                        ],
                        checkpoints: [{ id: '1', name: 'urlencoded参数正确编码和发送' }],
                        notes: [{ id: '1', name: '应支持多个参数的同时发送' }],
                      },
                      {
                        purpose: 'urlencoded参数key,value支持变量(需验证所有的变量类型),调用127.0.0.1:{环境变量中的端口}/echo,返回结果urlencoded参数正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '已配置变量:account="user123"' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在urlencoded参数中添加:key="user", value="{{account}}"' },
                          { id: '2', name: '点击发送按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '变量被正确替换为account的值' },
                          { id: '2', name: '服务器接收到:user=user123' },
                        ],
                        checkpoints: [{ id: '1', name: 'urlencoded参数支持变量替换' }],
                        notes: [{ id: '1', name: '应验证多种变量类型' }],
                      },
                      {
                        purpose: 'urlencoded参数key,value支持mock(需验证所有的mock情况),调用127.0.0.1:{环境变量中的端口}/echo,返回结果urlencoded参数正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '已配置mock:@name,@email' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在urlencoded参数中添加:key="name", value="@name"' },
                          { id: '2', name: '添加:key="email", value="@email"' },
                          { id: '3', name: '点击发送按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: 'mock数据被正确生成和替换' },
                          { id: '2', name: '服务器接收到生成后的mock数据' },
                        ],
                        checkpoints: [{ id: '1', name: 'urlencoded参数支持mock' }],
                        notes: [{ id: '1', name: '需验证所有支持的mock函数' }],
                      },
                      {
                        purpose: 'urlencoded参数key,value支持混合变量(需验证所有的混合情况),调用127.0.0.1:{环境变量中的端口}/echo,返回结果urlencoded参数正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '已配置变量:api_v="v1",已配置mock:@id' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在urlencoded参数中添加:key="version", value="api_{{api_v}}"' },
                          { id: '2', name: '添加:key="request_id", value="REQ_@id"' },
                          { id: '3', name: '点击发送按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '混合变量被正确替换和生成' },
                          { id: '2', name: '服务器接收到:version=api_v1&request_id=REQ_abc123' },
                        ],
                        checkpoints: [{ id: '1', name: 'urlencoded参数支持混合变量' }],
                        notes: [{ id: '1', name: '应支持复杂的混合场景' }],
                      },
                      {
                        purpose: 'urlencoded参数是否发送未勾选那么当前参数不会发送,调用127.0.0.1:{环境变量中的端口}/echo,返回结果urlencoded参数正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: 'urlencoded参数有两个:user(已勾选),token(未勾选)' },
                        ],
                        operationSteps: [
                          { id: '1', name: '确认token参数未勾选' },
                          { id: '2', name: '点击发送按钮' },
                          { id: '3', name: '观察响应中的参数' },
                          { id: '4', name: '勾选token后再发送' },
                        ],
                        expectedResults: [
                          { id: '1', name: '未勾选时,只发送user参数' },
                          { id: '2', name: '勾选后,发送所有参数' },
                        ],
                        checkpoints: [{ id: '1', name: '未勾选的参数被过滤' }],
                        notes: [{ id: '1', name: '应支持动态启用/禁用参数' }],
                      },
                    ],
                  },
                  {
                    modelName: 'raw参数',
                    description: 'raw参数',
                    atomicFunc: [
                      {
                        purpose: 'raw text参数输入值以后,请求头自动添加contentType:text/plain,调用127.0.0.1:{环境变量中的端口}/echo,返回结果参数和请求头正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '请求URL为http://127.0.0.1:8000/echo,method为POST' },
                        ],
                        operationSteps: [
                          { id: '1', name: '选择body类型为raw,格式为text' },
                          { id: '2', name: '在编辑器中输入:This is plain text content' },
                          { id: '3', name: '点击发送按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '请求头自动包含Content-Type: text/plain' },
                          { id: '2', name: '服务器接收到纯文本内容' },
                          { id: '3', name: '响应体显示完整的text数据' },
                        ],
                        checkpoints: [{ id: '1', name: 'raw text格式自动设置正确的Content-Type' }],
                        notes: [{ id: '1', name: '支持自动化的Content-Type设置' }],
                      },
                      {
                        purpose: 'raw html参数输入值以后,请求头自动添加contentType:text/html,调用127.0.0.1:{环境变量中的端口}/echo,返回结果参数和请求头正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '请求URL为http://127.0.0.1:8000/echo,method为POST' },
                        ],
                        operationSteps: [
                          { id: '1', name: '选择body类型为raw,格式为html' },
                          { id: '2', name: '输入HTML代码:<html><body>Hello World</body></html>' },
                          { id: '3', name: '点击发送按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '请求头自动包含Content-Type: text/html' },
                          { id: '2', name: '服务器接收到HTML内容' },
                        ],
                        checkpoints: [{ id: '1', name: 'raw html格式自动设置正确的Content-Type' }],
                        notes: [{ id: '1', name: '支持HTML格式的识别' }],
                      },
                      {
                        purpose: 'raw xml参数输入值以后,请求头自动添加contentType:application/xml,调用127.0.0.1:{环境变量中的端口}/echo,返回结果参数和请求头正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '请求URL为http://127.0.0.1:8000/echo,method为POST' },
                        ],
                        operationSteps: [
                          { id: '1', name: '选择body类型为raw,格式为xml' },
                          { id: '2', name: '输入XML代码:<?xml version="1.0"?><root><item>test</item></root>' },
                          { id: '3', name: '点击发送按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '请求头自动包含Content-Type: application/xml' },
                          { id: '2', name: '服务器接收到正确的XML数据' },
                        ],
                        checkpoints: [{ id: '1', name: 'raw xml格式自动设置正确的Content-Type' }],
                        notes: [{ id: '1', name: '支持XML格式的正确处理' }],
                      },
                      {
                        purpose: 'raw javascript参数输入值以后,请求头自动添加contentType:text/javascript,调用127.0.0.1:{环境变量中的端口}/echo,返回结果参数和请求头正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '请求URL为http://127.0.0.1:8000/echo,method为POST' },
                        ],
                        operationSteps: [
                          { id: '1', name: '选择body类型为raw,格式为javascript' },
                          { id: '2', name: '输入JavaScript代码:console.log("test"); var x = 123;' },
                          { id: '3', name: '点击发送按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '请求头自动包含Content-Type: text/javascript' },
                          { id: '2', name: '服务器接收到JavaScript代码' },
                        ],
                        checkpoints: [{ id: '1', name: 'raw javascript格式自动设置正确的Content-Type' }],
                        notes: [{ id: '1', name: '支持JavaScript格式的发送' }],
                      },
                      {
                        purpose: 'raw 参数(text,html,xml,json格式)无任何值,请求头不自动添加,调用127.0.0.1:{环境变量中的端口}/echo,返回结果参数和请求头正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '已选择body类型为raw' },
                        ],
                        operationSteps: [
                          { id: '1', name: '不在编辑器中输入任何内容(保持为空)' },
                          { id: '2', name: '点击发送按钮' },
                          { id: '3', name: '观察请求头中的Content-Type' },
                        ],
                        expectedResults: [
                          { id: '1', name: 'raw body为空时,请求头不包含自动添加的Content-Type' },
                          { id: '2', name: '服务器接收到空的body' },
                        ],
                        checkpoints: [{ id: '1', name: '空的raw body不触发自动Content-Type设置' }],
                        notes: [{ id: '1', name: '应根据内容智能识别格式' }],
                      },
                    ],
                  },
                  {
                    modelName: 'binary参数',
                    description: 'binary参数',
                    atomicFunc: [
                      {
                        purpose: '变量模式,若没有输入有效变量,发送返回值中正确提示发送被终止',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: 'body类型为binary,模式为变量' },
                        ],
                        operationSteps: [
                          { id: '1', name: '不输入任何变量或输入无效变量' },
                          { id: '2', name: '点击发送按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '显示错误提示:变量不存在或无效' },
                          { id: '2', name: '发送被阻止' },
                        ],
                        checkpoints: [{ id: '1', name: '变量模式下验证变量的有效性' }],
                        notes: [{ id: '1', name: '应进行客户端验证' }],
                      },
                      {
                        purpose: '变量模式,输入有效变量,请求头自动添加contentType:xxx(验证常见文件格式),调用127.0.0.1:{环境变量中的端口}/echo,返回结果参数和请求头正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '已配置变量:pdf_file="/tmp/document.pdf"' },
                          { id: '3', name: '文件/tmp/document.pdf存在' },
                        ],
                        operationSteps: [
                          { id: '1', name: '选择body类型为binary,模式为变量' },
                          { id: '2', name: '输入变量:{{pdf_file}}' },
                          { id: '3', name: '点击发送按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '变量被解析为文件路径' },
                          { id: '2', name: '请求头自动设置Content-Type: application/pdf' },
                          { id: '3', name: '文件内容被正确发送' },
                        ],
                        checkpoints: [{ id: '1', name: '根据文件格式自动设置Content-Type' }],
                        notes: [{ id: '1', name: '支持常见文件格式的MIME类型' }],
                      },
                      {
                        purpose: '文件模式,选择文件被删除或者未选择文件,发送返回值中正确提示发送被终止',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: 'body类型为binary,模式为文件' },
                        ],
                        operationSteps: [
                          { id: '1', name: '未选择任何文件或选择的文件已被删除' },
                          { id: '2', name: '点击发送按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '显示错误提示:文件不存在' },
                          { id: '2', name: '发送被阻止' },
                        ],
                        checkpoints: [{ id: '1', name: '文件模式下验证文件的存在性' }],
                        notes: [{ id: '1', name: '应提供清晰的错误提示' }],
                      },
                      {
                        purpose: '文件模式,选择正确的文件,请请求头自动添加contentType:xxx(验证常见文件格式),调用127.0.0.1:{环境变量中的端口}/echo,返回结果参数和请求头正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: 'body类型为binary,模式为文件' },
                          { id: '3', name: '系统存在文件:/tmp/image.png' },
                        ],
                        operationSteps: [
                          { id: '1', name: '点击文件选择按钮' },
                          { id: '2', name: '选择/tmp/image.png文件' },
                          { id: '3', name: '观察自动设置的Content-Type' },
                          { id: '4', name: '点击发送按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '请求头自动设置Content-Type: image/png' },
                          { id: '2', name: '文件二进制内容被正确发送' },
                          { id: '3', name: '服务器接收到完整的文件内容' },
                        ],
                        checkpoints: [{ id: '1', name: '根据文件扩展名自动识别Content-Type' }],
                        notes: [{ id: '1', name: '应支持多种常见文件格式' }],
                      },
                    ],
                  },
                  {
                    modelName: 'none参数',
                    description: 'none参数',
                    atomicFunc: [
                      {
                        purpose: '变量模式,若没有输入有效变量,发送返回值中正确提示发送被终止',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: 'body类型为none' },
                        ],
                        operationSteps: [
                          { id: '1', name: '不输入任何内容或值' },
                          { id: '2', name: '点击发送按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '请求被正确发送,body为空' },
                          { id: '2', name: '服务器接收到不包含body的请求' },
                        ],
                        checkpoints: [{ id: '1', name: 'none类型表示没有请求体' }],
                        notes: [{ id: '1', name: '适用于GET,DELETE等无body的请求方法' }],
                      },
                    ],
                  },
                ],
              },
              // header参数
              {
                modelName: 'header',
                description: '请求头',
                children: [
                  {
                    modelName: '默认请求头',
                    description: '默认请求头',
                    atomicFunc: [
                      {
                        purpose: '未设置任何body参数,默认请求头:Host,Accept-Encoding,Connection,Content-Length,User-Agent,Accept,调用127.0.0.1:{环境变量中的端口}/echo,返回结果请求头参数正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                          { id: '3', name: '未添加任何body参数' },
                        ],
                        operationSteps: [
                          { id: '1', name: '点击发送按钮' },
                          { id: '2', name: '观察响应中的请求头信息' },
                        ],
                        expectedResults: [
                          { id: '1', name: '请求包含默认的Host请求头' },
                          { id: '2', name: '请求包含Accept-Encoding请求头' },
                          { id: '3', name: '请求包含Connection请求头' },
                          { id: '4', name: '请求包含User-Agent请求头' },
                          { id: '5', name: '请求包含Accept请求头' },
                        ],
                        checkpoints: [{ id: '1', name: '默认请求头自动添加' }],
                        notes: [{ id: '1', name: '这些是HTTP标准请求头' }],
                      },
                      {
                        purpose: '隐藏请求头中user-agent和accept值可以更改,更改后调用127.0.0.1:{环境变量中的端口}/echo,返回结果请求头参数正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                        ],
                        operationSteps: [
                          { id: '1', name: '展开隐藏请求头列表' },
                          { id: '2', name: '修改User-Agent的值为自定义值' },
                          { id: '3', name: '修改Accept的值为application/json' },
                          { id: '4', name: '点击发送按钮' },
                          { id: '5', name: '观察响应中的请求头值' },
                        ],
                        expectedResults: [
                          { id: '1', name: '修改后的User-Agent值被发送到服务器' },
                          { id: '2', name: '修改后的Accept值被发送到服务器' },
                          { id: '3', name: '服务器返回修改后的请求头信息' },
                        ],
                        checkpoints: [{ id: '1', name: '隐藏请求头的值可被修改' }],
                        notes: [{ id: '1', name: '允许用户自定义标准请求头' }],
                      },
                      {
                        purpose: '点击隐藏请求头图标展示隐藏请求头,再次点击收起隐藏请求头,隐藏请求头和用户输入请求头直接存在分割线',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: 'header区域已展开' },
                        ],
                        operationSteps: [
                          { id: '1', name: '观察初始状态(隐藏请求头默认收起)' },
                          { id: '2', name: '点击隐藏请求头图标展开隐藏请求头列表' },
                          { id: '3', name: '观察展开后的分割线' },
                          { id: '4', name: '再次点击隐藏请求头图标收起' },
                        ],
                        expectedResults: [
                          { id: '1', name: '隐藏请求头列表展开显示' },
                          { id: '2', name: '隐藏请求头和自定义请求头之间显示分割线' },
                          { id: '3', name: '再次点击后隐藏请求头列表收起' },
                          { id: '4', name: '分割线消失' },
                        ],
                        checkpoints: [{ id: '1', name: '隐藏请求头的展开/收起功能正常' }],
                        notes: [{ id: '1', name: '分割线用于区分默认和自定义请求头' }],
                      },
                      {
                        purpose: 'body中参数不同的mode,并且对应mode录入了参数,会自动添加content-type,调用127.0.0.1:{环境变量中的端口}/echo,返回请求头参数正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '请求URL为http://127.0.0.1:8000/echo,method为POST' },
                        ],
                        operationSteps: [
                          { id: '1', name: '选择body类型为json,输入JSON数据' },
                          { id: '2', name: '观察header中是否自动添加了Content-Type' },
                          { id: '3', name: '点击发送按钮' },
                        ],
                        expectedResults: [
                          { id: '1', name: '自动添加Content-Type: application/json' },
                          { id: '2', name: '服务器接收到正确的Content-Type' },
                        ],
                        checkpoints: [{ id: '1', name: '根据body类型自动设置Content-Type' }],
                        notes: [{ id: '1', name: '每种body类型对应特定的Content-Type' }],
                      },
                      {
                        purpose: '自动添加的content-type值允许修改,调用127.0.0.1:{环境变量中的端口}/echo,返回请求头参数正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: 'body类型为json,自动添加了Content-Type' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在自定义请求头中修改或新增Content-Type' },
                          { id: '2', name: '设置为自定义值:application/custom' },
                          { id: '3', name: '点击发送按钮' },
                          { id: '4', name: '观察服务器接收到的Content-Type' },
                        ],
                        expectedResults: [
                          { id: '1', name: '自动添加的Content-Type被用户修改值覆盖' },
                          { id: '2', name: '服务器接收到自定义的Content-Type值' },
                        ],
                        checkpoints: [{ id: '1', name: '用户可以覆盖自动设置的Content-Type' }],
                        notes: [{ id: '1', name: '提供灵活的请求头定制能力' }],
                      },
                    ],
                  },
                  {
                    modelName: '自定义请求头',
                    description: '自定义请求头',
                    atomicFunc: [
                      {
                        purpose: '用户输入请求头key,如果匹配上预设的请求头,会出现请求头下拉列表,下拉列表中匹配上的关键字高亮,按tab可以选中第一个,也可以上下切换按回车选中',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '自定义请求头输入框为空' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在自定义请求头的key输入框中输入"auth"' },
                          { id: '2', name: '观察是否出现下拉列表(包含Authorization等)' },
                          { id: '3', name: '按tab键选中第一个下拉项' },
                          { id: '4', name: '清空并再次输入,使用上下方向键切换' },
                          { id: '5', name: '按回车键选中某个下拉项' },
                        ],
                        expectedResults: [
                          { id: '1', name: '输入匹配的关键字时出现下拉列表' },
                          { id: '2', name: '下拉列表中匹配的关键字被高亮显示' },
                          { id: '3', name: '按tab键选中第一个下拉项' },
                          { id: '4', name: '可以使用方向键在下拉列表中切换' },
                          { id: '5', name: '按回车键选中下拉列表中的项' },
                        ],
                        checkpoints: [{ id: '1', name: '请求头下拉列表的选择和高亮功能' }],
                        notes: [{ id: '1', name: '提供请求头的自动补全和建议功能' }],
                      },
                      {
                        purpose: '用户输入请求头如果key相同(key忽略大小写比较,需要验证忽略大小写情况),则会覆盖允许覆盖默认请求头(需要验证所有情况),调用127.0.0.1:{环境变量中的端口}/echo,返回请求头参数正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                        ],
                        operationSteps: [
                          { id: '1', name: '展开隐藏请求头,记录User-Agent的默认值' },
                          { id: '2', name: '在自定义请求头中添加key="user-agent",value="CustomAgent/1.0"' },
                          { id: '3', name: '点击发送按钮' },
                          { id: '4', name: '观察服务器接收到的User-Agent值' },
                          { id: '5', name: '再测试其他大小写变体如"User-Agent","USER-AGENT"' },
                        ],
                        expectedResults: [
                          { id: '1', name: '自定义的user-agent值覆盖了默认值' },
                          { id: '2', name: '服务器接收到自定义的User-Agent值' },
                          { id: '3', name: 'key的大小写不同但仍然匹配和覆盖' },
                          { id: '4', name: '允许覆盖所有默认的隐藏请求头' },
                        ],
                        checkpoints: [{ id: '1', name: '请求头key匹配忽略大小写' }],
                        notes: [{ id: '1', name: 'HTTP请求头key是大小写不敏感的' }],
                      },
                      [
                        {
                          purpose: 'header参数key输入值以后,如果不存在next节点,则自动新增一行数据,自动新增数据需要被选中',
                          precondition: [
                            { id: '1', name: '已打开httpNode节点编辑页面' },
                            { id: '2', name: '自定义请求头表格中只有一行,且为空' },
                          ],
                          operationSteps: [
                            { id: '1', name: '在第一行header的key输入框中输入X-Custom-Header' },
                            { id: '2', name: '点击key输入框外的区域使其失焦' },
                          ],
                          expectedResults: [
                            { id: '1', name: '第一行key值为X-Custom-Header,自动新增第二行空的header行' },
                            { id: '2', name: '新增的第二行被自动选中' },
                          ],
                          checkpoints: [{ id: '1', name: '自动新增逻辑在header编辑器中实现' }],
                          notes: [{ id: '1', name: '与其他参数保持一致的行为' }],
                        },
                        {
                          purpose: 'header参数key,value,description输入值以后,调用127.0.0.1:{环境变量中的端口}/echo,返回结果header参数正确',
                          precondition: [
                            { id: '1', name: '已打开httpNode节点编辑页面' },
                            { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                          ],
                          operationSteps: [
                            { id: '1', name: '在自定义header中添加:key="X-Request-ID", value="12345"' },
                            { id: '2', name: '添加:key="X-API-Version", value="v1"' },
                            { id: '3', name: '点击发送按钮' },
                          ],
                          expectedResults: [
                            { id: '1', name: '服务器接收到自定义header参数' },
                            { id: '2', name: '响应体显示完整的header信息' },
                          ],
                          checkpoints: [{ id: '1', name: '自定义header正确发送到服务器' }],
                          notes: [{ id: '1', name: '支持多个自定义header的同时发送' }],
                        },
                        {
                          purpose: 'header参数key,value支持变量(需验证所有的变量类型),调用127.0.0.1:{环境变量中的端口}/echo,返回结果header参数正确',
                          precondition: [
                            { id: '1', name: '已打开httpNode节点编辑页面' },
                            { id: '2', name: '已配置变量:token="abc123xyz",api_key="key_prod"' },
                          ],
                          operationSteps: [
                            { id: '1', name: '添加header:key="Authorization", value="Bearer {{token}}"' },
                            { id: '2', name: '添加header:key="X-API-Key", value="{{api_key}}"' },
                            { id: '3', name: '点击发送按钮' },
                          ],
                          expectedResults: [
                            { id: '1', name: '变量被正确替换:Authorization=Bearer abc123xyz' },
                            { id: '2', name: '服务器接收到替换后的header值' },
                          ],
                          checkpoints: [{ id: '1', name: 'header参数支持变量替换' }],
                          notes: [{ id: '1', name: '需验证多种变量类型' }],
                        },
                        {
                          purpose: 'header参数key,value支持mock(需验证所有的mock情况),调用127.0.0.1:{环境变量中的端口}/echo,返回结果header参数正确',
                          precondition: [
                            { id: '1', name: '已打开httpNode节点编辑页面' },
                            { id: '2', name: '已配置mock:@uuid,@timestamp' },
                          ],
                          operationSteps: [
                            { id: '1', name: '添加header:key="X-Request-ID", value="@uuid"' },
                            { id: '2', name: '添加header:key="X-Timestamp", value="@timestamp"' },
                            { id: '3', name: '点击发送按钮' },
                          ],
                          expectedResults: [
                            { id: '1', name: 'mock数据被正确生成替换' },
                            { id: '2', name: '每次发送时mock数据会重新生成' },
                          ],
                          checkpoints: [{ id: '1', name: 'header参数支持mock' }],
                          notes: [{ id: '1', name: '需验证所有支持的mock函数' }],
                        },
                        {
                          purpose: 'header参数key,value支持混合变量(需验证所有的混合情况),调用127.0.0.1:{环境变量中的端口}/echo,返回结果header参数正确',
                          precondition: [
                            { id: '1', name: '已打开httpNode节点编辑页面' },
                            { id: '2', name: '已配置变量:api_v="v2",已配置mock:@uuid' },
                          ],
                          operationSteps: [
                            { id: '1', name: '添加header:key="X-API-Version", value="api_{{api_v}}"' },
                            { id: '2', name: '添加header:key="X-Session-ID", value="sid_@uuid"' },
                            { id: '3', name: '点击发送按钮' },
                          ],
                          expectedResults: [
                            { id: '1', name: '混合变量被正确替换:X-API-Version=api_v2' },
                            { id: '2', name: '混合mock被正确生成:X-Session-ID=sid_<uuid>' },
                          ],
                          checkpoints: [{ id: '1', name: 'header参数支持混合变量' }],
                          notes: [{ id: '1', name: '支持复杂的混合场景' }],
                        },
                        {
                          purpose: 'header参数是否发送未勾选那么当前参数不会发送,调用127.0.0.1:{环境变量中的端口}/echo,返回结果header参数正确',
                          precondition: [
                            { id: '1', name: '已打开httpNode节点编辑页面' },
                            { id: '2', name: '自定义header中有两个参数:X-Request-ID(已勾选),X-Debug(未勾选)' },
                          ],
                          operationSteps: [
                            { id: '1', name: '确认X-Debug的"是否发送"checkbox处于未勾选状态' },
                            { id: '2', name: '点击发送按钮' },
                            { id: '3', name: '观察响应中的header参数' },
                            { id: '4', name: '勾选X-Debug后再发送' },
                          ],
                          expectedResults: [
                            { id: '1', name: '未勾选时,只发送X-Request-ID,不发送X-Debug' },
                            { id: '2', name: '勾选后,发送所有header参数' },
                          ],
                          checkpoints: [{ id: '1', name: '未勾选的header参数被过滤' }],
                          notes: [{ id: '1', name: '应支持动态启用/禁用header参数' }],
                        },
                      ],
                    ],
                  },
                  {
                    modelName: '请求头优先级',
                    description: '请求头优先级',
                    atomicFunc: [
                      {
                        purpose: '自定义请求头优先级大于公共请求头,公共请求头优先级大于可更改的默认请求头,需要验证尽可能所有情况',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面' },
                          { id: '2', name: '请求URL为http://127.0.0.1:8000/echo' },
                        ],
                        operationSteps: [
                          { id: '1', name: '添加公共请求头:key="X-Custom", value="from-common"' },
                          { id: '2', name: '在自定义header中添加相同key:key="X-Custom", value="from-custom"' },
                          { id: '3', name: '点击发送按钮观察哪个值被发送' },
                          { id: '4', name: '再测试修改默认请求头User-Agent与自定义值的优先级' },
                        ],
                        expectedResults: [
                          { id: '1', name: '自定义请求头的值优先级最高' },
                          { id: '2', name: '服务器接收到X-Custom=from-custom' },
                          { id: '3', name: '自定义header优先级 > 公共header优先级 > 默认header' },
                        ],
                        checkpoints: [{ id: '1', name: '请求头优先级规则正确实现' }],
                        notes: [{ id: '1', name: '需验证所有优先级组合情况' }],
                      },
                    ],
                  },
                ],
              },
              // 返回参数
              {
                modelName: '返回参数',
                description: '返回参数',
                atomicFunc: [
                  {
                    purpose: '返回参数可以新增,可以删除(但是必须保留一个),可以修改名称,可以修改状态码,可以数据类型',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面的返回参数区域' },
                      { id: '2', name: '返回参数列表已初始化有默认的参数' },
                    ],
                    operationSteps: [
                      { id: '1', name: '点击新增按钮添加新的返回参数' },
                      { id: '2', name: '修改新添加参数的名称,状态码,数据类型' },
                      { id: '3', name: '尝试删除一个参数(保留至少一个)' },
                      { id: '4', name: '尝试删除最后一个参数(应被阻止)' },
                    ],
                    expectedResults: [
                      { id: '1', name: '可以成功新增返回参数' },
                      { id: '2', name: '可以修改参数的名称,状态码,数据类型' },
                      { id: '3', name: '当有多个参数时可以删除参数' },
                      { id: '4', name: '删除最后一个参数时显示提示,保留至少一个' },
                    ],
                    checkpoints: [{ id: '1', name: '返回参数的CRUD操作正常实现' }],
                    notes: [{ id: '1', name: '返回参数用于API文档和Mock' }],
                  },
                  {
                    purpose: '允许选择常见响应码,也允许用户自定义100~999的响应码,不同大小响应码颜色不同,鼠标移动到常见响应码上方显示响应码含义',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面的返回参数区域' },
                      { id: '2', name: '返回参数列表中至少有一个参数' },
                    ],
                    operationSteps: [
                      { id: '1', name: '点击返回参数的状态码输入框,弹出常见响应码列表' },
                      { id: '2', name: '从常见响应码列表中选择200' },
                      { id: '3', name: '鼠标悬停在列表中的404响应码上方' },
                      { id: '4', name: '清空状态码输入框,输入自定义响应码250' },
                      { id: '5', name: '观察不同状态码的颜色显示(2xx绿色,3xx蓝色,4xx黄色,5xx红色)' },
                    ],
                    expectedResults: [
                      { id: '1', name: '状态码输入框弹出常见响应码列表(200,201,204,301,302,400,401,403,404,500,502,503等)' },
                      { id: '2', name: '可以从列表中选择常见响应码' },
                      { id: '3', name: '鼠标悬停显示响应码含义提示(如"404 Not Found")' },
                      { id: '4', name: '可以自定义输入100~999范围的任何状态码' },
                      { id: '5', name: '不同类别的响应码显示不同颜色(2xx绿色,3xx蓝色,4xx黄色,5xx红色)' },
                    ],
                    checkpoints: [
                      { id: '1', name: '常见响应码列表正确显示和提示' },
                      { id: '2', name: '状态码颜色分类渲染正确' },
                      { id: '3', name: '自定义状态码验证范围100~999' },
                    ],
                    notes: [
                      { id: '1', name: '响应码用于Mock服务器返回' },
                      { id: '2', name: '颜色编码遵循HTTP标准:2xx成功,3xx重定向,4xx客户端错误,5xx服务器错误' },
                    ],
                  },
                  {
                    purpose: '允许选择常见响应类型,也允许用户自定义响应类型,不同响应类型对应不同输入框',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面的返回参数区域' },
                      { id: '2', name: '返回参数列表中至少有一个参数' },
                    ],
                    operationSteps: [
                      { id: '1', name: '点击返回参数的数据类型下拉框' },
                      { id: '2', name: '选择JSON类型' },
                      { id: '3', name: '观察是否显示JSON编辑输入框' },
                      { id: '4', name: '修改数据类型为HTML' },
                      { id: '5', name: '观察是否显示HTML编辑输入框' },
                      { id: '6', name: '修改数据类型为自定义响应类型' },
                      { id: '7', name: '输入自定义类型名称,如Custom' },
                      { id: '8', name: '输入自定义类型对应的内容' },
                    ],
                    expectedResults: [
                      { id: '1', name: '数据类型下拉框显示常见响应类型:JSON,HTML,XML,CSV,Text等' },
                      { id: '2', name: '选择JSON类型后显示JSON编辑输入框' },
                      { id: '3', name: '选择HTML类型后显示HTML编辑输入框' },
                      { id: '4', name: '可以选择自定义响应类型' },
                      { id: '5', name: '自定义类型可以输入类型名称和对应的内容' },
                      { id: '6', name: '不同响应类型的输入框独立存储各自的内容' },
                    ],
                    checkpoints: [
                      { id: '1', name: '数据类型下拉列表正确渲染' },
                      { id: '2', name: '不同数据类型对应不同输入框组件' },
                      { id: '3', name: '自定义响应类型支持输入和保存' },
                    ],
                    notes: [
                      { id: '1', name: '响应类型用于Mock服务器返回内容' },
                      { id: '2', name: '常见类型包括:JSON,HTML,XML,CSV,Text,Binary等' },
                      { id: '3', name: '自定义类型允许用户创建特殊格式的响应' },
                    ],
                  },
                ],
              },
              // 前置脚本
              {
                modelName: 'preScript',
                description: '前置脚本',
                children: [
                  {
                    modelName: '编辑器功能',
                    description: '编辑器功能',
                    atomicFunc: [
                      {
                        purpose: '前置脚本编辑器支持JavaScript语法高亮',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在编辑器中输入JavaScript代码,包括关键字,函数,变量等' },
                          { id: '2', name: '观察不同类型代码的颜色显示' },
                        ],
                        expectedResults: [
                          { id: '1', name: '编辑器显示JavaScript语法高亮' },
                          { id: '2', name: '关键字显示为蓝色,字符串显示为绿色,注释显示为灰色等' },
                          { id: '3', name: '语法高亮准确反映JavaScript语法' },
                        ],
                        checkpoints: [
                          { id: '1', name: '使用Monaco Editor提供语法高亮' },
                          { id: '2', name: '支持JavaScript语言定义' },
                        ],
                        notes: [
                          { id: '1', name: '语法高亮基于Monaco Editor的内置JavaScript支持' },
                        ],
                      },
                      {
                        purpose: '输入af.后出现代码补全提示,包括request,http,envs等API',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在编辑器中输入af.' },
                          { id: '2', name: '等待代码补全列表出现' },
                          { id: '3', name: '观察补全列表中是否包含request,http,envs,variables,cookies等API' },
                          { id: '4', name: '选择request并观察子属性补全' },
                        ],
                        expectedResults: [
                          { id: '1', name: '输入af.后自动弹出代码补全列表' },
                          { id: '2', name: '补全列表包含所有af对象的可用API(request,http,envs,variables,cookies等)' },
                          { id: '3', name: '可以通过键盘或鼠标选择补全项' },
                          { id: '4', name: '选择request后可以继续补全其属性(如request.prefix,request.path等)' },
                        ],
                        checkpoints: [
                          { id: '1', name: '代码补全通过Monaco Editor的IntelliSense实现' },
                          { id: '2', name: '补全列表包含所有af API定义' },
                        ],
                        notes: [
                          { id: '1', name: '代码补全通过ProvideCompletionItems实现' },
                          { id: '2', name: '支持嵌套属性补全' },
                        ],
                      },
                      {
                        purpose: '点击格式化按钮,代码格式化正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '编辑器中有未格式化的JavaScript代码' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在编辑器中输入格式不规范的JavaScript代码(如缩进不对,括号不整齐)' },
                          { id: '2', name: '点击编辑器的格式化按钮' },
                          { id: '3', name: '观察代码是否被正确格式化' },
                        ],
                        expectedResults: [
                          { id: '1', name: '点击格式化按钮后代码自动重新格式化' },
                          { id: '2', name: '缩进统一为规范的空格数(如2空格或4空格)' },
                          { id: '3', name: '括号对齐,代码结构清晰' },
                          { id: '4', name: '格式化后代码仍能正常执行' },
                        ],
                        checkpoints: [
                          { id: '1', name: '格式化通过Prettier或Monaco Editor的格式化服务实现' },
                          { id: '2', name: '保持代码功能不变' },
                        ],
                        notes: [
                          { id: '1', name: '格式化遵循JavaScript标准风格指南' },
                        ],
                      },
                      {
                        purpose: '鼠标悬停在af对象属性上时显示API说明提示',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '编辑器中已输入af.request或其他af API' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在编辑器中输入代码af.request.prefix' },
                          { id: '2', name: '鼠标悬停在request属性上' },
                          { id: '3', name: '观察是否显示说明提示' },
                          { id: '4', name: '鼠标悬停在prefix属性上' },
                          { id: '5', name: '观察说明提示的内容' },
                        ],
                        expectedResults: [
                          { id: '1', name: '鼠标悬停时显示对应属性的说明提示(Hover提示)' },
                          { id: '2', name: '提示包含属性的描述,类型等信息' },
                          { id: '3', name: '提示及时出现和消失' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'Hover提示通过Monaco Editor的Hover服务实现' },
                          { id: '2', name: '提示内容来自af API定义' },
                        ],
                        notes: [
                          { id: '1', name: '鼠标悬停提示基于Monaco Editor的IntelliSense' },
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'af.request API',
                    description: 'af.request API',
                    atomicFunc: [
                      {
                        purpose: '使用af.request.prefix获取并修改请求前缀,发送请求后验证前缀已更改',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '请求URL包含前缀部分' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入:af.request.prefix = "http://new-api.example.com"' },
                          { id: '2', name: '点击发送请求按钮' },
                          { id: '3', name: '在响应区域查看实际请求的URL' },
                        ],
                        expectedResults: [
                          { id: '1', name: '前置脚本正确执行,请求前缀被修改' },
                          { id: '2', name: '实际发送的请求使用修改后的前缀' },
                          { id: '3', name: '响应区域显示修改后的完整URL' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.request.prefix属性可读写' },
                          { id: '2', name: '修改生效于实际HTTP请求' },
                        ],
                        notes: [
                          { id: '1', name: '前缀是URL的协议和域名部分' },
                        ],
                      },
                      {
                        purpose: '使用af.request.path获取并修改请求路径,发送请求后验证路径已更改',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '请求URL已配置' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入:af.request.path = "/api/v2/users"' },
                          { id: '2', name: '点击发送请求按钮' },
                          { id: '3', name: '在响应区域查看实际请求的URL路径' },
                        ],
                        expectedResults: [
                          { id: '1', name: '前置脚本正确执行,请求路径被修改' },
                          { id: '2', name: '实际发送的请求使用修改后的路径' },
                          { id: '3', name: '响应区域显示修改后的完整URL' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.request.path属性可读写' },
                          { id: '2', name: '修改生效于实际HTTP请求' },
                        ],
                        notes: [
                          { id: '1', name: '路径是URL的路径部分,不包括查询参数' },
                        ],
                      },
                      {
                        purpose: '使用af.request.fullPath获取完整请求路径',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '请求URL已配置,包含查询参数' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入:console.log(af.request.fullPath)' },
                          { id: '2', name: '点击发送请求按钮' },
                          { id: '3', name: '在响应区域的控制台输出中查看打印的fullPath值' },
                        ],
                        expectedResults: [
                          { id: '1', name: '前置脚本正确执行' },
                          { id: '2', name: '控制台输出显示完整的请求路径和查询参数' },
                          { id: '3', name: 'fullPath包含路径和所有查询参数' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.request.fullPath属性可读' },
                          { id: '2', name: 'fullPath包含path + query参数' },
                        ],
                        notes: [
                          { id: '1', name: '完整路径包括路径和所有查询参数' },
                        ],
                      },
                      {
                        purpose: '使用af.request.headers获取并修改请求头,发送请求后验证请求头已更改',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '请求已配置了初始请求头' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入:af.request.headers["X-Custom-Header"] = "custom-value"' },
                          { id: '2', name: '点击发送请求按钮' },
                          { id: '3', name: '在响应区域查看实际发送的请求头' },
                        ],
                        expectedResults: [
                          { id: '1', name: '前置脚本正确执行,请求头被修改' },
                          { id: '2', name: '自定义请求头成功添加到请求中' },
                          { id: '3', name: '响应区域的请求头信息中包含修改后的自定义头' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.request.headers属性可读写' },
                          { id: '2', name: '修改的请求头生效于实际HTTP请求' },
                        ],
                        notes: [
                          { id: '1', name: '请求头为键值对对象' },
                        ],
                      },
                      {
                        purpose: '使用af.request.queryParams获取并修改Query参数,发送请求后验证参数已更改',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '请求已配置了初始查询参数' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入:af.request.queryParams["page"] = "2"' },
                          { id: '2', name: '点击发送请求按钮' },
                          { id: '3', name: '在响应区域查看实际请求的URL' },
                        ],
                        expectedResults: [
                          { id: '1', name: '前置脚本正确执行,查询参数被修改' },
                          { id: '2', name: '实际发送的请求URL包含修改后的查询参数' },
                          { id: '3', name: '响应区域显示修改后的完整URL' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.request.queryParams属性可读写' },
                          { id: '2', name: '修改的查询参数生效于实际HTTP请求' },
                        ],
                        notes: [
                          { id: '1', name: '查询参数为键值对对象' },
                        ],
                      },
                      {
                        purpose: '使用af.request.pathParams获取并修改Path参数,发送请求后验证参数已更改',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '请求URL已配置了路径参数' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入:af.request.pathParams["id"] = "999"' },
                          { id: '2', name: '点击发送请求按钮' },
                          { id: '3', name: '在响应区域查看实际请求的URL' },
                        ],
                        expectedResults: [
                          { id: '1', name: '前置脚本正确执行,路径参数被修改' },
                          { id: '2', name: '实际发送的请求URL中路径参数被替换' },
                          { id: '3', name: '响应区域显示修改后的完整URL' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.request.pathParams属性可读写' },
                          { id: '2', name: '修改的路径参数生效于实际HTTP请求' },
                        ],
                        notes: [
                          { id: '1', name: '路径参数对应URL中的{paramName}占位符' },
                        ],
                      },
                      {
                        purpose: '使用af.request.body.json获取并修改JSON body,发送请求后验证body已更改',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '请求已配置JSON body' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入:af.request.body.json.username = "newuser"' },
                          { id: '2', name: '点击发送请求按钮' },
                          { id: '3', name: '在响应区域查看实际请求的body' },
                        ],
                        expectedResults: [
                          { id: '1', name: '前置脚本正确执行,JSON body被修改' },
                          { id: '2', name: '实际发送的请求body中JSON字段被修改' },
                          { id: '3', name: '响应区域显示修改后的body内容' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.request.body.json属性可读写' },
                          { id: '2', name: '修改的JSON字段生效于实际HTTP请求' },
                        ],
                        notes: [
                          { id: '1', name: '仅当body类型为JSON时可用' },
                        ],
                      },
                      {
                        purpose: '使用af.request.body.formdata获取并修改formdata body,发送请求后验证body已更改',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '请求已配置FormData body' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入:af.request.body.formdata["fieldname"] = "newvalue"' },
                          { id: '2', name: '点击发送请求按钮' },
                          { id: '3', name: '在响应区域查看实际请求的body' },
                        ],
                        expectedResults: [
                          { id: '1', name: '前置脚本正确执行,FormData body被修改' },
                          { id: '2', name: '实际发送的请求body中FormData字段被修改' },
                          { id: '3', name: '响应区域显示修改后的body内容' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.request.body.formdata属性可读写' },
                          { id: '2', name: '修改的FormData字段生效于实际HTTP请求' },
                        ],
                        notes: [
                          { id: '1', name: '仅当body类型为FormData时可用' },
                        ],
                      },
                      {
                        purpose: '使用af.request.method获取并修改请求方法,发送请求后验证方法已更改',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '请求已配置' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入:af.request.method = "PUT"' },
                          { id: '2', name: '点击发送请求按钮' },
                          { id: '3', name: '在响应区域查看实际请求的HTTP方法' },
                        ],
                        expectedResults: [
                          { id: '1', name: '前置脚本正确执行,HTTP方法被修改' },
                          { id: '2', name: '实际发送的请求使用修改后的HTTP方法' },
                          { id: '3', name: '响应区域显示修改后的HTTP方法' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.request.method属性可读写' },
                          { id: '2', name: '修改的HTTP方法生效于实际HTTP请求' },
                        ],
                        notes: [
                          { id: '1', name: '支持的方法包括:GET,POST,PUT,DELETE,PATCH,HEAD,OPTIONS等' },
                        ],
                      },
                      {
                        purpose: '使用af.request.replaceUrl()替换整个URL,发送请求后验证URL已更改',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '请求已配置' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入:af.request.replaceUrl("https://new-api.example.com/api/v2/users?id=123")' },
                          { id: '2', name: '点击发送请求按钮' },
                          { id: '3', name: '在响应区域查看实际请求的完整URL' },
                        ],
                        expectedResults: [
                          { id: '1', name: '前置脚本正确执行,整个URL被替换' },
                          { id: '2', name: '实际发送的请求使用新的完整URL' },
                          { id: '3', name: '响应区域显示新的完整URL' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.request.replaceUrl()方法可调用' },
                          { id: '2', name: '新的完整URL生效于实际HTTP请求' },
                        ],
                        notes: [
                          { id: '1', name: 'replaceUrl()方法替换整个URL,包括前缀,路径和查询参数' },
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'af.http API',
                    description: 'af.http API',
                    atomicFunc: [
                      {
                        purpose: '使用af.http.get()发送GET请求,请求成功并获取响应数据',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '有可用的GET接口URL' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入:const response = await af.http.get("https://api.example.com/users")' },
                          { id: '2', name: '添加日志输出该响应:console.log(response)' },
                          { id: '3', name: '点击发送请求按钮' },
                          { id: '4', name: '在响应区域查看控制台输出' },
                        ],
                        expectedResults: [
                          { id: '1', name: '前置脚本正确执行GET请求' },
                          { id: '2', name: '返回响应对象包含状态码,响应头,响应体等信息' },
                          { id: '3', name: '控制台输出显示响应数据' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.http.get()方法可调用' },
                          { id: '2', name: '支持async/await异步调用' },
                          { id: '3', name: '返回完整的响应对象' },
                        ],
                        notes: [
                          { id: '1', name: '可以在前置脚本中进行其他API调用' },
                        ],
                      },
                      {
                        purpose: '使用af.http.post()发送POST请求,请求成功并获取响应数据',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '有可用的POST接口URL' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入:const response = await af.http.post("https://api.example.com/users", { name: "John" })' },
                          { id: '2', name: '添加日志输出该响应' },
                          { id: '3', name: '点击发送请求按钮' },
                          { id: '4', name: '在响应区域查看控制台输出' },
                        ],
                        expectedResults: [
                          { id: '1', name: '前置脚本正确执行POST请求' },
                          { id: '2', name: '返回响应对象包含状态码,响应头,响应体等信息' },
                          { id: '3', name: '控制台输出显示响应数据' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.http.post()方法可调用' },
                          { id: '2', name: '支持传递请求体数据' },
                          { id: '3', name: '返回完整的响应对象' },
                        ],
                        notes: [
                          { id: '1', name: 'POST请求可以传递数据作为第二个参数' },
                        ],
                      },
                      {
                        purpose: '使用af.http.put()发送PUT请求,请求成功并获取响应数据',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '有可用的PUT接口URL' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入:const response = await af.http.put("https://api.example.com/users/123", { name: "Jane" })' },
                          { id: '2', name: '添加日志输出该响应' },
                          { id: '3', name: '点击发送请求按钮' },
                          { id: '4', name: '在响应区域查看控制台输出' },
                        ],
                        expectedResults: [
                          { id: '1', name: '前置脚本正确执行PUT请求' },
                          { id: '2', name: '返回响应对象包含状态码,响应头,响应体等信息' },
                          { id: '3', name: '控制台输出显示响应数据' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.http.put()方法可调用' },
                          { id: '2', name: '支持传递请求体数据' },
                          { id: '3', name: '返回完整的响应对象' },
                        ],
                        notes: [
                          { id: '1', name: 'PUT请求通常用于更新资源' },
                        ],
                      },
                      {
                        purpose: '使用af.http.delete()发送DELETE请求,请求成功并获取响应数据',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '有可用的DELETE接口URL' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入:const response = await af.http.delete("https://api.example.com/users/123")' },
                          { id: '2', name: '添加日志输出该响应' },
                          { id: '3', name: '点击发送请求按钮' },
                          { id: '4', name: '在响应区域查看控制台输出' },
                        ],
                        expectedResults: [
                          { id: '1', name: '前置脚本正确执行DELETE请求' },
                          { id: '2', name: '返回响应对象包含状态码,响应头,响应体等信息' },
                          { id: '3', name: '控制台输出显示响应数据' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.http.delete()方法可调用' },
                          { id: '2', name: '返回完整的响应对象' },
                        ],
                        notes: [
                          { id: '1', name: 'DELETE请求通常用于删除资源' },
                        ],
                      },
                      {
                        purpose: 'af.http请求失败时正确抛出错误并在响应区域展示错误信息',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入:try { const response = await af.http.get("https://api.example.com/invalid-endpoint") } catch(e) { console.error(e.message) }' },
                          { id: '2', name: '点击发送请求按钮' },
                          { id: '3', name: '在响应区域查看错误信息' },
                        ],
                        expectedResults: [
                          { id: '1', name: '请求失败时正确抛出错误' },
                          { id: '2', name: '错误信息可以被catch捕获' },
                          { id: '3', name: '响应区域显示详细的错误信息(如网络错误,超时等)' },
                        ],
                        checkpoints: [
                          { id: '1', name: '请求失败时抛出异常对象' },
                          { id: '2', name: '异常可以被try-catch捕获' },
                          { id: '3', name: '错误信息包含错误类型和详细描述' },
                        ],
                        notes: [
                          { id: '1', name: '错误处理使用标准的JavaScript异常机制' },
                        ],
                      },
                    ],
                  },
                  {
                    modelName: '环境变量访问',
                    description: '环境变量访问',
                    atomicFunc: [
                      {
                        purpose: '使用af.envs获取所有环境变量列表',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '已配置多个环境变量' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入:console.log(af.envs)' },
                          { id: '2', name: '点击发送请求按钮' },
                          { id: '3', name: '在响应区域的控制台输出中查看所有环境变量' },
                        ],
                        expectedResults: [
                          { id: '1', name: '前置脚本正确执行' },
                          { id: '2', name: '输出显示所有可用的环境变量列表' },
                          { id: '3', name: '列表包含所有已配置的环境及其变量集合' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.envs属性可读' },
                          { id: '2', name: '返回所有环境变量的完整列表' },
                        ],
                        notes: [
                          { id: '1', name: 'af.envs返回环境变量对象或数组' },
                        ],
                      },
                      {
                        purpose: '使用af.currentEnv获取当前激活的环境变量',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                          { id: '2', name: '已激活某个环境' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入:console.log(af.currentEnv)' },
                          { id: '2', name: '点击发送请求按钮' },
                          { id: '3', name: '在响应区域的控制台输出中查看当前环境变量' },
                        ],
                        expectedResults: [
                          { id: '1', name: '前置脚本正确执行' },
                          { id: '2', name: '输出显示当前激活的环境名称' },
                          { id: '3', name: '可以访问该环境下的所有变量' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.currentEnv属性可读' },
                          { id: '2', name: '返回当前激活的环境信息' },
                        ],
                        notes: [
                          { id: '1', name: 'af.currentEnv返回当前激活环境的变量集合' },
                        ],
                      },
                    ],
                  },
                  {
                    modelName: '脚本执行',
                    description: '脚本执行',
                    atomicFunc: [
                      {
                        purpose: '前置脚本语法错误时,发送请求后在响应区域展示脚本错误信息',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入有语法错误的代码:const x = { invalid syntax }' },
                          { id: '2', name: '点击发送请求按钮' },
                          { id: '3', name: '观察响应区域是否显示脚本错误信息' },
                        ],
                        expectedResults: [
                          { id: '1', name: '脚本执行失败' },
                          { id: '2', name: '响应区域显示脚本语法错误信息' },
                          { id: '3', name: '错误信息包含错误行号和具体的语法错误描述' },
                        ],
                        checkpoints: [
                          { id: '1', name: '脚本语法检查功能正常' },
                          { id: '2', name: '错误信息清晰准确' },
                        ],
                        notes: [
                          { id: '1', name: '语法错误包括括号不匹配,关键字拼写错误等' },
                        ],
                      },
                      {
                        purpose: '前置脚本运行时错误时,发送请求后在响应区域展示运行时错误信息',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入会导致运行时错误的代码:const x = null; x.property' },
                          { id: '2', name: '点击发送请求按钮' },
                          { id: '3', name: '观察响应区域是否显示脚本运行时错误信息' },
                        ],
                        expectedResults: [
                          { id: '1', name: '脚本执行失败' },
                          { id: '2', name: '响应区域显示脚本运行时错误信息' },
                          { id: '3', name: '错误信息包含错误类型和具体的错误描述' },
                        ],
                        checkpoints: [
                          { id: '1', name: '脚本运行时错误捕获功能正常' },
                          { id: '2', name: '错误信息清晰准确' },
                        ],
                        notes: [
                          { id: '1', name: '运行时错误包括类型错误,引用错误等' },
                        ],
                      },
                      {
                        purpose: '前置脚本正常执行后,主请求继续发送',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的前置脚本区域和请求配置' },
                          { id: '2', name: '主请求已配置' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在前置脚本中输入正确的脚本代码' },
                          { id: '2', name: '点击发送请求按钮' },
                          { id: '3', name: '在响应区域查看是否发送了主请求并获得响应' },
                        ],
                        expectedResults: [
                          { id: '1', name: '前置脚本正常执行' },
                          { id: '2', name: '脚本执行完成后主请求继续发送' },
                          { id: '3', name: '响应区域显示主请求的响应数据(不是脚本错误)' },
                        ],
                        checkpoints: [
                          { id: '1', name: '脚本执行和主请求是独立的流程' },
                          { id: '2', name: '脚本正确执行后主请求正常发送' },
                        ],
                        notes: [
                          { id: '1', name: '前置脚本的作用是在主请求前修改请求或执行其他操作' },
                        ],
                      },
                    ],
                  },
                ],
              },
              // 后置脚本
              {
                modelName: 'afterScript',
                description: '后置脚本',
                children: [
                  {
                    modelName: '编辑器功能',
                    description: '编辑器功能',
                    atomicFunc: [
                      {
                        purpose: '后置脚本编辑器支持JavaScript语法高亮',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在编辑器中输入JavaScript代码,包括关键字,函数,变量等' },
                          { id: '2', name: '观察不同类型代码的颜色显示' },
                        ],
                        expectedResults: [
                          { id: '1', name: '编辑器显示JavaScript语法高亮' },
                          { id: '2', name: '关键字显示为蓝色,字符串显示为绿色,注释显示为灰色等' },
                          { id: '3', name: '语法高亮准确反映JavaScript语法' },
                        ],
                        checkpoints: [
                          { id: '1', name: '使用Monaco Editor提供语法高亮' },
                          { id: '2', name: '支持JavaScript语言定义' },
                        ],
                        notes: [
                          { id: '1', name: '语法高亮基于Monaco Editor的内置JavaScript支持' },
                        ],
                      },
                      {
                        purpose: '输入af.后出现代码补全提示,包括response,sessionStorage,localStorage,cookies,variables等API',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在编辑器中输入af.' },
                          { id: '2', name: '等待代码补全列表出现' },
                          { id: '3', name: '观察补全列表中是否包含response,sessionStorage,localStorage,cookies,variables等API' },
                          { id: '4', name: '选择response并观察子属性补全' },
                        ],
                        expectedResults: [
                          { id: '1', name: '输入af.后自动弹出代码补全列表' },
                          { id: '2', name: '补全列表包含所有af对象的可用API(response,sessionStorage,localStorage,cookies,variables等)' },
                          { id: '3', name: '可以通过键盘或鼠标选择补全项' },
                          { id: '4', name: '选择response后可以继续补全其属性(如response.statusCode,response.headers等)' },
                        ],
                        checkpoints: [
                          { id: '1', name: '代码补全通过Monaco Editor的IntelliSense实现' },
                          { id: '2', name: '补全列表包含所有af API定义' },
                        ],
                        notes: [
                          { id: '1', name: '后置脚本的af API与前置脚本不同,提供response等响应相关API' },
                        ],
                      },
                      {
                        purpose: '点击格式化按钮,代码格式化正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '编辑器中有未格式化的JavaScript代码' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在编辑器中输入格式不规范的JavaScript代码(如缩进不对,括号不整齐)' },
                          { id: '2', name: '点击编辑器的格式化按钮' },
                          { id: '3', name: '观察代码是否被正确格式化' },
                        ],
                        expectedResults: [
                          { id: '1', name: '点击格式化按钮后代码自动重新格式化' },
                          { id: '2', name: '缩进统一为规范的空格数(如2空格或4空格)' },
                          { id: '3', name: '括号对齐,代码结构清晰' },
                          { id: '4', name: '格式化后代码仍能正常执行' },
                        ],
                        checkpoints: [
                          { id: '1', name: '格式化通过Prettier或Monaco Editor的格式化服务实现' },
                          { id: '2', name: '保持代码功能不变' },
                        ],
                        notes: [
                          { id: '1', name: '格式化遵循JavaScript标准风格指南' },
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'af.response API',
                    description: 'af.response API',
                    atomicFunc: [
                      {
                        purpose: '使用af.response.statusCode获取响应状态码',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已发送请求并获得响应' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:console.log(af.response.statusCode)' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '在响应区域的控制台输出中查看状态码' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '控制台输出显示响应的HTTP状态码(如200,404等)' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.response.statusCode属性可读' },
                          { id: '2', name: '返回正确的HTTP状态码数值' },
                        ],
                        notes: [
                          { id: '1', name: '状态码在响应完成后通过后置脚本可以获取' },
                        ],
                      },
                      {
                        purpose: '使用af.response.headers获取响应头',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已发送请求并获得响应' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:console.log(af.response.headers)' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '在响应区域的控制台输出中查看响应头对象' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '控制台输出显示响应头对象,包含Content-Type,Content-Length等' },
                          { id: '3', name: '可以访问特定的响应头,如af.response.headers["content-type"]' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.response.headers属性可读' },
                          { id: '2', name: '返回响应头键值对对象' },
                        ],
                        notes: [
                          { id: '1', name: '响应头为键值对对象格式' },
                        ],
                      },
                      {
                        purpose: '使用af.response.cookies获取响应Cookie',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已发送请求并获得包含Set-Cookie的响应' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:console.log(af.response.cookies)' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '在响应区域的控制台输出中查看Cookie信息' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '控制台输出显示响应中设置的Cookie信息' },
                          { id: '3', name: '如果响应包含Set-Cookie头,可以访问Cookie详情' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.response.cookies属性可读' },
                          { id: '2', name: '返回响应中的Cookie信息' },
                        ],
                        notes: [
                          { id: '1', name: '只有在响应包含Set-Cookie时才会有值' },
                        ],
                      },
                      {
                        purpose: '使用af.response.body获取响应体数据',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已发送请求并获得响应' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:console.log(af.response.body)' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '在响应区域的控制台输出中查看响应体' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '控制台输出显示完整的响应体数据' },
                          { id: '3', name: '响应体可以是JSON对象,字符串,HTML等' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.response.body属性可读' },
                          { id: '2', name: '返回响应体的实际内容' },
                        ],
                        notes: [
                          { id: '1', name: '响应体可以是任何格式的数据' },
                        ],
                      },
                      {
                        purpose: '使用af.response.rt获取响应时长',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已发送请求并获得响应' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:console.log(af.response.rt)' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '在响应区域的控制台输出中查看响应时长' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '控制台输出显示响应时长(毫秒)' },
                          { id: '3', name: '响应时长是数值类型,表示从请求发送到收到完整响应的时间' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.response.rt属性可读' },
                          { id: '2', name: '返回响应时长数值(毫秒)' },
                        ],
                        notes: [
                          { id: '1', name: '响应时长(rt)以毫秒为单位' },
                        ],
                      },
                      {
                        purpose: '使用af.response.size获取响应大小',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已发送请求并获得响应' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:console.log(af.response.size)' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '在响应区域的控制台输出中查看响应大小' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '控制台输出显示响应大小(字节)' },
                          { id: '3', name: '响应大小是数值类型,表示响应体的字节数' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.response.size属性可读' },
                          { id: '2', name: '返回响应大小数值(字节)' },
                        ],
                        notes: [
                          { id: '1', name: '响应大小(size)以字节为单位' },
                        ],
                      },
                      {
                        purpose: '使用af.response.ip获取远端IP地址',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已发送请求并获得响应' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:console.log(af.response.ip)' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '在响应区域的控制台输出中查看远端IP地址' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '控制台输出显示响应服务器的IP地址' },
                          { id: '3', name: 'IP地址是字符串格式,如"192.168.1.1"' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.response.ip属性可读' },
                          { id: '2', name: '返回远端服务器的IP地址字符串' },
                        ],
                        notes: [
                          { id: '1', name: '远端IP是响应来源的服务器IP地址' },
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'af.sessionStorage API',
                    description: 'af.sessionStorage API',
                    atomicFunc: [
                      {
                        purpose: '使用af.sessionStorage.set(key, value)存储会话数据',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:af.sessionStorage.set("token", "abc123")' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '数据成功保存在会话存储中' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '会话数据成功存储' },
                          { id: '3', name: '键值对可以在后续请求中访问' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.sessionStorage.set()方法可调用' },
                          { id: '2', name: '数据存储成功' },
                        ],
                        notes: [
                          { id: '1', name: '会话存储只在当前应用会话期间有效' },
                        ],
                      },
                      {
                        purpose: '使用af.sessionStorage.get(key)获取会话数据',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已通过af.sessionStorage.set()存储会话数据' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:const token = af.sessionStorage.get("token"); console.log(token)' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '在控制台输出中查看获取的值' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '成功获取之前存储的会话数据' },
                          { id: '3', name: '控制台输出显示正确的值' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.sessionStorage.get()方法可调用' },
                          { id: '2', name: '返回正确的存储值' },
                        ],
                        notes: [
                          { id: '1', name: '如果键不存在返回null或undefined' },
                        ],
                      },
                      {
                        purpose: '使用af.sessionStorage.remove(key)删除会话数据',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已通过af.sessionStorage.set()存储会话数据' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:af.sessionStorage.remove("token")' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '验证数据已被删除:af.sessionStorage.get("token")返回null' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '会话数据成功删除' },
                          { id: '3', name: '再次获取该键时返回null或undefined' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.sessionStorage.remove()方法可调用' },
                          { id: '2', name: '指定键的数据被删除' },
                        ],
                        notes: [
                          { id: '1', name: '删除不存在的键不会报错' },
                        ],
                      },
                      {
                        purpose: '使用af.sessionStorage.clear()清空所有会话数据',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已存储多个会话数据' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:af.sessionStorage.clear()' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '验证所有数据已清空' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '所有会话数据被清空' },
                          { id: '3', name: '后续get()调用返回null' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.sessionStorage.clear()方法可调用' },
                          { id: '2', name: '清空所有会话数据' },
                        ],
                        notes: [
                          { id: '1', name: '清空操作是不可逆的' },
                        ],
                      },
                      {
                        purpose: '会话数据在关闭应用后清空',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已存储会话数据' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:af.sessionStorage.set("session_key", "session_value")' },
                          { id: '2', name: '发送请求确保数据存储成功' },
                          { id: '3', name: '完全关闭应用(退出Electron)' },
                          { id: '4', name: '重新打开应用' },
                          { id: '5', name: '在后置脚本中验证:console.log(af.sessionStorage.get("session_key"))' },
                          { id: '6', name: '发送请求查看控制台输出' },
                        ],
                        expectedResults: [
                          { id: '1', name: '初始时会话数据存储成功' },
                          { id: '2', name: '应用关闭后会话数据被清空' },
                          { id: '3', name: '重新打开应用后get()返回null(数据已清空)' },
                        ],
                        checkpoints: [
                          { id: '1', name: '会话存储只在应用运行期间保留' },
                          { id: '2', name: '应用关闭时自动清空会话数据' },
                        ],
                        notes: [
                          { id: '1', name: '会话存储的生命周期仅为应用会话期间' },
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'af.localStorage API',
                    description: 'af.localStorage API',
                    atomicFunc: [
                      {
                        purpose: '使用af.localStorage.set(key, value)存储持久数据',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:af.localStorage.set("user_id", "12345")' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '数据成功保存在本地存储中' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '持久数据成功存储' },
                          { id: '3', name: '键值对可以在后续请求中持续访问' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.localStorage.set()方法可调用' },
                          { id: '2', name: '数据存储成功' },
                        ],
                        notes: [
                          { id: '1', name: '本地存储数据在应用关闭后仍然保留' },
                        ],
                      },
                      {
                        purpose: '使用af.localStorage.get(key)获取持久数据',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已通过af.localStorage.set()存储持久数据' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:const userId = af.localStorage.get("user_id"); console.log(userId)' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '在控制台输出中查看获取的值' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '成功获取之前存储的持久数据' },
                          { id: '3', name: '控制台输出显示正确的值' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.localStorage.get()方法可调用' },
                          { id: '2', name: '返回正确的存储值' },
                        ],
                        notes: [
                          { id: '1', name: '如果键不存在返回null或undefined' },
                        ],
                      },
                      {
                        purpose: '使用af.localStorage.remove(key)删除持久数据',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已通过af.localStorage.set()存储持久数据' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:af.localStorage.remove("user_id")' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '验证数据已被删除:af.localStorage.get("user_id")返回null' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '持久数据成功删除' },
                          { id: '3', name: '再次获取该键时返回null或undefined' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.localStorage.remove()方法可调用' },
                          { id: '2', name: '指定键的数据被删除' },
                        ],
                        notes: [
                          { id: '1', name: '删除不存在的键不会报错' },
                        ],
                      },
                      {
                        purpose: '使用af.localStorage.clear()清空所有持久数据',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已存储多个持久数据' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:af.localStorage.clear()' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '验证所有数据已清空' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '所有持久数据被清空' },
                          { id: '3', name: '后续get()调用返回null' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.localStorage.clear()方法可调用' },
                          { id: '2', name: '清空所有持久数据' },
                        ],
                        notes: [
                          { id: '1', name: '清空操作是不可逆的' },
                        ],
                      },
                      {
                        purpose: '持久数据在关闭应用后仍然保留',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:af.localStorage.set("persist_key", "persist_value")' },
                          { id: '2', name: '发送请求确保数据存储成功' },
                          { id: '3', name: '完全关闭应用(退出Electron)' },
                          { id: '4', name: '重新打开应用' },
                          { id: '5', name: '在后置脚本中验证:console.log(af.localStorage.get("persist_key"))' },
                          { id: '6', name: '发送请求查看控制台输出' },
                        ],
                        expectedResults: [
                          { id: '1', name: '初始时持久数据存储成功' },
                          { id: '2', name: '应用关闭后持久数据仍然保留' },
                          { id: '3', name: '重新打开应用后get()返回存储的值(数据未被清空)' },
                        ],
                        checkpoints: [
                          { id: '1', name: '持久存储在应用生命周期内保留' },
                          { id: '2', name: '应用关闭和重新启动不影响数据' },
                        ],
                        notes: [
                          { id: '1', name: '本地存储的生命周期超越应用会话期间' },
                          { id: '2', name: '只有显式调用remove()或clear()才能删除数据' },
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'af.cookies API',
                    description: 'af.cookies API',
                    atomicFunc: [
                      {
                        purpose: '使用af.cookies.get(name)获取指定Cookie值',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已存在Cookie数据(通过响应头Set-Cookie或脚本设置)' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:const sessionId = af.cookies.get("session_id"); console.log(sessionId)' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '在控制台输出中查看Cookie值' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '成功获取指定的Cookie值' },
                          { id: '3', name: '控制台输出显示正确的Cookie值' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.cookies.get()方法可调用' },
                          { id: '2', name: '返回正确的Cookie值' },
                        ],
                        notes: [
                          { id: '1', name: '如果Cookie不存在返回null或undefined' },
                        ],
                      },
                      {
                        purpose: '使用af.cookies.getAll()获取所有Cookie',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已存在多个Cookie数据' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:const allCookies = af.cookies.getAll(); console.log(allCookies)' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '在控制台输出中查看所有Cookie' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '获取所有可用的Cookie' },
                          { id: '3', name: '控制台输出显示Cookie对象或数组' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.cookies.getAll()方法可调用' },
                          { id: '2', name: '返回所有Cookie的集合' },
                        ],
                        notes: [
                          { id: '1', name: '返回值可能是对象或数组格式' },
                        ],
                      },
                      {
                        purpose: '使用af.cookies.set(name, value)设置Cookie值',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:af.cookies.set("auth_token", "xyz789")' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '在后续请求中验证Cookie已设置' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: 'Cookie成功设置' },
                          { id: '3', name: '后续请求的请求头中包含该Cookie' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.cookies.set()方法可调用' },
                          { id: '2', name: 'Cookie成功保存' },
                        ],
                        notes: [
                          { id: '1', name: 'Cookie在后续请求中自动附加到请求头' },
                        ],
                      },
                      {
                        purpose: '使用af.cookies.remove(name)删除Cookie',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已存在Cookie数据' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:af.cookies.remove("auth_token")' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '验证Cookie已被删除:af.cookies.get("auth_token")返回null' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: 'Cookie成功删除' },
                          { id: '3', name: '再次获取该Cookie时返回null或undefined' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.cookies.remove()方法可调用' },
                          { id: '2', name: '指定的Cookie被删除' },
                        ],
                        notes: [
                          { id: '1', name: '删除不存在的Cookie不会报错' },
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'af.variables API',
                    description: 'af.variables API',
                    atomicFunc: [
                      {
                        purpose: '使用af.variables.get(name)获取指定变量值',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已定义变量或通过脚本设置了变量' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:const apiUrl = af.variables.get("api_url"); console.log(apiUrl)' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '在控制台输出中查看变量值' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '成功获取指定变量的值' },
                          { id: '3', name: '控制台输出显示正确的变量值' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.variables.get()方法可调用' },
                          { id: '2', name: '返回正确的变量值' },
                        ],
                        notes: [
                          { id: '1', name: '如果变量不存在返回null或undefined' },
                        ],
                      },
                      {
                        purpose: '使用af.variables.set(name, value)设置变量值',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入:af.variables.set("next_page", 2)' },
                          { id: '2', name: '再次发送请求' },
                          { id: '3', name: '验证变量已被设置并可以在后续请求中使用' },
                        ],
                        expectedResults: [
                          { id: '1', name: '后置脚本正确执行' },
                          { id: '2', name: '变量成功设置' },
                          { id: '3', name: '在后续请求中可以通过{{next_page}}访问该变量' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'af.variables.set()方法可调用' },
                          { id: '2', name: '变量值成功保存' },
                        ],
                        notes: [
                          { id: '1', name: '设置的变量作用域为当前项目或会话' },
                        ],
                      },
                      {
                        purpose: '后置脚本中设置的变量在下次请求中可以使用',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                          { id: '2', name: '已配置前一个请求的后置脚本用于设置变量' },
                        ],
                        operationSteps: [
                          { id: '1', name: '第一个请求的后置脚本中输入:af.variables.set("token_from_response", response.body.token)' },
                          { id: '2', name: '发送第一个请求' },
                          { id: '3', name: '在第二个请求的URL或Header中使用该变量:{{token_from_response}}' },
                          { id: '4', name: '发送第二个请求' },
                          { id: '5', name: '验证变量值已被正确替换' },
                        ],
                        expectedResults: [
                          { id: '1', name: '第一个请求的后置脚本成功设置变量' },
                          { id: '2', name: '第二个请求可以访问到该变量' },
                          { id: '3', name: '变量值在请求中被正确替换' },
                        ],
                        checkpoints: [
                          { id: '1', name: '变量持久化存储正常' },
                          { id: '2', name: '变量在请求前的替换流程中可用' },
                        ],
                        notes: [
                          { id: '1', name: '变量的跨请求使用是测试链接多个API的关键' },
                        ],
                      },
                    ],
                  },
                  {
                    modelName: '脚本执行',
                    description: '脚本执行',
                    atomicFunc: [
                      {
                        purpose: '后置脚本语法错误时,在响应区域展示脚本错误信息',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入有语法错误的代码:const x = { invalid syntax }' },
                          { id: '2', name: '发送请求' },
                          { id: '3', name: '观察响应区域是否显示脚本错误信息' },
                        ],
                        expectedResults: [
                          { id: '1', name: '脚本执行失败' },
                          { id: '2', name: '响应区域显示脚本语法错误信息' },
                          { id: '3', name: '错误信息包含错误行号和具体的语法错误描述' },
                        ],
                        checkpoints: [
                          { id: '1', name: '脚本语法检查功能正常' },
                          { id: '2', name: '错误信息清晰准确' },
                        ],
                        notes: [
                          { id: '1', name: '语法错误包括括号不匹配,关键字拼写错误等' },
                        ],
                      },
                      {
                        purpose: '后置脚本运行时错误时,在响应区域展示运行时错误信息',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入会导致运行时错误的代码:const x = null; x.property' },
                          { id: '2', name: '发送请求' },
                          { id: '3', name: '观察响应区域是否显示脚本运行时错误信息' },
                        ],
                        expectedResults: [
                          { id: '1', name: '脚本执行失败' },
                          { id: '2', name: '响应区域显示脚本运行时错误信息' },
                          { id: '3', name: '错误信息包含错误类型和具体的错误描述' },
                        ],
                        checkpoints: [
                          { id: '1', name: '脚本运行时错误捕获功能正常' },
                          { id: '2', name: '错误信息清晰准确' },
                        ],
                        notes: [
                          { id: '1', name: '运行时错误包括类型错误,引用错误等' },
                        ],
                      },
                      {
                        purpose: '后置脚本在主请求响应后执行',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点编辑页面的后置脚本区域和请求配置' },
                          { id: '2', name: '主请求已配置' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在后置脚本中输入访问响应的代码:console.log(af.response.statusCode)' },
                          { id: '2', name: '发送请求' },
                          { id: '3', name: '观察响应区域的执行顺序:先显示主请求响应,再执行后置脚本' },
                        ],
                        expectedResults: [
                          { id: '1', name: '主请求首先执行并收到响应' },
                          { id: '2', name: '后置脚本在主请求完成后执行' },
                          { id: '3', name: '后置脚本可以访问主请求的响应数据' },
                        ],
                        checkpoints: [
                          { id: '1', name: '脚本执行顺序正确' },
                          { id: '2', name: '后置脚本可以访问响应对象' },
                        ],
                        notes: [
                          { id: '1', name: '后置脚本的作用是在主请求完成后对响应进行处理' },
                        ],
                      },
                    ],
                  },
                ],
              },
              // 备注
              {
                modelName: 'remark',
                description: '备注',
                atomicFunc: [
                  {
                    purpose: '备注编辑器支持Markdown格式输入和预览',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面的备注区域' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在备注编辑器中输入Markdown格式内容' },
                      { id: '2', name: '切换到预览模式或观察编辑器的实时预览' },
                      { id: '3', name: '观察Markdown内容是否正确渲染' },
                    ],
                    expectedResults: [
                      { id: '1', name: '备注编辑器支持Markdown输入' },
                      { id: '2', name: 'Markdown内容正确渲染为格式化内容' },
                      { id: '3', name: '编辑和预览模式之间可以切换' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'Markdown编辑器基于标准Markdown语法' },
                      { id: '2', name: '预览功能可用' },
                    ],
                    notes: [
                      { id: '1', name: '备注用于记录API的使用说明或测试备忘' },
                    ],
                  },
                  {
                    purpose: '输入普通文本后保存,刷新页面内容保持不变',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面的备注区域' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在备注编辑器中输入普通文本:测试备注' },
                      { id: '2', name: '保存内容(Ctrl+S或点击保存按钮)' },
                      { id: '3', name: '刷新页面或重新打开该节点' },
                      { id: '4', name: '验证备注内容是否保持不变' },
                    ],
                    expectedResults: [
                      { id: '1', name: '普通文本成功输入' },
                      { id: '2', name: '保存后内容持久化' },
                      { id: '3', name: '刷新后备注内容完全保持不变' },
                    ],
                    checkpoints: [
                      { id: '1', name: '备注内容正确保存到数据库' },
                      { id: '2', name: '刷新不会丢失内容' },
                    ],
                    notes: [
                      { id: '1', name: '备注内容是持久化的' },
                    ],
                  },
                  {
                    purpose: '输入Markdown标题(# 标题)正确渲染为标题样式',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面的备注区域' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在备注编辑器中输入:# 主标题' },
                      { id: '2', name: '输入:## 子标题' },
                      { id: '3', name: '切换到预览模式查看渲染效果' },
                    ],
                    expectedResults: [
                      { id: '1', name: '# 号标题渲染为大标题样式' },
                      { id: '2', name: '## 号标题渲染为中等标题样式' },
                      { id: '3', name: '标题大小和样式正确区分' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'Markdown标题语法支持' },
                      { id: '2', name: '标题样式正确渲染' },
                    ],
                    notes: [
                      { id: '1', name: '支持#,##,###等多级标题' },
                    ],
                  },
                  {
                    purpose: '输入Markdown粗体(**粗体**)正确渲染为粗体样式',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面的备注区域' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在备注编辑器中输入:这是**粗体文本**' },
                      { id: '2', name: '输入:这是***粗体斜体***' },
                      { id: '3', name: '切换到预览模式查看渲染效果' },
                    ],
                    expectedResults: [
                      { id: '1', name: '**粗体文本**渲染为加粗样式' },
                      { id: '2', name: '***粗体斜体***渲染为加粗斜体样式' },
                      { id: '3', name: '样式效果正确' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'Markdown粗体语法支持' },
                      { id: '2', name: '粗体样式正确渲染' },
                    ],
                    notes: [
                      { id: '1', name: '支持**粗体**和***粗体斜体***等格式' },
                    ],
                  },
                  {
                    purpose: '输入Markdown链接([文字](url))正确渲染为可点击链接',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面的备注区域' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在备注编辑器中输入:[Apiflow官网](https://apiflow.example.com)' },
                      { id: '2', name: '切换到预览模式' },
                      { id: '3', name: '验证链接是否可点击' },
                    ],
                    expectedResults: [
                      { id: '1', name: '链接文本显示为可点击的链接样式(通常为蓝色下划线)' },
                      { id: '2', name: '点击链接可以打开指定的URL' },
                      { id: '3', name: '链接跳转正确' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'Markdown链接语法支持' },
                      { id: '2', name: '链接可点击并正确跳转' },
                    ],
                    notes: [
                      { id: '1', name: '链接格式为[显示文本](URL)' },
                    ],
                  },
                  {
                    purpose: '输入Markdown代码块正确渲染并支持语法高亮',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面的备注区域' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在备注编辑器中输入代码块(三个反引号+语言)' },
                      { id: '2', name: '输入:```json\n{"key": "value"}\n```' },
                      { id: '3', name: '切换到预览模式查看渲染效果' },
                    ],
                    expectedResults: [
                      { id: '1', name: '代码块正确显示为代码区域' },
                      { id: '2', name: 'JSON代码支持语法高亮' },
                      { id: '3', name: '代码可读性良好' },
                    ],
                    checkpoints: [
                      { id: '1', name: 'Markdown代码块语法支持' },
                      { id: '2', name: '代码语法高亮功能正常' },
                    ],
                    notes: [
                      { id: '1', name: '支持多种语言的代码高亮(js,json,python等)' },
                    ],
                  },
                  {
                    purpose: '备注内容变更后出现未保存小圆点,保存后小圆点消失',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面的备注区域' },
                      { id: '2', name: '备注已保存' },
                    ],
                    operationSteps: [
                      { id: '1', name: '修改备注内容' },
                      { id: '2', name: '观察节点标签或编辑器标题是否出现未保存标记(通常为小圆点)' },
                      { id: '3', name: '保存内容' },
                      { id: '4', name: '观察未保存标记是否消失' },
                    ],
                    expectedResults: [
                      { id: '1', name: '内容修改后出现未保存标记' },
                      { id: '2', name: '标记清晰可见' },
                      { id: '3', name: '保存后标记立即消失' },
                    ],
                    checkpoints: [
                      { id: '1', name: '未保存状态指示正常工作' },
                      { id: '2', name: '保存状态同步准确' },
                    ],
                    notes: [
                      { id: '1', name: '未保存标记帮助用户了解内容状态' },
                    ],
                  },
                  {
                    purpose: '备注支持撤销操作,ctrl+z可以撤销输入',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面的备注区域' },
                      { id: '2', name: '已在备注中输入内容' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在备注中输入一些文本' },
                      { id: '2', name: '按Ctrl+Z快捷键' },
                      { id: '3', name: '观察最后的输入是否被撤销' },
                    ],
                    expectedResults: [
                      { id: '1', name: '最后的输入被正确撤销' },
                      { id: '2', name: '可以多次撤销回到更早的状态' },
                      { id: '3', name: '撤销功能流畅无卡顿' },
                    ],
                    checkpoints: [
                      { id: '1', name: '撤销功能实现正确' },
                      { id: '2', name: '支持多步撤销' },
                    ],
                    notes: [
                      { id: '1', name: '撤销历史记录在编辑器中维护' },
                    ],
                  },
                  {
                    purpose: '备注支持重做操作,ctrl+shift+z可以重做撤销的操作',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面的备注区域' },
                      { id: '2', name: '已执行过撤销操作' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在备注中输入一些文本' },
                      { id: '2', name: '按Ctrl+Z撤销' },
                      { id: '3', name: '按Ctrl+Shift+Z重做' },
                      { id: '4', name: '观察撤销的内容是否恢复' },
                    ],
                    expectedResults: [
                      { id: '1', name: '撤销的内容被正确恢复' },
                      { id: '2', name: '可以多次重做' },
                      { id: '3', name: '重做功能流畅无卡顿' },
                    ],
                    checkpoints: [
                      { id: '1', name: '重做功能实现正确' },
                      { id: '2', name: '支持多步重做' },
                    ],
                    notes: [
                      { id: '1', name: '重做历史记录在撤销后维护' },
                    ],
                  },
                ],
              },
              // 请求设置
              {
                modelName: 'httpNodeSettings',
                description: '设置',
                children: [
                  {
                    modelName: '请求配置',
                    description: '请求配置',
                    atomicFunc: [
                      {
                        purpose: '修改最大文本Body大小配置,验证超过限制时的处理',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点的设置面板' },
                          { id: '2', name: '请求配置选项可见' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在设置面板中找到"最大文本Body大小"配置项' },
                          { id: '2', name: '修改该值为较小的值,如1MB' },
                          { id: '3', name: '创建一个超过该限制的文本Body请求' },
                          { id: '4', name: '发送请求并观察处理结果' },
                        ],
                        expectedResults: [
                          { id: '1', name: '设置值成功修改' },
                          { id: '2', name: '超过限制时显示警告提示或限制传输' },
                          { id: '3', name: '用户能了解到数据大小的限制' },
                        ],
                        checkpoints: [
                          { id: '1', name: '最大Body大小配置可修改' },
                          { id: '2', name: '超过限制时有相应处理' },
                        ],
                        notes: [
                          { id: '1', name: '防止意外发送过大数据' },
                        ],
                      },
                      {
                        purpose: '修改最大原始Body大小配置,验证超过限制时的处理',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点的设置面板' },
                          { id: '2', name: '请求配置选项可见' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在设置面板中找到"最大原始Body大小"配置项' },
                          { id: '2', name: '修改该值为较小的值,如2MB' },
                          { id: '3', name: '创建一个超过该限制的Raw Body请求' },
                          { id: '4', name: '发送请求并观察处理结果' },
                        ],
                        expectedResults: [
                          { id: '1', name: '设置值成功修改' },
                          { id: '2', name: '超过限制时显示警告提示或限制传输' },
                          { id: '3', name: '用户能了解到原始数据的大小限制' },
                        ],
                        checkpoints: [
                          { id: '1', name: '最大原始Body大小配置可修改' },
                          { id: '2', name: '超过限制时有相应处理' },
                        ],
                        notes: [
                          { id: '1', name: '原始Body指Raw参数类型的数据' },
                        ],
                      },
                      {
                        purpose: '修改自定义User-Agent配置,发送请求后验证User-Agent已更改',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点的设置面板' },
                          { id: '2', name: '请求配置选项可见' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在设置面板中找到"自定义User-Agent"配置项' },
                          { id: '2', name: '输入自定义User-Agent字符串' },
                          { id: '3', name: '保存配置' },
                          { id: '4', name: '发送请求并查看请求头中的User-Agent' },
                        ],
                        expectedResults: [
                          { id: '1', name: '自定义User-Agent配置成功保存' },
                          { id: '2', name: '请求的User-Agent请求头已更改为自定义值' },
                          { id: '3', name: '验证请求头确实包含自定义的User-Agent' },
                        ],
                        checkpoints: [
                          { id: '1', name: '自定义User-Agent配置可修改' },
                          { id: '2', name: '配置生效于实际请求' },
                        ],
                        notes: [
                          { id: '1', name: '用于模拟不同客户端的请求' },
                        ],
                      },
                      {
                        purpose: '修改请求头值最大展示长度配置,验证请求头展示截断正确',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点的设置面板' },
                          { id: '2', name: '请求配置选项可见' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在设置面板中找到"请求头值最大展示长度"配置项' },
                          { id: '2', name: '修改该值为较小的值,如50字符' },
                          { id: '3', name: '保存配置' },
                          { id: '4', name: '添加一个很长的自定义请求头' },
                          { id: '5', name: '发送请求并查看请求头的展示效果' },
                        ],
                        expectedResults: [
                          { id: '1', name: '设置值成功修改' },
                          { id: '2', name: '请求头值在展示时被截断为配置的长度' },
                          { id: '3', name: '可能会显示省略号或提示表示数据被截断' },
                        ],
                        checkpoints: [
                          { id: '1', name: '展示长度配置可修改' },
                          { id: '2', name: '配置生效于响应区域的显示' },
                        ],
                        notes: [
                          { id: '1', name: '只影响UI展示,不影响实际请求' },
                        ],
                      },
                    ],
                  },
                  {
                    modelName: '重定向配置',
                    description: '重定向配置',
                    atomicFunc: [
                      {
                        purpose: '开启自动跟随重定向时,请求自动跟随重定向并返回最终响应',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点的设置面板' },
                          { id: '2', name: '重定向配置选项可见' },
                          { id: '3', name: '有一个返回重定向响应的API' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在设置面板中启用"自动跟随重定向"选项' },
                          { id: '2', name: '保存配置' },
                          { id: '3', name: '发送一个返回301/302重定向的请求' },
                          { id: '4', name: '观察是否自动跟随重定向并返回最终响应' },
                        ],
                        expectedResults: [
                          { id: '1', name: '配置成功启用' },
                          { id: '2', name: '请求自动跟随重定向' },
                          { id: '3', name: '响应显示最终页面的响应数据,而非重定向响应' },
                        ],
                        checkpoints: [
                          { id: '1', name: '重定向配置可启用' },
                          { id: '2', name: '自动跟随重定向功能正常工作' },
                        ],
                        notes: [
                          { id: '1', name: '自动跟随重定向可简化API测试' },
                        ],
                      },
                      {
                        purpose: '关闭自动跟随重定向时,请求返回重定向响应不继续跟随',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点的设置面板' },
                          { id: '2', name: '重定向配置选项可见' },
                          { id: '3', name: '有一个返回重定向响应的API' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在设置面板中禁用"自动跟随重定向"选项' },
                          { id: '2', name: '保存配置' },
                          { id: '3', name: '发送一个返回301/302重定向的请求' },
                          { id: '4', name: '观察是否返回重定向响应并停止' },
                        ],
                        expectedResults: [
                          { id: '1', name: '配置成功禁用' },
                          { id: '2', name: '请求返回重定向响应' },
                          { id: '3', name: '不继续跟随重定向到最终页面' },
                        ],
                        checkpoints: [
                          { id: '1', name: '重定向配置可禁用' },
                          { id: '2', name: '禁用时不自动跟随重定向' },
                        ],
                        notes: [
                          { id: '1', name: '禁用可用于调试重定向逻辑' },
                        ],
                      },
                      {
                        purpose: '修改最大重定向次数配置,超过次数后停止重定向并提示',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点的设置面板' },
                          { id: '2', name: '重定向配置选项可见' },
                          { id: '3', name: '自动跟随重定向已启用' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在设置面板中找到"最大重定向次数"配置' },
                          { id: '2', name: '修改为较小的值,如2次' },
                          { id: '3', name: '保存配置' },
                          { id: '4', name: '发送一个产生多次重定向的请求' },
                          { id: '5', name: '观察是否在超过限制后停止并提示' },
                        ],
                        expectedResults: [
                          { id: '1', name: '配置成功修改' },
                          { id: '2', name: '超过重定向次数后停止跟随' },
                          { id: '3', name: '显示提示或错误信息' },
                        ],
                        checkpoints: [
                          { id: '1', name: '最大重定向次数配置可修改' },
                          { id: '2', name: '超过限制时有相应提示' },
                        ],
                        notes: [
                          { id: '1', name: '防止无限重定向循环' },
                        ],
                      },
                    ],
                  },
                  {
                    modelName: '显示顺序配置',
                    description: '显示顺序配置',
                    atomicFunc: [
                      {
                        purpose: '拖拽调整Body参数模式显示顺序后,Body区域按新顺序展示',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点的设置面板' },
                          { id: '2', name: '显示顺序配置选项可见' },
                          { id: '3', name: 'Body参数模式选项可见(JSON,FormData,Raw等)' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在显示顺序配置中找到Body参数模式列表' },
                          { id: '2', name: '拖拽改变模式的顺序,如将Raw移到最前' },
                          { id: '3', name: '保存配置' },
                          { id: '4', name: '回到请求编辑页面查看Body区域的模式顺序' },
                        ],
                        expectedResults: [
                          { id: '1', name: '顺序成功修改' },
                          { id: '2', name: 'Body区域按新顺序展示参数模式' },
                          { id: '3', name: '拖拽操作流畅无卡顿' },
                        ],
                        checkpoints: [
                          { id: '1', name: 'Body参数模式顺序可拖拽调整' },
                          { id: '2', name: '配置生效于实际UI展示' },
                        ],
                        notes: [
                          { id: '1', name: '帮助用户自定义常用模式的顺序' },
                        ],
                      },
                      {
                        purpose: '拖拽调整标签页显示顺序后,标签按新顺序展示',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点的设置面板' },
                          { id: '2', name: '显示顺序配置选项可见' },
                          { id: '3', name: '标签页选项可见(URL,Params,Body,返回参数等)' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在显示顺序配置中找到标签页列表' },
                          { id: '2', name: '拖拽改变标签页的顺序' },
                          { id: '3', name: '保存配置' },
                          { id: '4', name: '回到请求编辑页面查看标签页顺序' },
                        ],
                        expectedResults: [
                          { id: '1', name: '顺序成功修改' },
                          { id: '2', name: '标签页按新顺序显示' },
                          { id: '3', name: '拖拽操作流畅' },
                        ],
                        checkpoints: [
                          { id: '1', name: '标签页顺序可拖拽调整' },
                          { id: '2', name: '配置生效于实际UI展示' },
                        ],
                        notes: [
                          { id: '1', name: '帮助用户自定义常用标签的顺序' },
                        ],
                      },
                      {
                        purpose: '显示顺序修改后刷新页面,顺序保持不变',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点的设置面板' },
                          { id: '2', name: '已修改了Body参数模式或标签页的顺序' },
                        ],
                        operationSteps: [
                          { id: '1', name: '修改显示顺序配置中的某个顺序' },
                          { id: '2', name: '保存配置' },
                          { id: '3', name: '刷新整个页面' },
                          { id: '4', name: '重新打开httpNode节点的设置面板' },
                          { id: '5', name: '验证顺序是否仍为修改后的顺序' },
                        ],
                        expectedResults: [
                          { id: '1', name: '配置保存成功' },
                          { id: '2', name: '刷新后顺序保持不变' },
                          { id: '3', name: '顺序持久化正确' },
                        ],
                        checkpoints: [
                          { id: '1', name: '显示顺序配置正确保存' },
                          { id: '2', name: '刷新不会重置顺序' },
                        ],
                        notes: [
                          { id: '1', name: '用户偏好设置需要持久化' },
                        ],
                      },
                    ],
                  },
                  {
                    modelName: '恢复默认',
                    description: '恢复默认',
                    atomicFunc: [
                      {
                        purpose: '点击恢复默认按钮,所有配置项恢复为默认值',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点的设置面板' },
                          { id: '2', name: '已修改了多个配置项' },
                        ],
                        operationSteps: [
                          { id: '1', name: '修改设置面板中的多个配置项' },
                          { id: '2', name: '找到"恢复默认"按钮' },
                          { id: '3', name: '点击该按钮' },
                          { id: '4', name: '观察所有配置项是否恢复为默认值' },
                        ],
                        expectedResults: [
                          { id: '1', name: '所有修改的配置项都被恢复' },
                          { id: '2', name: '配置值恢复为系统默认值' },
                          { id: '3', name: '可能显示确认提示' },
                        ],
                        checkpoints: [
                          { id: '1', name: '恢复默认功能正常工作' },
                          { id: '2', name: '所有配置项都被重置' },
                        ],
                        notes: [
                          { id: '1', name: '恢复默认可以快速重置所有自定义配置' },
                        ],
                      },
                      {
                        purpose: '恢复默认后刷新页面,配置保持为默认值',
                        precondition: [
                          { id: '1', name: '已打开httpNode节点的设置面板' },
                          { id: '2', name: '已修改过配置项并恢复为默认值' },
                        ],
                        operationSteps: [
                          { id: '1', name: '修改多个配置项' },
                          { id: '2', name: '点击恢复默认按钮' },
                          { id: '3', name: '保存设置' },
                          { id: '4', name: '刷新整个页面' },
                          { id: '5', name: '重新打开设置面板' },
                          { id: '6', name: '验证所有配置是否仍为默认值' },
                        ],
                        expectedResults: [
                          { id: '1', name: '配置成功恢复为默认值' },
                          { id: '2', name: '保存后默认值被持久化' },
                          { id: '3', name: '刷新后默认值保持不变' },
                        ],
                        checkpoints: [
                          { id: '1', name: '默认值配置持久化正确' },
                          { id: '2', name: '刷新不会改变恢复后的配置' },
                        ],
                        notes: [
                          { id: '1', name: '恢复默认的配置需要被正确保存' },
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
          // 响应区域
          {
            modelName: '响应区域',
            description: '响应区域',
            children: [
              // 响应基本信息
              {
                modelName: '请求基本信息',
                description: '请求基本信息',
                atomicFunc: [
                  {
                    purpose: '发送请求后,基本信息区域内容展示,需要展示key和value的值,请求地址,请求方式,维护人员,创建人员,创建时间,维护时间',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: '已配置请求信息' },
                    ],
                    operationSteps: [
                      { id: '1', name: '发送请求' },
                      { id: '2', name: '在响应区域查看基本信息面板' },
                      { id: '3', name: '验证所有字段内容的正确性' },
                    ],
                    expectedResults: [
                      { id: '1', name: '请求地址正确显示' },
                      { id: '2', name: '请求方式正确显示' },
                      { id: '3', name: '维护人员,创建人员信息显示' },
                      { id: '4', name: '创建时间,维护时间显示' },
                    ],
                    checkpoints: [
                      { id: '1', name: '基本信息面板所有字段完整' },
                      { id: '2', name: '信息准确对应请求配置' },
                    ],
                    notes: [
                      { id: '1', name: '基本信息用于快速了解请求概况' },
                    ],
                  },
                  {
                    purpose: '发送请求后,验证请求方法颜色,验证所有请求方法颜色',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: '已配置不同HTTP方法的请求' },
                    ],
                    operationSteps: [
                      { id: '1', name: '分别发送GET,POST,PUT,DELETE,PATCH等请求' },
                      { id: '2', name: '观察基本信息面板中请求方法的颜色' },
                      { id: '3', name: '验证每种方法颜色是否一致且易区分' },
                    ],
                    expectedResults: [
                      { id: '1', name: 'GET方法显示对应颜色(通常为绿色)' },
                      { id: '2', name: 'POST方法显示对应颜色(通常为蓝色)' },
                      { id: '3', name: 'PUT方法显示对应颜色(通常为黄色)' },
                      { id: '4', name: 'DELETE方法显示对应颜色(通常为红色)' },
                    ],
                    checkpoints: [
                      { id: '1', name: '所有HTTP方法颜色定义正确' },
                      { id: '2', name: '颜色易于区分' },
                    ],
                    notes: [
                      { id: '1', name: '颜色编码帮助快速识别请求方法' },
                    ],
                  },
                ],
              },
              //响应基本信息
              {
                modelName: '响应基本信息',
                description: '响应基本信息',
                atomicFunc: [
                  {
                    purpose: '未发送请求或者发送请求失败时候,响应基本信息展示:状态码,时长,大小,格式,并且值为?图标,鼠标移上去提示未请求数据',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: '未发送过任何请求' },
                    ],
                    operationSteps: [
                      { id: '1', name: '打开响应区域的基本信息面板' },
                      { id: '2', name: '观察状态码,时长,大小,格式的显示' },
                      { id: '3', name: '鼠标悬停在?图标上方' },
                    ],
                    expectedResults: [
                      { id: '1', name: '状态码显示为?' },
                      { id: '2', name: '时长显示为?' },
                      { id: '3', name: '大小显示为?' },
                      { id: '4', name: '悬停时显示"未请求"或类似提示' },
                    ],
                    checkpoints: [
                      { id: '1', name: '未请求状态的?图标正确显示' },
                      { id: '2', name: '提示信息清晰' },
                    ],
                    notes: [
                      { id: '1', name: '?图标表示数据未加载或不可用' },
                    ],
                  },
                  {
                    purpose: '发送请求成功,展示正确的http状态码,需要验证各种可能的状态码和颜色',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: '已配置请求' },
                    ],
                    operationSteps: [
                      { id: '1', name: '发送返回200的请求,观察状态码显示和颜色' },
                      { id: '2', name: '发送返回404的请求,观察状态码显示和颜色' },
                      { id: '3', name: '发送返回500的请求,观察状态码显示和颜色' },
                      { id: '4', name: '发送返回301的请求,观察状态码显示和颜色' },
                    ],
                    expectedResults: [
                      { id: '1', name: '200状态码显示为绿色' },
                      { id: '2', name: '404状态码显示为黄色或橙色' },
                      { id: '3', name: '500状态码显示为红色' },
                      { id: '4', name: '301状态码显示为蓝色' },
                    ],
                    checkpoints: [
                      { id: '1', name: '状态码正确显示' },
                      { id: '2', name: '颜色编码准确' },
                    ],
                    notes: [
                      { id: '1', name: '颜色编码:2xx绿色,3xx蓝色,4xx黄色/橙色,5xx红色' },
                    ],
                  },
                  {
                    purpose: '发送请求成功,展示正确的时长,需要验证时长的各种可能的颜色',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: '已配置请求' },
                    ],
                    operationSteps: [
                      { id: '1', name: '发送快速响应的请求(时长<100ms)' },
                      { id: '2', name: '观察时长显示和颜色(应为绿色)' },
                      { id: '3', name: '发送中等响应的请求(时长100-1000ms)' },
                      { id: '4', name: '观察时长显示和颜色(应为黄色)' },
                      { id: '5', name: '发送慢速响应的请求(时长>1000ms)' },
                      { id: '6', name: '观察时长显示和颜色(应为红色)' },
                    ],
                    expectedResults: [
                      { id: '1', name: '快速响应显示为绿色' },
                      { id: '2', name: '中等响应显示为黄色' },
                      { id: '3', name: '慢速响应显示为红色' },
                      { id: '4', name: '时长数值准确显示(毫秒)' },
                    ],
                    checkpoints: [
                      { id: '1', name: '时长正确计算和显示' },
                      { id: '2', name: '颜色根据时长进行分级' },
                    ],
                    notes: [
                      { id: '1', name: '时长用于性能监控' },
                    ],
                  },
                  {
                    purpose: '发送请求成功,展示正确的返回`大小`,需要验证`大小`的各种可能的颜色',
                    precondition: [
                      { id: '1', name: '已打开httpNode节点编辑页面' },
                      { id: '2', name: '已配置请求' },
                    ],
                    operationSteps: [
                      { id: '1', name: '发送返回小数据的请求(<10KB)' },
                      { id: '2', name: '观察大小显示和颜色(应为绿色)' },
                      { id: '3', name: '发送返回中等数据的请求(10-100KB)' },
                      { id: '4', name: '观察大小显示和颜色(应为黄色)' },
                      { id: '5', name: '发送返回大数据的请求(>100KB)' },
                      { id: '6', name: '观察大小显示和颜色(应为红色)' },
                    ],
                    expectedResults: [
                      { id: '1', name: '小数据显示为绿色' },
                      { id: '2', name: '中等数据显示为黄色' },
                      { id: '3', name: '大数据显示为红色' },
                      { id: '4', name: '大小数值准确显示(KB或MB)' },
                    ],
                    checkpoints: [
                      { id: '1', name: '大小正确计算和显示' },
                      { id: '2', name: '颜色根据数据大小进行分级' },
                    ],
                    notes: [
                      { id: '1', name: '大小用于性能和带宽监控' },
                    ],
                  },
                  {
                    purpose: '发送请求成功,展示正确格式',
                    precondition: [
                      { id: '1', name: '已打开apiflow应用' },
                      { id: '2', name: '已创建项目并打开项目' },
                      { id: '3', name: '已创建HTTP节点' },
                      { id: '4', name: '响应区域已收集到完整的响应数据包括状态码,响应时长,响应大小' },
                    ],
                    operationSteps: [
                      { id: '1', name: '在HTTP节点编辑器中发送请求到可用的API端点' },
                      { id: '2', name: '观察响应基本信息的布局和显示格式' },
                      { id: '3', name: '验证各个指标信息的排列和对齐方式' },
                      { id: '4', name: '检查响应基本信息与其他响应区域的距离和边距' },
                    ],
                    expectedResults: [
                      { id: '1', name: '响应基本信息区域正确显示所有指标:状态码,响应时长,响应大小,返回值格式' },
                      { id: '2', name: '各个指标之间有合理的间距,不会出现重叠或拥挤的情况' },
                      { id: '3', name: '响应基本信息区域与返回值,请求信息等其他区域保持视觉上的一致性' },
                      { id: '4', name: '信息格式清晰易读,所有文本,数值,图标都正确对齐' },
                    ],
                    checkpoints: [
                      { id: '1', name: '验证状态码,响应时长,响应大小都显示出来' },
                      { id: '2', name: '验证每个指标的颜色编码与状态相符' },
                      { id: '3', name: '验证响应基本信息区域与下方返回值区域有合适的分隔距离' },
                      { id: '4', name: '验证在不同窗口宽度下布局仍然正确' },
                    ],
                    notes: [
                      { id: '1', name: '此测试用例验证整个响应基本信息区域的综合展示效果' },
                      { id: '2', name: '需要确保所有指标在各种响应大小和状态码下都能正确显示' },
                      { id: '3', name: '应关注视觉层级和空间使用的合理性' },
                    ],
                  },
                ],
              },
              //响应详情
              {
                modelName: '响应详情',
                description: '响应详情',
                children: [
                  {
                    modelName: '返回值',
                    description: '返回值',
                    atomicFunc: [
                      {
                        purpose: '返回值类型为json格式,正确展示json数据,json返回区域距离底部有合理的距离',
                        precondition: [
                          { id: '1', name: '已打开apiflow应用' },
                          { id: '2', name: '已创建项目并打开项目' },
                          { id: '3', name: '已创建HTTP节点' },
                          { id: '4', name: '已发送请求到返回JSON数据的API端点(如https://jsonplaceholder.typicode.com/posts/1)' },
                        ],
                        operationSteps: [
                          { id: '1', name: '在HTTP节点编辑器中发送请求到返回JSON格式的API' },
                          { id: '2', name: '查看响应区域中的返回值标签页' },
                          { id: '3', name: '观察JSON数据的显示格式,缩进和高亮情况' },
                          { id: '4', name: '检查JSON树形结构的展开/折叠功能' },
                          { id: '5', name: '验证返回值区域与窗口底部的距离' },
                        ],
                        expectedResults: [
                          { id: '1', name: 'JSON数据正确显示,包括所有字段和嵌套结构' },
                          { id: '2', name: 'JSON语法高亮正确应用,不同类型的值有不同的颜色' },
                          { id: '3', name: 'JSON树形结构可以正确展开和折叠' },
                          { id: '4', name: '返回值区域与窗口底部保持合理的内边距,内容不会被遮挡' },
                          { id: '5', name: '大型JSON对象能正确显示,不会出现截断或显示错误' },
                        ],
                        checkpoints: [
                          { id: '1', name: '验证JSON格式的完整性和正确性' },
                          { id: '2', name: '验证嵌套对象和数组的展示' },
                          { id: '3', name: '验证JSON值的数据类型颜色编码正确(字符串,数字,布尔值等)' },
                          { id: '4', name: '验证返回值区域能容纳完整内容并可滚动' },
                          { id: '5', name: '验证在不同窗口大小下JSON显示没有问题' },
                        ],
                        notes: [
                          { id: '1', name: '此测试关键验证JSON渲染引擎的正确性' },
                          { id: '2', name: '需要测试包含深度嵌套的复杂JSON结构' },
                          { id: '3', name: '应该测试包含各种数据类型的JSON(null, boolean, number, string, array, object)' },
                        ],
                      },
                    ],
                  },
                  {
                    modelName: '请求信息',
                    description: '请求信息',
                    atomicFunc: [
                      {
                        purpose: '请求信息区域基本信息,请求头,请求body正确展示,请求信息区域距离底部有合理的距离',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          '已发送包含请求头和Body数据的请求(如POST请求)',
                        ],
                        operationSteps: [
                          '1. 在HTTP节点编辑器中发送POST或PUT请求',
                          '2. 在响应区域查看"请求信息"标签页',
                          '3. 观察基本信息部分(方法,URL,协议)',
                          '4. 检查请求头部分的显示和展示方式',
                          '5. 查看请求Body部分的格式和内容',
                          '6. 验证请求信息区域与底部的距离',
                        ],
                        expectedResults: [
                          '基本信息正确显示:HTTP方法,完整URL,协议版本',
                          '请求头正确显示,包括所有自定义头和系统头',
                          '请求Body正确显示,格式化正确(JSON/FormData/URLEncoded)',
                          '不同的Body类型显示格式正确',
                          '请求信息区域与窗口底部保持合理距离,内容完整可见',
                        ],
                        checkpoints: [
                          '验证HTTP方法,URL,协议版本正确显示',
                          '验证请求头列表的完整性',
                          '验证请求头值正确,包括特殊字符',
                          '验证Body内容完整,没有被截断',
                          '验证Body的格式化正确(缩进,高亮)',
                          '验证请求信息可以正常滚动',
                        ],
                        notes: [
                          '此测试验证HTTP请求信息的完整记录和展示',
                          '需要测试包含各种Body类型的请求(JSON,FormData,URLEncoded,Raw)',
                          '应验证自定义请求头正确传输并显示',
                          '应检查大型Body的显示(性能,截断)',
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'responseHeader',
                    description: '返回头',
                    atomicFunc: [
                      {
                        purpose: '返回头正确展示,左右布局时候展示请求头详情按钮,上下布局不展示详情按钮',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          '已发送请求到返回响应头的API端点',
                        ],
                        operationSteps: [
                          '1. 在HTTP节点编辑器中发送请求',
                          '2. 在响应区域查看"响应头"标签页',
                          '3. 观察响应头的显示列表',
                          '4. 在左右布局模式下查看是否显示详情按钮',
                          '5. 切换到上下布局模式,检查详情按钮是否隐藏',
                          '6. 验证各个响应头的完整信息',
                        ],
                        expectedResults: [
                          '响应头正确显示,包括Content-Type,Content-Length等标准头',
                          '左右布局模式下显示响应头详情按钮',
                          '上下布局模式下隐藏响应头详情按钮',
                          '响应头列表能显示所有返回的头信息',
                          '响应头值正确显示,包括特殊字符和长值',
                        ],
                        checkpoints: [
                          '验证响应头列表的完整性',
                          '验证响应头值的准确性',
                          '验证详情按钮在左右布局模式下出现',
                          '验证详情按钮在上下布局模式下隐藏',
                          '验证响应头标题和值的对齐方式',
                        ],
                        notes: [
                          '此测试验证响应头的正确展示和布局自适应',
                          '需要测试包含各种类型响应头的请求',
                          '应验证自定义响应头的显示',
                          '应检查长值响应头的截断和完整显示',
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'responseCookie',
                    description: '返回cookie',
                    atomicFunc: [
                      {
                        purpose: '返回cookie正确展示,左右布局时候展示cookie管理按钮和详情按钮,上下布局不展示详情按钮,cookie值需要正确展示(测试请求需要设置cookie,并且在返回cookie中正确展示)',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          '已在请求头中手动设置Cookie头',
                          '已发送请求到支持Set-Cookie返回头的API端点',
                        ],
                        operationSteps: [
                          '1. 在HTTP节点编辑器中的请求头里设置Cookie头(如Cookie: test=value123)',
                          '2. 发送请求到支持返回Set-Cookie的API',
                          '3. 在响应区域查看"返回Cookie"标签页',
                          '4. 在左右布局模式下查看Cookie管理和详情按钮',
                          '5. 切换到上下布局模式,检查详情按钮是否隐藏',
                          '6. 验证返回的Cookie值是否正确展示',
                        ],
                        expectedResults: [
                          '返回的Cookie值正确显示',
                          '左右布局模式下显示Cookie管理按钮和详情按钮',
                          '上下布局模式下隐藏详情按钮',
                          'Cookie值包括名称,值,域,路径,过期时间等完整信息',
                          '发送的Cookie和返回的Cookie能正确区分显示',
                        ],
                        checkpoints: [
                          '验证返回Cookie列表的完整性',
                          '验证Cookie值的准确性',
                          '验证Cookie管理按钮在左右布局显示',
                          '验证Cookie详情按钮在左右布局显示,在上下布局隐藏',
                          '验证Cookie属性(Domain, Path, Expires, HttpOnly等)的显示',
                          '验证Cookie值可以手动添加到Cookie存储',
                        ],
                        notes: [
                          '此测试验证Cookie的完整展示和管理功能',
                          '需要测试包含多个Cookie的响应',
                          '应验证Cookie的持久化和跨请求使用',
                          '应测试包含特殊字符和编码的Cookie值',
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'rawValue',
                    description: '原始值',
                    atomicFunc: [
                      {
                        purpose: '原始值需要正确返回',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          '已发送请求获得响应',
                        ],
                        operationSteps: [
                          '1. 在HTTP节点编辑器中发送请求',
                          '2. 在响应区域查看"原始值"标签页',
                          '3. 观察原始响应数据的显示内容',
                          '4. 检查数据的完整性和准确性',
                          '5. 验证原始值与其他格式化显示的一致性',
                        ],
                        expectedResults: [
                          '原始值标签页显示完整的未经处理的响应数据',
                          '原始值与JSON/其他格式化显示的内容一致',
                          '原始值包含所有响应体的字节数据',
                          '原始值能正确显示二进制或非UTF-8编码的数据',
                          '原始值支持复制和搜索功能',
                        ],
                        checkpoints: [
                          '验证原始值内容的完整性',
                          '验证原始值数据与请求响应的准确性',
                          '验证原始值与其他格式化视图的内容一致',
                          '验证大型原始值的显示和性能',
                          '验证原始值能正确处理特殊字符和编码',
                          '验证原始值的复制功能可用',
                        ],
                        notes: [
                          '此测试验证原始响应数据的准确展示',
                          '原始值是调试HTTP通信的重要工具',
                          '应测试各种Content-Type的响应(JSON,HTML,XML,Binary等)',
                          '应验证大文件和流式响应的原始值显示',
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
          // 功能验证
          {
            modelName: 'httpNode功能验证',
            description: 'httpNode功能验证',
            children: [
              // 请求方法
              {
                modelName: '请求方法验证',
                description: '请求方法验证',
                atomicFunc: [
                  {
                    purpose: '更改所有的请求方法,调用echo接口,请求方法正确',
                    precondition: [
                      '已打开apiflow应用',
                      '已创建项目并打开项目',
                      '已创建HTTP节点',
                      '已设置Echo API的URL(如:https://httpbin.org/anything)',
                    ],
                    operationSteps: [
                      '1. 在HTTP节点编辑器中打开请求方法下拉菜单',
                      '2. 依次选择并测试所有HTTP方法:GET,POST,PUT,DELETE,PATCH,HEAD,OPTIONS',
                      '3. 对每个方法发送请求到Echo API',
                      '4. 检查响应中返回的请求方法是否与选择的方法一致',
                      '5. 验证方法变更后的UI更新',
                    ],
                    expectedResults: [
                      '所有HTTP方法都可以正确选择和切换',
                      '每个方法发送的请求的Method头与选择的方法一致',
                      'Echo API返回的method字段与实际发送的方法匹配',
                      '方法切换后,UI立即更新显示新的方法',
                      '不同的HTTP方法能正确处理(例如HEAD方法不返回body)',
                    ],
                    checkpoints: [
                      '验证GET方法能正常发送',
                      '验证POST方法能正常发送',
                      '验证PUT方法能正常发送',
                      '验证DELETE方法能正常发送',
                      '验证PATCH方法能正常发送',
                      '验证HEAD方法响应不包含body',
                      '验证OPTIONS方法返回Allow头',
                      '验证方法名称显示正确',
                    ],
                    notes: [
                      '此测试验证所有HTTP方法的基础功能',
                      'Echo API应该是支持所有方法的测试端点',
                      '需要验证方法选择器的UI状态和响应体的一致性',
                    ],
                  },
                ],
              },
              // 请求url
              {
                modelName: '请求url验证',
                description: '请求url验证',
                atomicFunc: [
                  {
                    purpose: '验证localhost格式的url,调用echo接口,能正确请求,并且显示正确的url地址',
                    precondition: [
                      '已打开apiflow应用',
                      '已创建项目并打开项目',
                      '已创建HTTP节点',
                      '本地已部署Echo服务或Mock服务',
                    ],
                    operationSteps: [
                      '1. 在HTTP节点的URL字段中输入localhost格式的URL(如http://localhost:3000/api/echo)',
                      '2. 发送请求',
                      '3. 查看响应中的请求URL信息',
                      '4. 验证显示的URL与输入的URL一致',
                      '5. 检查响应中返回的host头是否正确',
                    ],
                    expectedResults: [
                      'localhost格式的URL能正确解析和请求',
                      '请求能正常发送到本地服务',
                      '响应中显示的URL为localhost格式,而不是其他格式',
                      '响应正确返回,状态码200',
                      'localhost端口号能正确传递',
                    ],
                    checkpoints: [
                      '验证localhost URL能正常发送请求',
                      '验证请求信息中显示的URL正确',
                      '验证localhost被正确解析为本地回环地址',
                      '验证端口号正确',
                      '验证协议(http/https)正确',
                    ],
                    notes: [
                      '此测试验证localhost格式URL的支持',
                      '需要确保本地服务运行',
                    ],
                  },
                  {
                    purpose: '验证127.0.0.1这样的ip url,调用echo接口,能正确请求,并且显示正确的url地址',
                    precondition: [
                      '已打开apiflow应用',
                      '已创建项目并打开项目',
                      '已创建HTTP节点',
                      '本地已部署Echo服务或Mock服务',
                    ],
                    operationSteps: [
                      '1. 在HTTP节点的URL字段中输入IP格式的URL(如http://127.0.0.1:3000/api/echo)',
                      '2. 发送请求',
                      '3. 查看响应中的请求URL信息',
                      '4. 验证显示的URL与输入的URL一致',
                      '5. 检查响应中返回的host头是否正确',
                    ],
                    expectedResults: [
                      '127.0.0.1格式的URL能正确解析和请求',
                      '请求能正常发送到本地IP地址',
                      '响应中显示的URL为IP格式,而不是其他格式',
                      '响应正确返回,状态码200',
                      'IP和端口号能正确传递',
                    ],
                    checkpoints: [
                      '验证IP格式URL能正常发送请求',
                      '验证请求信息中显示的URL正确',
                      '验证127.0.0.1被正确解析',
                      '验证端口号正确',
                      '验证协议(http/https)正确',
                    ],
                    notes: [
                      '此测试验证IP格式URL的支持',
                      '需要确保本地服务运行',
                      '应该测试不同的IP地址格式(IPv4,IPv6)',
                    ],
                  },
                ],
              },
              // query参数
              {
                modelName: 'query参数验证',
                description: 'query参数验证',
                atomicFunc: [
                  {
                    purpose: '调用echo接口验证参数为空是否正常返回/echo?id=',
                    precondition: [
                      '已打开apiflow应用',
                      '已创建项目并打开项目',
                      '已创建HTTP节点',
                      'Echo服务可用',
                    ],
                    operationSteps: [
                      '1. 在Query参数区域添加参数:id=(空值)',
                      '2. 设置URL为echo接口',
                      '3. 发送请求',
                      '4. 查看请求URL和响应body',
                    ],
                    expectedResults: [
                      '空参数能正确添加到URL中',
                      '请求发送成功,响应为200',
                      'Echo返回的参数中包含id=',
                      'URL显示为/echo?id=',
                    ],
                    checkpoints: [
                      '验证空参数被正确包含在URL中',
                      '验证Echo服务正确接收空参数',
                      '验证响应中能看到id参数',
                    ],
                    notes: [
                      '此测试验证空参数值的处理',
                      '需要确保URL编码正确',
                    ],
                  },
                  {
                    purpose: '调用echo接口验证常规参数是否正常返回/echo?id=1',
                    precondition: [
                      '已打开apiflow应用',
                      '已创建项目并打开项目',
                      '已创建HTTP节点',
                      'Echo服务可用',
                    ],
                    operationSteps: [
                      '1. 在Query参数区域添加参数:id=1',
                      '2. 设置URL为echo接口',
                      '3. 发送请求',
                      '4. 查看请求URL和响应body',
                    ],
                    expectedResults: [
                      '参数正确添加到URL中',
                      '请求发送成功,响应为200',
                      'Echo返回的参数中id值为1',
                      'URL正确显示为/echo?id=1',
                    ],
                    checkpoints: [
                      '验证参数被正确包含在URL中',
                      '验证Echo服务正确接收参数',
                      '验证参数值的准确性',
                    ],
                    notes: [
                      '此测试验证常规query参数的处理',
                    ],
                  },
                  {
                    purpose: '调用echo接口验证同名参数是否正常返回/echo?id=1&id=3',
                    precondition: [
                      '已打开apiflow应用',
                      '已创建项目并打开项目',
                      '已创建HTTP节点',
                      'Echo服务可用',
                    ],
                    operationSteps: [
                      '1. 在Query参数区域添加两条同名参数:id=1 和 id=3',
                      '2. 设置URL为echo接口',
                      '3. 发送请求',
                      '4. 查看请求URL和响应body',
                    ],
                    expectedResults: [
                      '同名参数都能正确添加到URL中',
                      '请求发送成功,响应为200',
                      'URL中包含两个id参数:id=1&id=3',
                      'Echo返回两个id参数值',
                    ],
                    checkpoints: [
                      '验证同名参数都被包含在URL中',
                      '验证参数顺序保持不变',
                      '验证Echo服务能处理多个同名参数',
                    ],
                    notes: [
                      '此测试验证多个同名参数的处理',
                      '有些API框架将多个同名参数作为数组处理',
                    ],
                  },
                  {
                    purpose: '调用echo接口验证中文参数是否正常返回/echo?name=张三&tag=a+b',
                    precondition: [
                      '已打开apiflow应用',
                      '已创建项目并打开项目',
                      '已创建HTTP节点',
                      'Echo服务可用',
                    ],
                    operationSteps: [
                      '1. 在Query参数区域添加中文参数:name=张三',
                      '2. 添加包含空格的参数:tag=a b',
                      '3. 设置URL为echo接口',
                      '4. 发送请求',
                      '5. 查看请求URL和响应body',
                    ],
                    expectedResults: [
                      '中文参数能正确URL编码',
                      '空格被正确编码为+或%20',
                      '请求发送成功,响应为200',
                      'Echo返回正确的参数值(自动解码)',
                      'URL显示正确的编码格式',
                    ],
                    checkpoints: [
                      '验证中文参数的URL编码',
                      '验证空格编码为+',
                      '验证Echo服务能正确解码中文参数',
                      '验证参数值正确显示',
                    ],
                    notes: [
                      '此测试验证特殊字符和多字节字符的处理',
                      '需要确保UTF-8编码正确',
                      '中文字符需要URL编码为%XX格式',
                    ],
                  },
                ],
              },
              // path参数
              {
                modelName: 'path参数验证',
                description: 'path参数验证',
                atomicFunc: [
                  {
                    purpose: '调用echo接口验证path参数是否正常返回',
                    precondition: [
                      '已打开apiflow应用',
                      '已创建项目并打开项目',
                      '已创建HTTP节点',
                      'Echo服务支持path参数(如/api/users/:id/posts/:postId)',
                    ],
                    operationSteps: [
                      '1. 设置URL包含path参数占位符(如http://api.example.com/users/:userId/posts/:postId)',
                      '2. 在Path参数区域添加实际参数值:userId=123, postId=456',
                      '3. 发送请求',
                      '4. 查看实际请求的URL',
                      '5. 验证响应中的参数值',
                    ],
                    expectedResults: [
                      'Path参数占位符被正确替换',
                      '最终请求URL为/users/123/posts/456',
                      '请求发送成功,响应为200',
                      'Echo返回的path值与输入的参数一致',
                      '多个path参数都能正确替换',
                    ],
                    checkpoints: [
                      '验证path参数占位符被正确识别',
                      '验证参数值正确替换到URL中',
                      '验证URL编码正确',
                      '验证多个path参数的替换',
                      '验证中文path参数的处理',
                    ],
                    notes: [
                      '此测试验证RESTful API的path参数支持',
                      'Path参数通常用于RESTful API设计',
                      '需要确保参数占位符的识别和替换',
                    ],
                  },
                ],
              },
              // body参数
              {
                modelName: 'body参数',
                description: 'body参数',
                children: [
                  {
                    modelName: 'json类型body验证',
                    description: 'json类型body验证',
                    atomicFunc: [
                      {
                        purpose: '调用echo接口验证常规json是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择JSON类型',
                          '3. 输入常规JSON数据:{"name":"test","age":20,"active":true}',
                          '4. 发送请求',
                          '5. 检查请求头中的Content-Type',
                          '6. 查看Echo返回的body',
                        ],
                        expectedResults: [
                          '常规JSON数据正确发送',
                          'Content-Type自动设置为application/json',
                          'Echo返回的body与发送的JSON一致',
                          '状态码为200',
                          'JSON格式正确,能正确解析',
                        ],
                        checkpoints: [
                          '验证JSON数据的完整性',
                          '验证Content-Type设置正确',
                          '验证JSON嵌套结构正确发送',
                          '验证特殊字符的处理',
                        ],
                        notes: [
                          '此测试验证常规JSON body的处理',
                          'Content-Type应该自动设置',
                        ],
                      },
                      {
                        purpose: '调用echo接口验证使用变量(所有类型变量都需要验证)的json是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          '已创建项目级别变量:globalVar=global_value',
                          '已创建环境变量:envVar=env_value',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择JSON类型',
                          '3. 输入包含变量的JSON:{"global":"{{globalVar}}","env":"{{envVar}}","local":"{{localVar}}"}',
                          '4. 在Session Variables中临时设置localVar=local_value',
                          '5. 发送请求',
                          '6. 查看Echo返回的body和变量是否正确替换',
                        ],
                        expectedResults: [
                          '所有变量类型都被正确替换',
                          '全局变量,环境变量,本地变量都能正常工作',
                          'Content-Type自动设置为application/json',
                          'Echo返回的body显示变量已被替换',
                          '状态码为200',
                        ],
                        checkpoints: [
                          '验证全局变量替换',
                          '验证环境变量替换',
                          '验证Session变量替换',
                          '验证变量不存在时的处理',
                          '验证Content-Type正确',
                        ],
                        notes: [
                          '此测试验证JSON中的变量替换功能',
                          '需要测试所有类型的变量',
                        ],
                      },
                      {
                        purpose: '调用echo接口验证使用mock(验证所有mock字段)的json是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择JSON类型',
                          '3. 输入包含mock数据的JSON:{"id":"@id","name":"@cname","email":"@email","mobile":"@mobile"}',
                          '4. 发送请求',
                          '5. 查看Echo返回的body',
                          '6. 验证mock数据已被生成',
                        ],
                        expectedResults: [
                          'Mock数据正确生成替换',
                          '各种mock字段都能正常工作(id,name,email,phone等)',
                          'Content-Type自动设置为application/json',
                          'Echo返回真实的生成数据,而非@notation',
                          '状态码为200',
                        ],
                        checkpoints: [
                          '验证各种mock字段的生成',
                          '验证数据的随机性(多次请求数据不同)',
                          '验证Content-Type正确',
                          '验证数据格式符合mock类型',
                        ],
                        notes: [
                          '此测试验证mock数据生成功能',
                          '需要测试所有支持的mock字段类型',
                        ],
                      },
                      {
                        purpose: '调用echo接口验证使用基础类型的json(例如: null,1,true, "string")是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择JSON类型',
                          '3. 分别测试不同基础类型:',
                          '   - null',
                          '   - 数字:123',
                          '   - 布尔值:true',
                          '   - 字符串:"hello world"',
                          '   - 数组:[1,2,3]',
                          '4. 每种类型都发送一次请求',
                          '5. 查看Echo返回的body和类型',
                        ],
                        expectedResults: [
                          '所有基础JSON类型都能正确发送',
                          'Content-Type自动设置为application/json',
                          'Echo正确识别和返回数据类型',
                          '状态码为200',
                          '数据类型保留正确(数字不转为字符串等)',
                        ],
                        checkpoints: [
                          '验证null类型',
                          '验证数字类型',
                          '验证布尔值类型',
                          '验证字符串类型',
                          '验证数组类型',
                          '验证Content-Type正确',
                        ],
                        notes: [
                          '此测试验证JSON基础类型的处理',
                          '确保数据类型在发送和接收时保持一致',
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'formdata类型body验证',
                    description: 'formdata类型body验证',
                    atomicFunc: [
                      {
                        purpose: '调用echo接口验证常规formdata是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择FormData类型',
                          '3. 添加表单字段:name=test, email=test@example.com, age=25',
                          '4. 发送请求',
                          '5. 检查请求头中的Content-Type',
                          '6. 查看Echo返回的body',
                        ],
                        expectedResults: [
                          'FormData数据正确发送',
                          'Content-Type自动设置为multipart/form-data',
                          'Echo返回的form数据与发送的数据一致',
                          '状态码为200',
                          '所有表单字段都正确传输',
                        ],
                        checkpoints: [
                          '验证FormData数据的完整性',
                          '验证Content-Type和boundary设置正确',
                          '验证所有字段都被正确发送',
                        ],
                        notes: [
                          '此测试验证FormData类型body的处理',
                          'Content-Type应该自动设置为multipart/form-data',
                        ],
                      },
                      {
                        purpose: '调用echo接口验证使用变量(所有类型变量都需要验证)的formdata是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          '已创建项目变量:projectVar=project_value',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择FormData类型',
                          '3. 添加表单字段,其中包含变量:name={{projectVar}}, desc={{envVar}}',
                          '4. 发送请求',
                          '5. 查看变量是否被正确替换',
                        ],
                        expectedResults: [
                          '变量在FormData中被正确替换',
                          'Content-Type正确设置',
                          'Echo返回替换后的值',
                          '状态码为200',
                        ],
                        checkpoints: [
                          '验证FormData中的变量替换',
                          '验证Content-Type正确',
                        ],
                        notes: [
                          '此测试验证FormData中的变量替换',
                        ],
                      },
                      {
                        purpose: '调用echo接口验证使用mock(验证所有mock字段)的formdata是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择FormData类型',
                          '3. 添加包含mock的表单字段:id=@id, email=@email, name=@cname',
                          '4. 发送请求',
                          '5. 查看mock数据是否正确生成',
                        ],
                        expectedResults: [
                          'Mock数据在FormData中被正确生成',
                          'Content-Type正确设置',
                          'Echo返回生成的真实数据',
                          '状态码为200',
                        ],
                        checkpoints: [
                          '验证FormData中的mock数据生成',
                          '验证Content-Type正确',
                        ],
                        notes: [
                          '此测试验证FormData中的mock功能',
                        ],
                      },
                      {
                        purpose: '调用echo接口验证文件上传是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          '系统中存在可上传的文件',
                          'Echo服务支持文件上传',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择FormData类型',
                          '3. 添加普通字段和文件字段',
                          '4. 点击文件输入,选择本地文件',
                          '5. 发送请求',
                          '6. 查看上传结果',
                        ],
                        expectedResults: [
                          '文件正确上传',
                          'Content-Type设置为multipart/form-data',
                          'Echo返回上传的文件信息',
                          '文件内容被正确传输',
                          '状态码为200',
                        ],
                        checkpoints: [
                          '验证文件选择功能',
                          '验证文件上传功能',
                          '验证Content-Type正确',
                          '验证大文件上传',
                        ],
                        notes: [
                          '此测试验证文件上传功能',
                          '应测试不同大小和类型的文件',
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'formData类型body验证(文件上传)',
                    description: 'formData类型body验证(文件上传)',
                    atomicFunc: [
                      {
                        purpose: '调用echo接口验证包含字符串和file类型的formData是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          '本地存在可上传的文件',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择FormData类型',
                          '3. 添加字符串字段:username=testuser, description=test file upload',
                          '4. 添加文件字段并选择本地文件',
                          '5. 发送请求',
                          '6. 查看Echo返回的结果',
                        ],
                        expectedResults: [
                          '字符串和文件都正确上传',
                          'Content-Type正确设置为multipart/form-data',
                          'Echo返回所有字段信息',
                          '文件内容正确传输',
                          '状态码为200',
                        ],
                        checkpoints: [
                          '验证字符串字段上传',
                          '验证文件字段上传',
                          '验证Content-Type正确',
                          '验证文件内容完整',
                        ],
                        notes: [
                          '此测试验证混合类型FormData上传',
                        ],
                      },
                      {
                        purpose: '调用echo接口验证formData录入value如果是变量(验证所有变量类型)是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          '已创建项目变量',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择FormData类型',
                          '3. 添加包含变量的字段:name={{globalVar}}, env={{envVar}}',
                          '4. 发送请求',
                          '5. 验证变量替换',
                        ],
                        expectedResults: [
                          '所有变量类型都被正确替换',
                          'Content-Type正确设置',
                          'Echo返回替换后的值',
                          '状态码为200',
                        ],
                        checkpoints: [
                          '验证FormData变量替换',
                          '验证Content-Type正确',
                        ],
                        notes: [
                          '此测试验证FormData中的变量功能',
                        ],
                      },
                      {
                        purpose: '调用echo接口验证formData录入value如果是mock(验证所有的mock值)是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择FormData类型',
                          '3. 添加包含mock的字段:id=@id, phone=@mobile, email=@email',
                          '4. 发送请求',
                          '5. 验证mock数据生成',
                        ],
                        expectedResults: [
                          'Mock数据正确生成',
                          'Content-Type正确设置',
                          'Echo返回生成的真实数据',
                          '状态码为200',
                        ],
                        checkpoints: [
                          '验证FormData中的mock生成',
                          '验证Content-Type正确',
                        ],
                        notes: [
                          '此测试验证FormData中的mock功能',
                        ],
                      },
                      {
                        purpose: '调用echo接口验证formData中没有file字段时是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择FormData类型',
                          '3. 添加多个纯字符串字段,不添加文件',
                          '4. 发送请求',
                          '5. 检查Content-Type和响应',
                        ],
                        expectedResults: [
                          '纯字符串FormData能正常发送',
                          'Content-Type设置为multipart/form-data',
                          'Echo返回所有字段',
                          '状态码为200',
                        ],
                        checkpoints: [
                          '验证纯字符串FormData',
                          '验证Content-Type正确',
                        ],
                        notes: [
                          '此测试验证无文件的FormData',
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'urlencoded类型body验证',
                    description: 'urlencoded类型body验证',
                    atomicFunc: [
                      {
                        purpose: '调用echo接口验证urlencoded参数是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择URLEncoded类型',
                          '3. 添加参数字段:username=test, password=123456, remember=true',
                          '4. 发送请求',
                          '5. 检查Content-Type和响应',
                        ],
                        expectedResults: [
                          'URLEncoded数据正确编码和发送',
                          'Content-Type自动设置为application/x-www-form-urlencoded',
                          'Echo返回解析后的参数',
                          '参数值正确显示',
                          '状态码为200',
                        ],
                        checkpoints: [
                          '验证URLEncoded格式',
                          '验证Content-Type正确',
                          '验证参数编码',
                          '验证特殊字符处理',
                        ],
                        notes: [
                          '此测试验证URLEncoded body类型',
                          '这是表单提交的常见格式',
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'raw类型body验证',
                    description: 'raw类型body验证',
                    atomicFunc: [
                      {
                        purpose: '调用echo接口验证text格式参数是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择Raw类型',
                          '3. 选择Text格式',
                          '4. 输入纯文本内容',
                          '5. 发送请求',
                          '6. 检查Content-Type和响应',
                        ],
                        expectedResults: [
                          '纯文本正确发送',
                          'Content-Type正确设置为text/plain',
                          'Echo返回原始文本内容',
                          '状态码为200',
                        ],
                        checkpoints: [
                          '验证Text格式发送',
                          '验证Content-Type正确',
                          '验证文本内容完整',
                        ],
                        notes: [
                          '此测试验证Raw Text类型',
                        ],
                      },
                      {
                        purpose: '调用echo接口验证html格式参数是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择Raw类型',
                          '3. 选择HTML格式',
                          '4. 输入HTML内容:<html><body><h1>Test</h1></body></html>',
                          '5. 发送请求',
                          '6. 检查Content-Type和响应',
                        ],
                        expectedResults: [
                          'HTML正确发送',
                          'Content-Type正确设置为text/html',
                          'Echo返回HTML内容',
                          '状态码为200',
                        ],
                        checkpoints: [
                          '验证HTML格式发送',
                          '验证Content-Type正确',
                          '验证HTML标签完整',
                        ],
                        notes: [
                          '此测试验证Raw HTML类型',
                        ],
                      },
                      {
                        purpose: '调用echo接口验证xml格式参数是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择Raw类型',
                          '3. 选择XML格式',
                          '4. 输入XML内容:<?xml version="1.0"?><root><name>test</name></root>',
                          '5. 发送请求',
                          '6. 检查Content-Type和响应',
                        ],
                        expectedResults: [
                          'XML正确发送',
                          'Content-Type正确设置为application/xml',
                          'Echo返回XML内容',
                          'XML格式保留',
                          '状态码为200',
                        ],
                        checkpoints: [
                          '验证XML格式发送',
                          '验证Content-Type正确',
                          '验证XML结构完整',
                        ],
                        notes: [
                          '此测试验证Raw XML类型',
                        ],
                      },
                      {
                        purpose: '调用echo接口验证javascript格式参数是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择Raw类型',
                          '3. 选择JavaScript格式',
                          '4. 输入JavaScript代码',
                          '5. 发送请求',
                          '6. 检查Content-Type和响应',
                        ],
                        expectedResults: [
                          'JavaScript代码正确发送',
                          'Content-Type正确设置为application/javascript',
                          'Echo返回代码内容',
                          '状态码为200',
                        ],
                        checkpoints: [
                          '验证JavaScript格式发送',
                          '验证Content-Type正确',
                          '验证代码内容完整',
                        ],
                        notes: [
                          '此测试验证Raw JavaScript类型',
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'binary类型body验证',
                    description: 'binary类型body验证',
                    atomicFunc: [
                      {
                        purpose: '调用echo接口验证binary变量模式请求是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          '本地存在二进制文件',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择Binary类型',
                          '3. 创建或选择一个二进制文件',
                          '4. 发送请求',
                          '5. 检查二进制数据传输',
                        ],
                        expectedResults: [
                          '二进制文件正确上传',
                          '文件内容被正确传输',
                          'Content-Type设置正确',
                          'Echo返回文件信息',
                          '状态码为200',
                        ],
                        checkpoints: [
                          '验证二进制文件上传',
                          '验证文件大小',
                          '验证Content-Type',
                        ],
                        notes: [
                          '此测试验证Binary类型body',
                        ],
                      },
                      {
                        purpose: '调用echo接口验证binary文件模式请求是否正常返回,content-type是否设置正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          '本地存在文件',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择POST方法',
                          '2. 在Body区域选择Binary类型',
                          '3. 使用文件模式选择文件',
                          '4. 发送请求',
                          '5. 检查文件传输',
                        ],
                        expectedResults: [
                          '文件正确发送',
                          '文件内容被完整传输',
                          'Content-Type正确',
                          '状态码为200',
                        ],
                        checkpoints: [
                          '验证文件上传',
                          '验证文件大小',
                          '验证Content-Type',
                        ],
                        notes: [
                          '此测试验证Binary文件上传模式',
                        ],
                      },
                    ],
                  },
                  {
                    modelName: 'none类型body验证',
                    description: 'none类型body验证',
                    atomicFunc: [
                      {
                        purpose: '调用echo接口验证body为none请求是否正常返回,content-type是否正确',
                        precondition: [
                          '已打开apiflow应用',
                          '已创建项目并打开项目',
                          '已创建HTTP节点',
                          'Echo服务可用',
                        ],
                        operationSteps: [
                          '1. 选择GET或DELETE方法',
                          '2. 在Body区域选择None类型(不发送body)',
                          '3. 发送请求',
                          '4. 检查请求是否正确',
                        ],
                        expectedResults: [
                          '请求正确发送,不包含body',
                          'Content-Type不被设置(或自动处理)',
                          'Echo返回正确响应',
                          '状态码为200',
                        ],
                        checkpoints: [
                          '验证不发送body',
                          '验证Content-Type处理',
                          '验证请求成功',
                        ],
                        notes: [
                          '此测试验证None类型body(无body请求)',
                          'GET/DELETE请求通常不需要body',
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
    ],
  },
];

